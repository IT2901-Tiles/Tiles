{"ast":null,"code":"'use strict';\n\nconst OperationBase = require('./operation').OperationBase;\n\nconst BulkWriteOperation = require('./bulk_write');\n\nconst MongoError = require('../core').MongoError;\n\nconst prepareDocs = require('./common_functions').prepareDocs;\n\nclass InsertManyOperation extends OperationBase {\n  constructor(collection, docs, options) {\n    super(options);\n    this.collection = collection;\n    this.docs = docs;\n  }\n\n  execute(callback) {\n    const coll = this.collection;\n    let docs = this.docs;\n    const options = this.options;\n\n    if (!Array.isArray(docs)) {\n      return callback(MongoError.create({\n        message: 'docs parameter must be an array of documents',\n        driver: true\n      }));\n    } // If keep going set unordered\n\n\n    options['serializeFunctions'] = options['serializeFunctions'] || coll.s.serializeFunctions;\n    docs = prepareDocs(coll, docs, options); // Generate the bulk write operations\n\n    const operations = [{\n      insertMany: docs\n    }];\n    const bulkWriteOperation = new BulkWriteOperation(coll, operations, options);\n    bulkWriteOperation.execute((err, result) => {\n      if (err) return callback(err, null);\n      callback(null, mapInsertManyResults(docs, result));\n    });\n  }\n\n}\n\nfunction mapInsertManyResults(docs, r) {\n  const finalResult = {\n    result: {\n      ok: 1,\n      n: r.insertedCount\n    },\n    ops: docs,\n    insertedCount: r.insertedCount,\n    insertedIds: r.insertedIds\n  };\n\n  if (r.getLastOp()) {\n    finalResult.result.opTime = r.getLastOp();\n  }\n\n  return finalResult;\n}\n\nmodule.exports = InsertManyOperation;","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/operations/insert_many.js"],"names":["OperationBase","require","BulkWriteOperation","MongoError","prepareDocs","InsertManyOperation","constructor","collection","docs","options","execute","callback","coll","Array","isArray","create","message","driver","s","serializeFunctions","operations","insertMany","bulkWriteOperation","err","result","mapInsertManyResults","r","finalResult","ok","n","insertedCount","ops","insertedIds","getLastOp","opTime","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,aAAa,GAAGC,OAAO,CAAC,aAAD,CAAP,CAAuBD,aAA7C;;AACA,MAAME,kBAAkB,GAAGD,OAAO,CAAC,cAAD,CAAlC;;AACA,MAAME,UAAU,GAAGF,OAAO,CAAC,SAAD,CAAP,CAAmBE,UAAtC;;AACA,MAAMC,WAAW,GAAGH,OAAO,CAAC,oBAAD,CAAP,CAA8BG,WAAlD;;AAEA,MAAMC,mBAAN,SAAkCL,aAAlC,CAAgD;AAC9CM,EAAAA,WAAW,CAACC,UAAD,EAAaC,IAAb,EAAmBC,OAAnB,EAA4B;AACrC,UAAMA,OAAN;AAEA,SAAKF,UAAL,GAAkBA,UAAlB;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACD;;AAEDE,EAAAA,OAAO,CAACC,QAAD,EAAW;AAChB,UAAMC,IAAI,GAAG,KAAKL,UAAlB;AACA,QAAIC,IAAI,GAAG,KAAKA,IAAhB;AACA,UAAMC,OAAO,GAAG,KAAKA,OAArB;;AAEA,QAAI,CAACI,KAAK,CAACC,OAAN,CAAcN,IAAd,CAAL,EAA0B;AACxB,aAAOG,QAAQ,CACbR,UAAU,CAACY,MAAX,CAAkB;AAAEC,QAAAA,OAAO,EAAE,8CAAX;AAA2DC,QAAAA,MAAM,EAAE;AAAnE,OAAlB,CADa,CAAf;AAGD,KATe,CAWhB;;;AACAR,IAAAA,OAAO,CAAC,oBAAD,CAAP,GAAgCA,OAAO,CAAC,oBAAD,CAAP,IAAiCG,IAAI,CAACM,CAAL,CAAOC,kBAAxE;AAEAX,IAAAA,IAAI,GAAGJ,WAAW,CAACQ,IAAD,EAAOJ,IAAP,EAAaC,OAAb,CAAlB,CAdgB,CAgBhB;;AACA,UAAMW,UAAU,GAAG,CACjB;AACEC,MAAAA,UAAU,EAAEb;AADd,KADiB,CAAnB;AAMA,UAAMc,kBAAkB,GAAG,IAAIpB,kBAAJ,CAAuBU,IAAvB,EAA6BQ,UAA7B,EAAyCX,OAAzC,CAA3B;AAEAa,IAAAA,kBAAkB,CAACZ,OAAnB,CAA2B,CAACa,GAAD,EAAMC,MAAN,KAAiB;AAC1C,UAAID,GAAJ,EAAS,OAAOZ,QAAQ,CAACY,GAAD,EAAM,IAAN,CAAf;AACTZ,MAAAA,QAAQ,CAAC,IAAD,EAAOc,oBAAoB,CAACjB,IAAD,EAAOgB,MAAP,CAA3B,CAAR;AACD,KAHD;AAID;;AArC6C;;AAwChD,SAASC,oBAAT,CAA8BjB,IAA9B,EAAoCkB,CAApC,EAAuC;AACrC,QAAMC,WAAW,GAAG;AAClBH,IAAAA,MAAM,EAAE;AAAEI,MAAAA,EAAE,EAAE,CAAN;AAASC,MAAAA,CAAC,EAAEH,CAAC,CAACI;AAAd,KADU;AAElBC,IAAAA,GAAG,EAAEvB,IAFa;AAGlBsB,IAAAA,aAAa,EAAEJ,CAAC,CAACI,aAHC;AAIlBE,IAAAA,WAAW,EAAEN,CAAC,CAACM;AAJG,GAApB;;AAOA,MAAIN,CAAC,CAACO,SAAF,EAAJ,EAAmB;AACjBN,IAAAA,WAAW,CAACH,MAAZ,CAAmBU,MAAnB,GAA4BR,CAAC,CAACO,SAAF,EAA5B;AACD;;AAED,SAAON,WAAP;AACD;;AAEDQ,MAAM,CAACC,OAAP,GAAiB/B,mBAAjB","sourcesContent":["'use strict';\n\nconst OperationBase = require('./operation').OperationBase;\nconst BulkWriteOperation = require('./bulk_write');\nconst MongoError = require('../core').MongoError;\nconst prepareDocs = require('./common_functions').prepareDocs;\n\nclass InsertManyOperation extends OperationBase {\n  constructor(collection, docs, options) {\n    super(options);\n\n    this.collection = collection;\n    this.docs = docs;\n  }\n\n  execute(callback) {\n    const coll = this.collection;\n    let docs = this.docs;\n    const options = this.options;\n\n    if (!Array.isArray(docs)) {\n      return callback(\n        MongoError.create({ message: 'docs parameter must be an array of documents', driver: true })\n      );\n    }\n\n    // If keep going set unordered\n    options['serializeFunctions'] = options['serializeFunctions'] || coll.s.serializeFunctions;\n\n    docs = prepareDocs(coll, docs, options);\n\n    // Generate the bulk write operations\n    const operations = [\n      {\n        insertMany: docs\n      }\n    ];\n\n    const bulkWriteOperation = new BulkWriteOperation(coll, operations, options);\n\n    bulkWriteOperation.execute((err, result) => {\n      if (err) return callback(err, null);\n      callback(null, mapInsertManyResults(docs, result));\n    });\n  }\n}\n\nfunction mapInsertManyResults(docs, r) {\n  const finalResult = {\n    result: { ok: 1, n: r.insertedCount },\n    ops: docs,\n    insertedCount: r.insertedCount,\n    insertedIds: r.insertedIds\n  };\n\n  if (r.getLastOp()) {\n    finalResult.result.opTime = r.getLastOp();\n  }\n\n  return finalResult;\n}\n\nmodule.exports = InsertManyOperation;\n"]},"metadata":{},"sourceType":"script"}