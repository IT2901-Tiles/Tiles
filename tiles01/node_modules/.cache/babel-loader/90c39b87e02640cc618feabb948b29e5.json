{"ast":null,"code":"'use strict';\n\nconst MongoError = require('./core/error').MongoError;\n\nconst WriteConcern = require('./write_concern');\n\nvar shallowClone = function (obj) {\n  var copy = {};\n\n  for (var name in obj) copy[name] = obj[name];\n\n  return copy;\n}; // Set simple property\n\n\nvar getSingleProperty = function (obj, name, value) {\n  Object.defineProperty(obj, name, {\n    enumerable: true,\n    get: function () {\n      return value;\n    }\n  });\n};\n\nvar formatSortValue = exports.formatSortValue = function (sortDirection) {\n  var value = ('' + sortDirection).toLowerCase();\n\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n\n    default:\n      throw new Error('Illegal sort clause, must be of the form ' + \"[['field1', '(ascending|descending)'], \" + \"['field2', '(ascending|descending)']]\");\n  }\n};\n\nvar formattedOrderClause = exports.formattedOrderClause = function (sortValue) {\n  var orderBy = {};\n  if (sortValue == null) return null;\n\n  if (Array.isArray(sortValue)) {\n    if (sortValue.length === 0) {\n      return null;\n    }\n\n    for (var i = 0; i < sortValue.length; i++) {\n      if (sortValue[i].constructor === String) {\n        orderBy[sortValue[i]] = 1;\n      } else {\n        orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);\n      }\n    }\n  } else if (sortValue != null && typeof sortValue === 'object') {\n    orderBy = sortValue;\n  } else if (typeof sortValue === 'string') {\n    orderBy[sortValue] = 1;\n  } else {\n    throw new Error('Illegal sort clause, must be of the form ' + \"[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]\");\n  }\n\n  return orderBy;\n};\n\nvar checkCollectionName = function checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new MongoError('collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new MongoError('collection names cannot be empty');\n  }\n\n  if (collectionName.indexOf('$') !== -1 && collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    throw new MongoError(\"collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    throw new MongoError(\"collection names must not start or end with '.'\");\n  } // Validate that we are not passing 0x00 in the collection name\n\n\n  if (collectionName.indexOf('\\x00') !== -1) {\n    throw new MongoError('collection names cannot contain a null character');\n  }\n};\n\nvar handleCallback = function (callback, err, value1, value2) {\n  try {\n    if (callback == null) return;\n\n    if (callback) {\n      return value2 ? callback(err, value1, value2) : callback(err, value1);\n    }\n  } catch (err) {\n    process.nextTick(function () {\n      throw err;\n    });\n    return false;\n  }\n\n  return true;\n};\n/**\n * Wrap a Mongo error document in an Error instance\n * @ignore\n * @api private\n */\n\n\nvar toError = function (error) {\n  if (error instanceof Error) return error;\n  var msg = error.err || error.errmsg || error.errMessage || error;\n  var e = MongoError.create({\n    message: msg,\n    driver: true\n  }); // Get all object keys\n\n  var keys = typeof error === 'object' ? Object.keys(error) : [];\n\n  for (var i = 0; i < keys.length; i++) {\n    try {\n      e[keys[i]] = error[keys[i]];\n    } catch (err) {// continue\n    }\n  }\n\n  return e;\n};\n/**\n * @ignore\n */\n\n\nvar normalizeHintField = function normalizeHintField(hint) {\n  var finalHint = null;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n    hint.forEach(function (param) {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n\n    for (var name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n};\n/**\n * Create index name based on field spec\n *\n * @ignore\n * @api private\n */\n\n\nvar parseIndexOptions = function (fieldOrSpec) {\n  var fieldHash = {};\n  var indexes = [];\n  var keys; // Get all the fields accordingly\n\n  if ('string' === typeof fieldOrSpec) {\n    // 'type'\n    indexes.push(fieldOrSpec + '_' + 1);\n    fieldHash[fieldOrSpec] = 1;\n  } else if (Array.isArray(fieldOrSpec)) {\n    fieldOrSpec.forEach(function (f) {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(function (k) {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {// undefined (ignore)\n      }\n    });\n  } else if (isObject(fieldOrSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(fieldOrSpec);\n    keys.forEach(function (key) {\n      indexes.push(key + '_' + fieldOrSpec[key]);\n      fieldHash[key] = fieldOrSpec[key];\n    });\n  }\n\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n};\n\nvar isObject = exports.isObject = function (arg) {\n  return '[object Object]' === Object.prototype.toString.call(arg);\n};\n\nvar debugOptions = function (debugFields, options) {\n  var finaloptions = {};\n  debugFields.forEach(function (n) {\n    finaloptions[n] = options[n];\n  });\n  return finaloptions;\n};\n\nvar decorateCommand = function (command, options, exclude) {\n  for (var name in options) {\n    if (exclude.indexOf(name) === -1) command[name] = options[name];\n  }\n\n  return command;\n};\n\nvar mergeOptions = function (target, source) {\n  for (var name in source) {\n    target[name] = source[name];\n  }\n\n  return target;\n}; // Merge options with translation\n\n\nvar translateOptions = function (target, source) {\n  var translations = {\n    // SSL translation options\n    sslCA: 'ca',\n    sslCRL: 'crl',\n    sslValidate: 'rejectUnauthorized',\n    sslKey: 'key',\n    sslCert: 'cert',\n    sslPass: 'passphrase',\n    // SocketTimeout translation options\n    socketTimeoutMS: 'socketTimeout',\n    connectTimeoutMS: 'connectionTimeout',\n    // Replicaset options\n    replicaSet: 'setName',\n    rs_name: 'setName',\n    secondaryAcceptableLatencyMS: 'acceptableLatency',\n    connectWithNoPrimary: 'secondaryOnlyConnectionAllowed',\n    // Mongos options\n    acceptableLatencyMS: 'localThresholdMS'\n  };\n\n  for (var name in source) {\n    if (translations[name]) {\n      target[translations[name]] = source[name];\n    } else {\n      target[name] = source[name];\n    }\n  }\n\n  return target;\n};\n\nvar filterOptions = function (options, names) {\n  var filterOptions = {};\n\n  for (var name in options) {\n    if (names.indexOf(name) !== -1) filterOptions[name] = options[name];\n  } // Filtered options\n\n\n  return filterOptions;\n}; // Write concern keys\n\n\nvar writeConcernKeys = ['w', 'j', 'wtimeout', 'fsync']; // Merge the write concern options\n\nvar mergeOptionsAndWriteConcern = function (targetOptions, sourceOptions, keys, mergeWriteConcern) {\n  // Mix in any allowed options\n  for (var i = 0; i < keys.length; i++) {\n    if (!targetOptions[keys[i]] && sourceOptions[keys[i]] !== undefined) {\n      targetOptions[keys[i]] = sourceOptions[keys[i]];\n    }\n  } // No merging of write concern\n\n\n  if (!mergeWriteConcern) return targetOptions; // Found no write Concern options\n\n  var found = false;\n\n  for (i = 0; i < writeConcernKeys.length; i++) {\n    if (targetOptions[writeConcernKeys[i]]) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    for (i = 0; i < writeConcernKeys.length; i++) {\n      if (sourceOptions[writeConcernKeys[i]]) {\n        targetOptions[writeConcernKeys[i]] = sourceOptions[writeConcernKeys[i]];\n      }\n    }\n  }\n\n  return targetOptions;\n};\n/**\n * Executes the given operation with provided arguments.\n *\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param {object} topology The topology to execute this operation on\n * @param {function} operation The operation to execute\n * @param {array} args Arguments to apply the provided operation\n * @param {object} [options] Options that modify the behavior of the method\n */\n\n\nconst executeLegacyOperation = (topology, operation, args, options) => {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n\n  if (!Array.isArray(args)) {\n    throw new TypeError('This method requires an array of arguments to apply');\n  }\n\n  options = options || {};\n  const Promise = topology.s.promiseLibrary;\n  let callback = args[args.length - 1]; // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n\n  let session, opOptions, owner;\n\n  if (!options.skipSessions && topology.hasSessionSupport()) {\n    opOptions = args[args.length - 2];\n\n    if (opOptions == null || opOptions.session == null) {\n      owner = Symbol();\n      session = topology.startSession({\n        owner\n      });\n      const optionsIndex = args.length - 2;\n      args[optionsIndex] = Object.assign({}, args[optionsIndex], {\n        session: session\n      });\n    } else if (opOptions.session && opOptions.session.hasEnded) {\n      throw new MongoError('Use of expired sessions is not permitted');\n    }\n  }\n\n  const makeExecuteCallback = (resolve, reject) => function executeCallback(err, result) {\n    if (session && session.owner === owner && !options.returnsCursor) {\n      session.endSession(() => {\n        delete opOptions.session;\n        if (err) return reject(err);\n        resolve(result);\n      });\n    } else {\n      if (err) return reject(err);\n      resolve(result);\n    }\n  }; // Execute using callback\n\n\n  if (typeof callback === 'function') {\n    callback = args.pop();\n    const handler = makeExecuteCallback(result => callback(null, result), err => callback(err, null));\n    args.push(handler);\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n      throw e;\n    }\n  } // Return a Promise\n\n\n  if (args[args.length - 1] != null) {\n    throw new TypeError('final argument to `executeLegacyOperation` must be a callback');\n  }\n\n  return new Promise(function (resolve, reject) {\n    const handler = makeExecuteCallback(resolve, reject);\n    args[args.length - 1] = handler;\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n    }\n  });\n};\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n *\n * @param {object} target The target command to which we will apply retryWrites.\n * @param {object} db The database from which we can inherit a retryWrites value.\n */\n\n\nfunction applyRetryableWrites(target, db) {\n  if (db && db.s.options.retryWrites) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n *\n * @param {Object} target the target command we will be applying the write concern to\n * @param {Object} sources sources where we can inherit default write concerns from\n * @param {Object} [options] optional settings passed into a command for write concern overrides\n * @returns {Object} the (now) decorated target\n */\n\n\nfunction applyWriteConcern(target, sources, options) {\n  options = options || {};\n  const db = sources.db;\n  const coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  const writeConcern = WriteConcern.fromOptions(options);\n\n  if (writeConcern) {\n    return Object.assign(target, {\n      writeConcern\n    });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, coll.writeConcern)\n    });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, db.writeConcern)\n    });\n  }\n\n  return target;\n}\n/**\n * Checks if a given value is a Promise\n *\n * @param {*} maybePromise\n * @return true if the provided value is a Promise\n */\n\n\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n/**\n * Applies collation to a given command.\n *\n * @param {object} [command] the command on which to apply collation\n * @param {(Cursor|Collection)} [target] target of command\n * @param {object} [options] options containing collation settings\n */\n\n\nfunction decorateWithCollation(command, target, options) {\n  const topology = target.s && target.s.topology || target.topology;\n\n  if (!topology) {\n    throw new TypeError('parameter \"target\" is missing a topology');\n  }\n\n  const capabilities = topology.capabilities();\n\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new MongoError(`Current topology does not support collation`);\n    }\n  }\n}\n/**\n * Applies a read concern to a given command.\n *\n * @param {object} command the command on which to apply the read concern\n * @param {Collection} coll the parent collection of the operation calling this method\n */\n\n\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n\n  let readConcern = Object.assign({}, command.readConcern || {});\n\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, {\n      readConcern: readConcern\n    });\n  }\n}\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param {object} command - the command on which to apply the explain\n * @param {Explain} explain - the options containing the explain verbosity\n * @return the new command\n */\n\n\nfunction decorateWithExplain(command, explain) {\n  if (command.explain) {\n    return command;\n  }\n\n  return {\n    explain: command,\n    verbosity: explain.verbosity\n  };\n}\n\nconst emitProcessWarning = msg => process.emitWarning(msg, 'DeprecationWarning');\n\nconst emitConsoleWarning = msg => console.error(msg);\n\nconst emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;\n/**\n * Default message handler for generating deprecation warnings.\n *\n * @param {string} name function name\n * @param {string} option option name\n * @return {string} warning message\n * @ignore\n * @api private\n */\n\nfunction defaultMsgHandler(name, option) {\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\n/**\n * Deprecates a given function's options.\n *\n * @param {object} config configuration for deprecation\n * @param {string} config.name function name\n * @param {Array} config.deprecatedOptions options to deprecate\n * @param {number} config.optionsIndex index of options object in function arguments array\n * @param {function} [config.msgHandler] optional custom message handler to generate warnings\n * @param {function} fn the target function of deprecation\n * @return {function} modified function that warns once per deprecated option, and executes original function\n * @ignore\n * @api private\n */\n\n\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n  const optionsWarned = new Set();\n\n  function deprecated() {\n    const options = arguments[config.optionsIndex]; // ensure options is a valid, non-empty object, otherwise short-circuit\n\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.apply(this, arguments);\n    }\n\n    config.deprecatedOptions.forEach(deprecatedOption => {\n      if (Object.prototype.hasOwnProperty.call(options, deprecatedOption) && !optionsWarned.has(deprecatedOption)) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitDeprecationWarning(msg);\n\n        if (this && this.getLogger) {\n          const logger = this.getLogger();\n\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    });\n    return fn.apply(this, arguments);\n  } // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n\n\n  Object.setPrototypeOf(deprecated, fn);\n\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nconst SUPPORTS = {}; // Test asyncIterator support\n\ntry {\n  require('./async/async_iterator');\n\n  SUPPORTS.ASYNC_ITERATOR = true;\n} catch (e) {\n  SUPPORTS.ASYNC_ITERATOR = false;\n}\n\nclass MongoDBNamespace {\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection;\n  }\n\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace) {\n    if (!namespace) {\n      throw new Error(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const index = namespace.indexOf('.');\n    return new MongoDBNamespace(namespace.substring(0, index), namespace.substring(index + 1));\n  }\n\n}\n\nfunction* makeCounter(seed) {\n  let count = seed || 0;\n\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n/**\n * Helper function for either accepting a callback, or returning a promise\n *\n * @param {Object} parent an instance of parent with promiseLibrary.\n * @param {object} parent.s an object containing promiseLibrary.\n * @param {function} parent.s.promiseLibrary an object containing promiseLibrary.\n * @param {[Function]} callback an optional callback.\n * @param {Function} fn A function that takes a callback\n * @returns {Promise|void} Returns nothing if a callback is supplied, else returns a Promise.\n */\n\n\nfunction maybePromise(parent, callback, fn) {\n  const PromiseLibrary = parent && parent.s && parent.s.promiseLibrary || Promise;\n  let result;\n\n  if (typeof callback !== 'function') {\n    result = new PromiseLibrary((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  fn(function (err, res) {\n    if (err != null) {\n      try {\n        callback(err);\n      } catch (error) {\n        return process.nextTick(() => {\n          throw error;\n        });\n      }\n\n      return;\n    }\n\n    callback(err, res);\n  });\n  return result;\n}\n\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw TypeError('numeric value required to calculate duration');\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n *\n * @param {function} fn An async function to run on an interval, must accept a `callback` as its only parameter\n * @param {object} [options] Optional settings\n * @param {number} [options.interval] The interval at which to run the provided function\n * @param {number} [options.minInterval] The minimum time which must pass between invocations of the provided function\n * @param {boolean} [options.immediate] Execute the function immediately when the interval is started\n */\n\n\nfunction makeInterruptableAsyncInterval(fn, options) {\n  let timerId;\n  let lastCallTime;\n  let lastWakeTime;\n  let stopped = false;\n  options = options || {};\n  const interval = options.interval || 1000;\n  const minInterval = options.minInterval || 500;\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n  const clock = typeof options.clock === 'function' ? options.clock : now;\n\n  function wake() {\n    const currentTime = clock();\n    const timeSinceLastWake = currentTime - lastWakeTime;\n    const timeSinceLastCall = currentTime - lastCallTime;\n    const timeUntilNextCall = interval - timeSinceLastCall;\n    lastWakeTime = currentTime; // For the streaming protocol: there is nothing obviously stopping this\n    // interval from being woken up again while we are waiting \"infinitely\"\n    // for `fn` to be called again`. Since the function effectively\n    // never completes, the `timeUntilNextCall` will continue to grow\n    // negatively unbounded, so it will never trigger a reschedule here.\n    // debounce multiple calls to wake within the `minInterval`\n\n    if (timeSinceLastWake < minInterval) {\n      return;\n    } // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n\n\n    if (timeUntilNextCall > minInterval) {\n      reschedule(minInterval);\n    } // This is possible in virtualized environments like AWS Lambda where our\n    // clock is unreliable. In these cases the timer is \"running\" but never\n    // actually completes, so we want to execute immediately and then attempt\n    // to reschedule.\n\n\n    if (timeUntilNextCall < 0) {\n      executeAndReschedule();\n    }\n  }\n\n  function stop() {\n    stopped = true;\n\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = null;\n    }\n\n    lastCallTime = 0;\n    lastWakeTime = 0;\n  }\n\n  function reschedule(ms) {\n    if (stopped) return;\n    clearTimeout(timerId);\n    timerId = setTimeout(executeAndReschedule, ms || interval);\n  }\n\n  function executeAndReschedule() {\n    lastWakeTime = 0;\n    lastCallTime = clock();\n    fn(err => {\n      if (err) throw err;\n      reschedule(interval);\n    });\n  }\n\n  if (immediate) {\n    executeAndReschedule();\n  } else {\n    lastCallTime = clock();\n    reschedule();\n  }\n\n  return {\n    wake,\n    stop\n  };\n}\n\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    return doc.reduce((err, u) => err || hasAtomicOperators(u), null);\n  }\n\n  return Object.keys(typeof doc.toBSON !== 'function' ? doc : doc.toBSON()).map(k => k[0]).indexOf('$') >= 0;\n}\n\nmodule.exports = {\n  filterOptions,\n  mergeOptions,\n  translateOptions,\n  shallowClone,\n  getSingleProperty,\n  checkCollectionName,\n  toError,\n  formattedOrderClause,\n  parseIndexOptions,\n  normalizeHintField,\n  handleCallback,\n  decorateCommand,\n  isObject,\n  debugOptions,\n  MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,\n  mergeOptionsAndWriteConcern,\n  executeLegacyOperation,\n  applyRetryableWrites,\n  applyWriteConcern,\n  isPromiseLike,\n  decorateWithCollation,\n  decorateWithReadConcern,\n  decorateWithExplain,\n  deprecateOptions,\n  SUPPORTS,\n  MongoDBNamespace,\n  emitDeprecationWarning,\n  makeCounter,\n  maybePromise,\n  now,\n  calculateDurationInMs,\n  makeInterruptableAsyncInterval,\n  hasAtomicOperators\n};","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/utils.js"],"names":["MongoError","require","WriteConcern","shallowClone","obj","copy","name","getSingleProperty","value","Object","defineProperty","enumerable","get","formatSortValue","exports","sortDirection","toLowerCase","Error","formattedOrderClause","sortValue","orderBy","Array","isArray","length","i","constructor","String","checkCollectionName","collectionName","indexOf","match","handleCallback","callback","err","value1","value2","process","nextTick","toError","error","msg","errmsg","errMessage","e","create","message","driver","keys","normalizeHintField","hint","finalHint","forEach","param","parseIndexOptions","fieldOrSpec","fieldHash","indexes","push","f","isObject","k","key","join","arg","prototype","toString","call","debugOptions","debugFields","options","finaloptions","n","decorateCommand","command","exclude","mergeOptions","target","source","translateOptions","translations","sslCA","sslCRL","sslValidate","sslKey","sslCert","sslPass","socketTimeoutMS","connectTimeoutMS","replicaSet","rs_name","secondaryAcceptableLatencyMS","connectWithNoPrimary","acceptableLatencyMS","filterOptions","names","writeConcernKeys","mergeOptionsAndWriteConcern","targetOptions","sourceOptions","mergeWriteConcern","undefined","found","executeLegacyOperation","topology","operation","args","TypeError","Promise","s","promiseLibrary","session","opOptions","owner","skipSessions","hasSessionSupport","Symbol","startSession","optionsIndex","assign","hasEnded","makeExecuteCallback","resolve","reject","executeCallback","result","returnsCursor","endSession","pop","handler","apply","applyRetryableWrites","db","retryWrites","applyWriteConcern","sources","coll","collection","inTransaction","writeConcern","fromOptions","isPromiseLike","maybePromise","then","decorateWithCollation","capabilities","collation","commandsTakeCollation","decorateWithReadConcern","readConcern","decorateWithExplain","explain","verbosity","emitProcessWarning","emitWarning","emitConsoleWarning","console","emitDeprecationWarning","defaultMsgHandler","option","deprecateOptions","config","fn","noDeprecation","msgHandler","optionsWarned","Set","deprecated","arguments","deprecatedOptions","deprecatedOption","hasOwnProperty","has","add","getLogger","logger","warn","setPrototypeOf","SUPPORTS","ASYNC_ITERATOR","MongoDBNamespace","withCollection","fromString","namespace","index","substring","makeCounter","seed","count","newCount","parent","PromiseLibrary","res","now","hrtime","Math","floor","calculateDurationInMs","started","elapsed","makeInterruptableAsyncInterval","timerId","lastCallTime","lastWakeTime","stopped","interval","minInterval","immediate","clock","wake","currentTime","timeSinceLastWake","timeSinceLastCall","timeUntilNextCall","reschedule","executeAndReschedule","stop","clearTimeout","ms","setTimeout","hasAtomicOperators","doc","reduce","u","toBSON","map","module","MAX_JS_INT","Number","MAX_SAFE_INTEGER"],"mappings":"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","sourcesContent":["'use strict';\nconst MongoError = require('./core/error').MongoError;\nconst WriteConcern = require('./write_concern');\n\nvar shallowClone = function(obj) {\n  var copy = {};\n  for (var name in obj) copy[name] = obj[name];\n  return copy;\n};\n\n// Set simple property\nvar getSingleProperty = function(obj, name, value) {\n  Object.defineProperty(obj, name, {\n    enumerable: true,\n    get: function() {\n      return value;\n    }\n  });\n};\n\nvar formatSortValue = (exports.formatSortValue = function(sortDirection) {\n  var value = ('' + sortDirection).toLowerCase();\n\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n    default:\n      throw new Error(\n        'Illegal sort clause, must be of the form ' +\n          \"[['field1', '(ascending|descending)'], \" +\n          \"['field2', '(ascending|descending)']]\"\n      );\n  }\n});\n\nvar formattedOrderClause = (exports.formattedOrderClause = function(sortValue) {\n  var orderBy = {};\n  if (sortValue == null) return null;\n  if (Array.isArray(sortValue)) {\n    if (sortValue.length === 0) {\n      return null;\n    }\n\n    for (var i = 0; i < sortValue.length; i++) {\n      if (sortValue[i].constructor === String) {\n        orderBy[sortValue[i]] = 1;\n      } else {\n        orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);\n      }\n    }\n  } else if (sortValue != null && typeof sortValue === 'object') {\n    orderBy = sortValue;\n  } else if (typeof sortValue === 'string') {\n    orderBy[sortValue] = 1;\n  } else {\n    throw new Error(\n      'Illegal sort clause, must be of the form ' +\n        \"[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]\"\n    );\n  }\n\n  return orderBy;\n});\n\nvar checkCollectionName = function checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new MongoError('collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new MongoError('collection names cannot be empty');\n  }\n\n  if (\n    collectionName.indexOf('$') !== -1 &&\n    collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null\n  ) {\n    throw new MongoError(\"collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    throw new MongoError(\"collection names must not start or end with '.'\");\n  }\n\n  // Validate that we are not passing 0x00 in the collection name\n  if (collectionName.indexOf('\\x00') !== -1) {\n    throw new MongoError('collection names cannot contain a null character');\n  }\n};\n\nvar handleCallback = function(callback, err, value1, value2) {\n  try {\n    if (callback == null) return;\n\n    if (callback) {\n      return value2 ? callback(err, value1, value2) : callback(err, value1);\n    }\n  } catch (err) {\n    process.nextTick(function() {\n      throw err;\n    });\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Wrap a Mongo error document in an Error instance\n * @ignore\n * @api private\n */\nvar toError = function(error) {\n  if (error instanceof Error) return error;\n\n  var msg = error.err || error.errmsg || error.errMessage || error;\n  var e = MongoError.create({ message: msg, driver: true });\n\n  // Get all object keys\n  var keys = typeof error === 'object' ? Object.keys(error) : [];\n\n  for (var i = 0; i < keys.length; i++) {\n    try {\n      e[keys[i]] = error[keys[i]];\n    } catch (err) {\n      // continue\n    }\n  }\n\n  return e;\n};\n\n/**\n * @ignore\n */\nvar normalizeHintField = function normalizeHintField(hint) {\n  var finalHint = null;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n\n    hint.forEach(function(param) {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n    for (var name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n};\n\n/**\n * Create index name based on field spec\n *\n * @ignore\n * @api private\n */\nvar parseIndexOptions = function(fieldOrSpec) {\n  var fieldHash = {};\n  var indexes = [];\n  var keys;\n\n  // Get all the fields accordingly\n  if ('string' === typeof fieldOrSpec) {\n    // 'type'\n    indexes.push(fieldOrSpec + '_' + 1);\n    fieldHash[fieldOrSpec] = 1;\n  } else if (Array.isArray(fieldOrSpec)) {\n    fieldOrSpec.forEach(function(f) {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(function(k) {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {\n        // undefined (ignore)\n      }\n    });\n  } else if (isObject(fieldOrSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(fieldOrSpec);\n    keys.forEach(function(key) {\n      indexes.push(key + '_' + fieldOrSpec[key]);\n      fieldHash[key] = fieldOrSpec[key];\n    });\n  }\n\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n};\n\nvar isObject = (exports.isObject = function(arg) {\n  return '[object Object]' === Object.prototype.toString.call(arg);\n});\n\nvar debugOptions = function(debugFields, options) {\n  var finaloptions = {};\n  debugFields.forEach(function(n) {\n    finaloptions[n] = options[n];\n  });\n\n  return finaloptions;\n};\n\nvar decorateCommand = function(command, options, exclude) {\n  for (var name in options) {\n    if (exclude.indexOf(name) === -1) command[name] = options[name];\n  }\n\n  return command;\n};\n\nvar mergeOptions = function(target, source) {\n  for (var name in source) {\n    target[name] = source[name];\n  }\n\n  return target;\n};\n\n// Merge options with translation\nvar translateOptions = function(target, source) {\n  var translations = {\n    // SSL translation options\n    sslCA: 'ca',\n    sslCRL: 'crl',\n    sslValidate: 'rejectUnauthorized',\n    sslKey: 'key',\n    sslCert: 'cert',\n    sslPass: 'passphrase',\n    // SocketTimeout translation options\n    socketTimeoutMS: 'socketTimeout',\n    connectTimeoutMS: 'connectionTimeout',\n    // Replicaset options\n    replicaSet: 'setName',\n    rs_name: 'setName',\n    secondaryAcceptableLatencyMS: 'acceptableLatency',\n    connectWithNoPrimary: 'secondaryOnlyConnectionAllowed',\n    // Mongos options\n    acceptableLatencyMS: 'localThresholdMS'\n  };\n\n  for (var name in source) {\n    if (translations[name]) {\n      target[translations[name]] = source[name];\n    } else {\n      target[name] = source[name];\n    }\n  }\n\n  return target;\n};\n\nvar filterOptions = function(options, names) {\n  var filterOptions = {};\n\n  for (var name in options) {\n    if (names.indexOf(name) !== -1) filterOptions[name] = options[name];\n  }\n\n  // Filtered options\n  return filterOptions;\n};\n\n// Write concern keys\nvar writeConcernKeys = ['w', 'j', 'wtimeout', 'fsync'];\n\n// Merge the write concern options\nvar mergeOptionsAndWriteConcern = function(targetOptions, sourceOptions, keys, mergeWriteConcern) {\n  // Mix in any allowed options\n  for (var i = 0; i < keys.length; i++) {\n    if (!targetOptions[keys[i]] && sourceOptions[keys[i]] !== undefined) {\n      targetOptions[keys[i]] = sourceOptions[keys[i]];\n    }\n  }\n\n  // No merging of write concern\n  if (!mergeWriteConcern) return targetOptions;\n\n  // Found no write Concern options\n  var found = false;\n  for (i = 0; i < writeConcernKeys.length; i++) {\n    if (targetOptions[writeConcernKeys[i]]) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    for (i = 0; i < writeConcernKeys.length; i++) {\n      if (sourceOptions[writeConcernKeys[i]]) {\n        targetOptions[writeConcernKeys[i]] = sourceOptions[writeConcernKeys[i]];\n      }\n    }\n  }\n\n  return targetOptions;\n};\n\n/**\n * Executes the given operation with provided arguments.\n *\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param {object} topology The topology to execute this operation on\n * @param {function} operation The operation to execute\n * @param {array} args Arguments to apply the provided operation\n * @param {object} [options] Options that modify the behavior of the method\n */\nconst executeLegacyOperation = (topology, operation, args, options) => {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n\n  if (!Array.isArray(args)) {\n    throw new TypeError('This method requires an array of arguments to apply');\n  }\n\n  options = options || {};\n  const Promise = topology.s.promiseLibrary;\n  let callback = args[args.length - 1];\n\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session, opOptions, owner;\n  if (!options.skipSessions && topology.hasSessionSupport()) {\n    opOptions = args[args.length - 2];\n    if (opOptions == null || opOptions.session == null) {\n      owner = Symbol();\n      session = topology.startSession({ owner });\n      const optionsIndex = args.length - 2;\n      args[optionsIndex] = Object.assign({}, args[optionsIndex], { session: session });\n    } else if (opOptions.session && opOptions.session.hasEnded) {\n      throw new MongoError('Use of expired sessions is not permitted');\n    }\n  }\n\n  const makeExecuteCallback = (resolve, reject) =>\n    function executeCallback(err, result) {\n      if (session && session.owner === owner && !options.returnsCursor) {\n        session.endSession(() => {\n          delete opOptions.session;\n          if (err) return reject(err);\n          resolve(result);\n        });\n      } else {\n        if (err) return reject(err);\n        resolve(result);\n      }\n    };\n\n  // Execute using callback\n  if (typeof callback === 'function') {\n    callback = args.pop();\n    const handler = makeExecuteCallback(\n      result => callback(null, result),\n      err => callback(err, null)\n    );\n    args.push(handler);\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n      throw e;\n    }\n  }\n\n  // Return a Promise\n  if (args[args.length - 1] != null) {\n    throw new TypeError('final argument to `executeLegacyOperation` must be a callback');\n  }\n\n  return new Promise(function(resolve, reject) {\n    const handler = makeExecuteCallback(resolve, reject);\n    args[args.length - 1] = handler;\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n    }\n  });\n};\n\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n *\n * @param {object} target The target command to which we will apply retryWrites.\n * @param {object} db The database from which we can inherit a retryWrites value.\n */\nfunction applyRetryableWrites(target, db) {\n  if (db && db.s.options.retryWrites) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n *\n * @param {Object} target the target command we will be applying the write concern to\n * @param {Object} sources sources where we can inherit default write concerns from\n * @param {Object} [options] optional settings passed into a command for write concern overrides\n * @returns {Object} the (now) decorated target\n */\nfunction applyWriteConcern(target, sources, options) {\n  options = options || {};\n  const db = sources.db;\n  const coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  const writeConcern = WriteConcern.fromOptions(options);\n  if (writeConcern) {\n    return Object.assign(target, { writeConcern });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });\n  }\n\n  return target;\n}\n\n/**\n * Checks if a given value is a Promise\n *\n * @param {*} maybePromise\n * @return true if the provided value is a Promise\n */\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n\n/**\n * Applies collation to a given command.\n *\n * @param {object} [command] the command on which to apply collation\n * @param {(Cursor|Collection)} [target] target of command\n * @param {object} [options] options containing collation settings\n */\nfunction decorateWithCollation(command, target, options) {\n  const topology = (target.s && target.s.topology) || target.topology;\n\n  if (!topology) {\n    throw new TypeError('parameter \"target\" is missing a topology');\n  }\n\n  const capabilities = topology.capabilities();\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new MongoError(`Current topology does not support collation`);\n    }\n  }\n}\n\n/**\n * Applies a read concern to a given command.\n *\n * @param {object} command the command on which to apply the read concern\n * @param {Collection} coll the parent collection of the operation calling this method\n */\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n  let readConcern = Object.assign({}, command.readConcern || {});\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, { readConcern: readConcern });\n  }\n}\n\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param {object} command - the command on which to apply the explain\n * @param {Explain} explain - the options containing the explain verbosity\n * @return the new command\n */\nfunction decorateWithExplain(command, explain) {\n  if (command.explain) {\n    return command;\n  }\n\n  return { explain: command, verbosity: explain.verbosity };\n}\n\nconst emitProcessWarning = msg => process.emitWarning(msg, 'DeprecationWarning');\nconst emitConsoleWarning = msg => console.error(msg);\nconst emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;\n\n/**\n * Default message handler for generating deprecation warnings.\n *\n * @param {string} name function name\n * @param {string} option option name\n * @return {string} warning message\n * @ignore\n * @api private\n */\nfunction defaultMsgHandler(name, option) {\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\n\n/**\n * Deprecates a given function's options.\n *\n * @param {object} config configuration for deprecation\n * @param {string} config.name function name\n * @param {Array} config.deprecatedOptions options to deprecate\n * @param {number} config.optionsIndex index of options object in function arguments array\n * @param {function} [config.msgHandler] optional custom message handler to generate warnings\n * @param {function} fn the target function of deprecation\n * @return {function} modified function that warns once per deprecated option, and executes original function\n * @ignore\n * @api private\n */\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n\n  const optionsWarned = new Set();\n  function deprecated() {\n    const options = arguments[config.optionsIndex];\n\n    // ensure options is a valid, non-empty object, otherwise short-circuit\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.apply(this, arguments);\n    }\n\n    config.deprecatedOptions.forEach(deprecatedOption => {\n      if (\n        Object.prototype.hasOwnProperty.call(options, deprecatedOption) &&\n        !optionsWarned.has(deprecatedOption)\n      ) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitDeprecationWarning(msg);\n        if (this && this.getLogger) {\n          const logger = this.getLogger();\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    });\n\n    return fn.apply(this, arguments);\n  }\n\n  // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  Object.setPrototypeOf(deprecated, fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nconst SUPPORTS = {};\n// Test asyncIterator support\ntry {\n  require('./async/async_iterator');\n  SUPPORTS.ASYNC_ITERATOR = true;\n} catch (e) {\n  SUPPORTS.ASYNC_ITERATOR = false;\n}\n\nclass MongoDBNamespace {\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection;\n  }\n\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace) {\n    if (!namespace) {\n      throw new Error(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const index = namespace.indexOf('.');\n    return new MongoDBNamespace(namespace.substring(0, index), namespace.substring(index + 1));\n  }\n}\n\nfunction* makeCounter(seed) {\n  let count = seed || 0;\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n\n/**\n * Helper function for either accepting a callback, or returning a promise\n *\n * @param {Object} parent an instance of parent with promiseLibrary.\n * @param {object} parent.s an object containing promiseLibrary.\n * @param {function} parent.s.promiseLibrary an object containing promiseLibrary.\n * @param {[Function]} callback an optional callback.\n * @param {Function} fn A function that takes a callback\n * @returns {Promise|void} Returns nothing if a callback is supplied, else returns a Promise.\n */\nfunction maybePromise(parent, callback, fn) {\n  const PromiseLibrary = (parent && parent.s && parent.s.promiseLibrary) || Promise;\n\n  let result;\n  if (typeof callback !== 'function') {\n    result = new PromiseLibrary((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  fn(function(err, res) {\n    if (err != null) {\n      try {\n        callback(err);\n      } catch (error) {\n        return process.nextTick(() => {\n          throw error;\n        });\n      }\n      return;\n    }\n\n    callback(err, res);\n  });\n\n  return result;\n}\n\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw TypeError('numeric value required to calculate duration');\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n *\n * @param {function} fn An async function to run on an interval, must accept a `callback` as its only parameter\n * @param {object} [options] Optional settings\n * @param {number} [options.interval] The interval at which to run the provided function\n * @param {number} [options.minInterval] The minimum time which must pass between invocations of the provided function\n * @param {boolean} [options.immediate] Execute the function immediately when the interval is started\n */\nfunction makeInterruptableAsyncInterval(fn, options) {\n  let timerId;\n  let lastCallTime;\n  let lastWakeTime;\n  let stopped = false;\n\n  options = options || {};\n  const interval = options.interval || 1000;\n  const minInterval = options.minInterval || 500;\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n  const clock = typeof options.clock === 'function' ? options.clock : now;\n\n  function wake() {\n    const currentTime = clock();\n    const timeSinceLastWake = currentTime - lastWakeTime;\n    const timeSinceLastCall = currentTime - lastCallTime;\n    const timeUntilNextCall = interval - timeSinceLastCall;\n    lastWakeTime = currentTime;\n\n    // For the streaming protocol: there is nothing obviously stopping this\n    // interval from being woken up again while we are waiting \"infinitely\"\n    // for `fn` to be called again`. Since the function effectively\n    // never completes, the `timeUntilNextCall` will continue to grow\n    // negatively unbounded, so it will never trigger a reschedule here.\n\n    // debounce multiple calls to wake within the `minInterval`\n    if (timeSinceLastWake < minInterval) {\n      return;\n    }\n\n    // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n    if (timeUntilNextCall > minInterval) {\n      reschedule(minInterval);\n    }\n\n    // This is possible in virtualized environments like AWS Lambda where our\n    // clock is unreliable. In these cases the timer is \"running\" but never\n    // actually completes, so we want to execute immediately and then attempt\n    // to reschedule.\n    if (timeUntilNextCall < 0) {\n      executeAndReschedule();\n    }\n  }\n\n  function stop() {\n    stopped = true;\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = null;\n    }\n\n    lastCallTime = 0;\n    lastWakeTime = 0;\n  }\n\n  function reschedule(ms) {\n    if (stopped) return;\n    clearTimeout(timerId);\n    timerId = setTimeout(executeAndReschedule, ms || interval);\n  }\n\n  function executeAndReschedule() {\n    lastWakeTime = 0;\n    lastCallTime = clock();\n\n    fn(err => {\n      if (err) throw err;\n      reschedule(interval);\n    });\n  }\n\n  if (immediate) {\n    executeAndReschedule();\n  } else {\n    lastCallTime = clock();\n    reschedule();\n  }\n\n  return { wake, stop };\n}\n\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    return doc.reduce((err, u) => err || hasAtomicOperators(u), null);\n  }\n\n  return (\n    Object.keys(typeof doc.toBSON !== 'function' ? doc : doc.toBSON())\n      .map(k => k[0])\n      .indexOf('$') >= 0\n  );\n}\n\nmodule.exports = {\n  filterOptions,\n  mergeOptions,\n  translateOptions,\n  shallowClone,\n  getSingleProperty,\n  checkCollectionName,\n  toError,\n  formattedOrderClause,\n  parseIndexOptions,\n  normalizeHintField,\n  handleCallback,\n  decorateCommand,\n  isObject,\n  debugOptions,\n  MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,\n  mergeOptionsAndWriteConcern,\n  executeLegacyOperation,\n  applyRetryableWrites,\n  applyWriteConcern,\n  isPromiseLike,\n  decorateWithCollation,\n  decorateWithReadConcern,\n  decorateWithExplain,\n  deprecateOptions,\n  SUPPORTS,\n  MongoDBNamespace,\n  emitDeprecationWarning,\n  makeCounter,\n  maybePromise,\n  now,\n  calculateDurationInMs,\n  makeInterruptableAsyncInterval,\n  hasAtomicOperators\n};\n"]},"metadata":{},"sourceType":"script"}