{"ast":null,"code":"'use strict';\n\nconst ReadPreference = require('./read_preference');\n\nconst TopologyType = require('../sdam/common').TopologyType;\n\nconst MongoError = require('../error').MongoError;\n\nconst isRetryableWriteError = require('../error').isRetryableWriteError;\n\nconst maxWireVersion = require('../utils').maxWireVersion;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = 20;\n/**\n * Emit event if it exists\n * @method\n */\n\nfunction emitSDAMEvent(self, event, description) {\n  if (self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n}\n\nfunction createCompressionInfo(options) {\n  if (!options.compression || !options.compression.compressors) {\n    return [];\n  } // Check that all supplied compressors are valid\n\n\n  options.compression.compressors.forEach(function (compressor) {\n    if (compressor !== 'snappy' && compressor !== 'zlib') {\n      throw new Error('compressors must be at least one of snappy or zlib');\n    }\n  });\n  return options.compression.compressors;\n}\n\nfunction clone(object) {\n  return JSON.parse(JSON.stringify(object));\n}\n\nvar getPreviousDescription = function (self) {\n  if (!self.s.serverDescription) {\n    self.s.serverDescription = {\n      address: self.name,\n      arbiters: [],\n      hosts: [],\n      passives: [],\n      type: 'Unknown'\n    };\n  }\n\n  return self.s.serverDescription;\n};\n\nvar emitServerDescriptionChanged = function (self, description) {\n  if (self.listeners('serverDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('serverDescriptionChanged', {\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n      address: self.name,\n      previousDescription: getPreviousDescription(self),\n      newDescription: description\n    });\n    self.s.serverDescription = description;\n  }\n};\n\nvar getPreviousTopologyDescription = function (self) {\n  if (!self.s.topologyDescription) {\n    self.s.topologyDescription = {\n      topologyType: 'Unknown',\n      servers: [{\n        address: self.name,\n        arbiters: [],\n        hosts: [],\n        passives: [],\n        type: 'Unknown'\n      }]\n    };\n  }\n\n  return self.s.topologyDescription;\n};\n\nvar emitTopologyDescriptionChanged = function (self, description) {\n  if (self.listeners('topologyDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('topologyDescriptionChanged', {\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n      address: self.name,\n      previousDescription: getPreviousTopologyDescription(self),\n      newDescription: description\n    });\n    self.s.serverDescription = description;\n  }\n};\n\nvar changedIsMaster = function (self, currentIsmaster, ismaster) {\n  var currentType = getTopologyType(self, currentIsmaster);\n  var newType = getTopologyType(self, ismaster);\n  if (newType !== currentType) return true;\n  return false;\n};\n\nvar getTopologyType = function (self, ismaster) {\n  if (!ismaster) {\n    ismaster = self.ismaster;\n  }\n\n  if (!ismaster) return 'Unknown';\n  if (ismaster.ismaster && ismaster.msg === 'isdbgrid') return 'Mongos';\n  if (ismaster.ismaster && !ismaster.hosts) return 'Standalone';\n  if (ismaster.ismaster) return 'RSPrimary';\n  if (ismaster.secondary) return 'RSSecondary';\n  if (ismaster.arbiterOnly) return 'RSArbiter';\n  return 'Unknown';\n};\n\nvar inquireServerState = function (self) {\n  return function (callback) {\n    if (self.s.state === 'destroyed') return; // Record response time\n\n    var start = new Date().getTime(); // emitSDAMEvent\n\n    emitSDAMEvent(self, 'serverHeartbeatStarted', {\n      connectionId: self.name\n    }); // Attempt to execute ismaster command\n\n    self.command('admin.$cmd', {\n      ismaster: true\n    }, {\n      monitoring: true\n    }, function (err, r) {\n      if (!err) {\n        // Legacy event sender\n        self.emit('ismaster', r, self); // Calculate latencyMS\n\n        var latencyMS = new Date().getTime() - start; // Server heart beat event\n\n        emitSDAMEvent(self, 'serverHeartbeatSucceeded', {\n          durationMS: latencyMS,\n          reply: r.result,\n          connectionId: self.name\n        }); // Did the server change\n\n        if (changedIsMaster(self, self.s.ismaster, r.result)) {\n          // Emit server description changed if something listening\n          emitServerDescriptionChanged(self, {\n            address: self.name,\n            arbiters: [],\n            hosts: [],\n            passives: [],\n            type: !self.s.inTopology ? 'Standalone' : getTopologyType(self)\n          });\n        } // Updat ismaster view\n\n\n        self.s.ismaster = r.result; // Set server response time\n\n        self.s.isMasterLatencyMS = latencyMS;\n      } else {\n        emitSDAMEvent(self, 'serverHeartbeatFailed', {\n          durationMS: latencyMS,\n          failure: err,\n          connectionId: self.name\n        });\n      } // Peforming an ismaster monitoring callback operation\n\n\n      if (typeof callback === 'function') {\n        return callback(err, r);\n      } // Perform another sweep\n\n\n      self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), self.s.haInterval);\n    });\n  };\n}; //\n// Clone the options\n\n\nvar cloneOptions = function (options) {\n  var opts = {};\n\n  for (var name in options) {\n    opts[name] = options[name];\n  }\n\n  return opts;\n};\n\nfunction Interval(fn, time) {\n  var timer = false;\n\n  this.start = function () {\n    if (!this.isRunning()) {\n      timer = setInterval(fn, time);\n    }\n\n    return this;\n  };\n\n  this.stop = function () {\n    clearInterval(timer);\n    timer = false;\n    return this;\n  };\n\n  this.isRunning = function () {\n    return timer !== false;\n  };\n}\n\nfunction Timeout(fn, time) {\n  var timer = false;\n\n  var func = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = false;\n      fn();\n    }\n  };\n\n  this.start = function () {\n    if (!this.isRunning()) {\n      timer = setTimeout(func, time);\n    }\n\n    return this;\n  };\n\n  this.stop = function () {\n    clearTimeout(timer);\n    timer = false;\n    return this;\n  };\n\n  this.isRunning = function () {\n    return timer !== false;\n  };\n}\n\nfunction diff(previous, current) {\n  // Difference document\n  var diff = {\n    servers: []\n  }; // Previous entry\n\n  if (!previous) {\n    previous = {\n      servers: []\n    };\n  } // Check if we have any previous servers missing in the current ones\n\n\n  for (var i = 0; i < previous.servers.length; i++) {\n    var found = false;\n\n    for (var j = 0; j < current.servers.length; j++) {\n      if (current.servers[j].address.toLowerCase() === previous.servers[i].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      // Add to the diff\n      diff.servers.push({\n        address: previous.servers[i].address,\n        from: previous.servers[i].type,\n        to: 'Unknown'\n      });\n    }\n  } // Check if there are any severs that don't exist\n\n\n  for (j = 0; j < current.servers.length; j++) {\n    found = false; // Go over all the previous servers\n\n    for (i = 0; i < previous.servers.length; i++) {\n      if (previous.servers[i].address.toLowerCase() === current.servers[j].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    } // Add the server to the diff\n\n\n    if (!found) {\n      diff.servers.push({\n        address: current.servers[j].address,\n        from: 'Unknown',\n        to: current.servers[j].type\n      });\n    }\n  } // Got through all the servers\n\n\n  for (i = 0; i < previous.servers.length; i++) {\n    var prevServer = previous.servers[i]; // Go through all current servers\n\n    for (j = 0; j < current.servers.length; j++) {\n      var currServer = current.servers[j]; // Matching server\n\n      if (prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {\n        // We had a change in state\n        if (prevServer.type !== currServer.type) {\n          diff.servers.push({\n            address: prevServer.address,\n            from: prevServer.type,\n            to: currServer.type\n          });\n        }\n      }\n    }\n  } // Return difference\n\n\n  return diff;\n}\n/**\n * Shared function to determine clusterTime for a given topology\n *\n * @param {*} topology\n * @param {*} clusterTime\n */\n\n\nfunction resolveClusterTime(topology, $clusterTime) {\n  if (topology.clusterTime == null) {\n    topology.clusterTime = $clusterTime;\n  } else {\n    if ($clusterTime.clusterTime.greaterThan(topology.clusterTime.clusterTime)) {\n      topology.clusterTime = $clusterTime;\n    }\n  }\n} // NOTE: this is a temporary move until the topologies can be more formally refactored\n//       to share code.\n\n\nconst SessionMixins = {\n  endSessions: function (sessions, callback) {\n    if (!Array.isArray(sessions)) {\n      sessions = [sessions];\n    } // TODO:\n    //   When connected to a sharded cluster the endSessions command\n    //   can be sent to any mongos. When connected to a replica set the\n    //   endSessions command MUST be sent to the primary if the primary\n    //   is available, otherwise it MUST be sent to any available secondary.\n    //   Is it enough to use: ReadPreference.primaryPreferred ?\n\n\n    this.command('admin.$cmd', {\n      endSessions: sessions\n    }, {\n      readPreference: ReadPreference.primaryPreferred\n    }, () => {\n      // intentionally ignored, per spec\n      if (typeof callback === 'function') callback();\n    });\n  }\n};\n\nfunction topologyType(topology) {\n  if (topology.description) {\n    return topology.description.type;\n  }\n\n  if (topology.type === 'mongos') {\n    return TopologyType.Sharded;\n  } else if (topology.type === 'replset') {\n    return TopologyType.ReplicaSetWithPrimary;\n  }\n\n  return TopologyType.Single;\n}\n\nconst RETRYABLE_WIRE_VERSION = 6;\n/**\n * Determines whether the provided topology supports retryable writes\n *\n * @param {Mongos|Replset} topology\n */\n\nconst isRetryableWritesSupported = function (topology) {\n  const maxWireVersion = topology.lastIsMaster().maxWireVersion;\n\n  if (maxWireVersion < RETRYABLE_WIRE_VERSION) {\n    return false;\n  }\n\n  if (!topology.logicalSessionTimeoutMinutes) {\n    return false;\n  }\n\n  if (topologyType(topology) === TopologyType.Single) {\n    return false;\n  }\n\n  return true;\n};\n\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\nfunction getMMAPError(err) {\n  if (err.code !== MMAPv1_RETRY_WRITES_ERROR_CODE || !err.errmsg.includes('Transaction numbers')) {\n    return err;\n  } // According to the retryable writes spec, we must replace the error message in this case.\n  // We need to replace err.message so the thrown message is correct and we need to replace err.errmsg to meet the spec requirement.\n\n\n  const newErr = new MongoError({\n    message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n    errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n    originalError: err\n  });\n  return newErr;\n} // NOTE: only used for legacy topology types\n\n\nfunction legacyIsRetryableWriteError(err, topology) {\n  if (!(err instanceof MongoError)) {\n    return false;\n  } // if pre-4.4 server, then add error label if its a retryable write error\n\n\n  if (isRetryableWritesSupported(topology) && (err instanceof MongoNetworkError || maxWireVersion(topology) < 9 && isRetryableWriteError(err))) {\n    err.addErrorLabel('RetryableWriteError');\n  }\n\n  return err.hasErrorLabel('RetryableWriteError');\n}\n\nmodule.exports = {\n  SessionMixins,\n  resolveClusterTime,\n  inquireServerState,\n  getTopologyType,\n  emitServerDescriptionChanged,\n  emitTopologyDescriptionChanged,\n  cloneOptions,\n  createCompressionInfo,\n  clone,\n  diff,\n  Interval,\n  Timeout,\n  isRetryableWritesSupported,\n  getMMAPError,\n  topologyType,\n  legacyIsRetryableWriteError\n};","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/core/topologies/shared.js"],"names":["ReadPreference","require","TopologyType","MongoError","isRetryableWriteError","maxWireVersion","MongoNetworkError","MMAPv1_RETRY_WRITES_ERROR_CODE","emitSDAMEvent","self","event","description","listeners","length","emit","createCompressionInfo","options","compression","compressors","forEach","compressor","Error","clone","object","JSON","parse","stringify","getPreviousDescription","s","serverDescription","address","name","arbiters","hosts","passives","type","emitServerDescriptionChanged","topologyId","id","previousDescription","newDescription","getPreviousTopologyDescription","topologyDescription","topologyType","servers","emitTopologyDescriptionChanged","changedIsMaster","currentIsmaster","ismaster","currentType","getTopologyType","newType","msg","secondary","arbiterOnly","inquireServerState","callback","state","start","Date","getTime","connectionId","command","monitoring","err","r","latencyMS","durationMS","reply","result","inTopology","isMasterLatencyMS","failure","inquireServerStateTimeout","setTimeout","haInterval","cloneOptions","opts","Interval","fn","time","timer","isRunning","setInterval","stop","clearInterval","Timeout","func","clearTimeout","diff","previous","current","i","found","j","toLowerCase","push","from","to","prevServer","currServer","resolveClusterTime","topology","$clusterTime","clusterTime","greaterThan","SessionMixins","endSessions","sessions","Array","isArray","readPreference","primaryPreferred","Sharded","ReplicaSetWithPrimary","Single","RETRYABLE_WIRE_VERSION","isRetryableWritesSupported","lastIsMaster","logicalSessionTimeoutMinutes","MMAPv1_RETRY_WRITES_ERROR_MESSAGE","getMMAPError","code","errmsg","includes","newErr","message","originalError","legacyIsRetryableWriteError","addErrorLabel","hasErrorLabel","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst ReadPreference = require('./read_preference');\nconst TopologyType = require('../sdam/common').TopologyType;\nconst MongoError = require('../error').MongoError;\nconst isRetryableWriteError = require('../error').isRetryableWriteError;\nconst maxWireVersion = require('../utils').maxWireVersion;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = 20;\n\n/**\n * Emit event if it exists\n * @method\n */\nfunction emitSDAMEvent(self, event, description) {\n  if (self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n}\n\nfunction createCompressionInfo(options) {\n  if (!options.compression || !options.compression.compressors) {\n    return [];\n  }\n\n  // Check that all supplied compressors are valid\n  options.compression.compressors.forEach(function(compressor) {\n    if (compressor !== 'snappy' && compressor !== 'zlib') {\n      throw new Error('compressors must be at least one of snappy or zlib');\n    }\n  });\n\n  return options.compression.compressors;\n}\n\nfunction clone(object) {\n  return JSON.parse(JSON.stringify(object));\n}\n\nvar getPreviousDescription = function(self) {\n  if (!self.s.serverDescription) {\n    self.s.serverDescription = {\n      address: self.name,\n      arbiters: [],\n      hosts: [],\n      passives: [],\n      type: 'Unknown'\n    };\n  }\n\n  return self.s.serverDescription;\n};\n\nvar emitServerDescriptionChanged = function(self, description) {\n  if (self.listeners('serverDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('serverDescriptionChanged', {\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n      address: self.name,\n      previousDescription: getPreviousDescription(self),\n      newDescription: description\n    });\n\n    self.s.serverDescription = description;\n  }\n};\n\nvar getPreviousTopologyDescription = function(self) {\n  if (!self.s.topologyDescription) {\n    self.s.topologyDescription = {\n      topologyType: 'Unknown',\n      servers: [\n        {\n          address: self.name,\n          arbiters: [],\n          hosts: [],\n          passives: [],\n          type: 'Unknown'\n        }\n      ]\n    };\n  }\n\n  return self.s.topologyDescription;\n};\n\nvar emitTopologyDescriptionChanged = function(self, description) {\n  if (self.listeners('topologyDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('topologyDescriptionChanged', {\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n      address: self.name,\n      previousDescription: getPreviousTopologyDescription(self),\n      newDescription: description\n    });\n\n    self.s.serverDescription = description;\n  }\n};\n\nvar changedIsMaster = function(self, currentIsmaster, ismaster) {\n  var currentType = getTopologyType(self, currentIsmaster);\n  var newType = getTopologyType(self, ismaster);\n  if (newType !== currentType) return true;\n  return false;\n};\n\nvar getTopologyType = function(self, ismaster) {\n  if (!ismaster) {\n    ismaster = self.ismaster;\n  }\n\n  if (!ismaster) return 'Unknown';\n  if (ismaster.ismaster && ismaster.msg === 'isdbgrid') return 'Mongos';\n  if (ismaster.ismaster && !ismaster.hosts) return 'Standalone';\n  if (ismaster.ismaster) return 'RSPrimary';\n  if (ismaster.secondary) return 'RSSecondary';\n  if (ismaster.arbiterOnly) return 'RSArbiter';\n  return 'Unknown';\n};\n\nvar inquireServerState = function(self) {\n  return function(callback) {\n    if (self.s.state === 'destroyed') return;\n    // Record response time\n    var start = new Date().getTime();\n\n    // emitSDAMEvent\n    emitSDAMEvent(self, 'serverHeartbeatStarted', { connectionId: self.name });\n\n    // Attempt to execute ismaster command\n    self.command('admin.$cmd', { ismaster: true }, { monitoring: true }, function(err, r) {\n      if (!err) {\n        // Legacy event sender\n        self.emit('ismaster', r, self);\n\n        // Calculate latencyMS\n        var latencyMS = new Date().getTime() - start;\n\n        // Server heart beat event\n        emitSDAMEvent(self, 'serverHeartbeatSucceeded', {\n          durationMS: latencyMS,\n          reply: r.result,\n          connectionId: self.name\n        });\n\n        // Did the server change\n        if (changedIsMaster(self, self.s.ismaster, r.result)) {\n          // Emit server description changed if something listening\n          emitServerDescriptionChanged(self, {\n            address: self.name,\n            arbiters: [],\n            hosts: [],\n            passives: [],\n            type: !self.s.inTopology ? 'Standalone' : getTopologyType(self)\n          });\n        }\n\n        // Updat ismaster view\n        self.s.ismaster = r.result;\n\n        // Set server response time\n        self.s.isMasterLatencyMS = latencyMS;\n      } else {\n        emitSDAMEvent(self, 'serverHeartbeatFailed', {\n          durationMS: latencyMS,\n          failure: err,\n          connectionId: self.name\n        });\n      }\n\n      // Peforming an ismaster monitoring callback operation\n      if (typeof callback === 'function') {\n        return callback(err, r);\n      }\n\n      // Perform another sweep\n      self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), self.s.haInterval);\n    });\n  };\n};\n\n//\n// Clone the options\nvar cloneOptions = function(options) {\n  var opts = {};\n  for (var name in options) {\n    opts[name] = options[name];\n  }\n  return opts;\n};\n\nfunction Interval(fn, time) {\n  var timer = false;\n\n  this.start = function() {\n    if (!this.isRunning()) {\n      timer = setInterval(fn, time);\n    }\n\n    return this;\n  };\n\n  this.stop = function() {\n    clearInterval(timer);\n    timer = false;\n    return this;\n  };\n\n  this.isRunning = function() {\n    return timer !== false;\n  };\n}\n\nfunction Timeout(fn, time) {\n  var timer = false;\n  var func = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = false;\n\n      fn();\n    }\n  };\n\n  this.start = function() {\n    if (!this.isRunning()) {\n      timer = setTimeout(func, time);\n    }\n    return this;\n  };\n\n  this.stop = function() {\n    clearTimeout(timer);\n    timer = false;\n    return this;\n  };\n\n  this.isRunning = function() {\n    return timer !== false;\n  };\n}\n\nfunction diff(previous, current) {\n  // Difference document\n  var diff = {\n    servers: []\n  };\n\n  // Previous entry\n  if (!previous) {\n    previous = { servers: [] };\n  }\n\n  // Check if we have any previous servers missing in the current ones\n  for (var i = 0; i < previous.servers.length; i++) {\n    var found = false;\n\n    for (var j = 0; j < current.servers.length; j++) {\n      if (current.servers[j].address.toLowerCase() === previous.servers[i].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      // Add to the diff\n      diff.servers.push({\n        address: previous.servers[i].address,\n        from: previous.servers[i].type,\n        to: 'Unknown'\n      });\n    }\n  }\n\n  // Check if there are any severs that don't exist\n  for (j = 0; j < current.servers.length; j++) {\n    found = false;\n\n    // Go over all the previous servers\n    for (i = 0; i < previous.servers.length; i++) {\n      if (previous.servers[i].address.toLowerCase() === current.servers[j].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    }\n\n    // Add the server to the diff\n    if (!found) {\n      diff.servers.push({\n        address: current.servers[j].address,\n        from: 'Unknown',\n        to: current.servers[j].type\n      });\n    }\n  }\n\n  // Got through all the servers\n  for (i = 0; i < previous.servers.length; i++) {\n    var prevServer = previous.servers[i];\n\n    // Go through all current servers\n    for (j = 0; j < current.servers.length; j++) {\n      var currServer = current.servers[j];\n\n      // Matching server\n      if (prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {\n        // We had a change in state\n        if (prevServer.type !== currServer.type) {\n          diff.servers.push({\n            address: prevServer.address,\n            from: prevServer.type,\n            to: currServer.type\n          });\n        }\n      }\n    }\n  }\n\n  // Return difference\n  return diff;\n}\n\n/**\n * Shared function to determine clusterTime for a given topology\n *\n * @param {*} topology\n * @param {*} clusterTime\n */\nfunction resolveClusterTime(topology, $clusterTime) {\n  if (topology.clusterTime == null) {\n    topology.clusterTime = $clusterTime;\n  } else {\n    if ($clusterTime.clusterTime.greaterThan(topology.clusterTime.clusterTime)) {\n      topology.clusterTime = $clusterTime;\n    }\n  }\n}\n\n// NOTE: this is a temporary move until the topologies can be more formally refactored\n//       to share code.\nconst SessionMixins = {\n  endSessions: function(sessions, callback) {\n    if (!Array.isArray(sessions)) {\n      sessions = [sessions];\n    }\n\n    // TODO:\n    //   When connected to a sharded cluster the endSessions command\n    //   can be sent to any mongos. When connected to a replica set the\n    //   endSessions command MUST be sent to the primary if the primary\n    //   is available, otherwise it MUST be sent to any available secondary.\n    //   Is it enough to use: ReadPreference.primaryPreferred ?\n    this.command(\n      'admin.$cmd',\n      { endSessions: sessions },\n      { readPreference: ReadPreference.primaryPreferred },\n      () => {\n        // intentionally ignored, per spec\n        if (typeof callback === 'function') callback();\n      }\n    );\n  }\n};\n\nfunction topologyType(topology) {\n  if (topology.description) {\n    return topology.description.type;\n  }\n\n  if (topology.type === 'mongos') {\n    return TopologyType.Sharded;\n  } else if (topology.type === 'replset') {\n    return TopologyType.ReplicaSetWithPrimary;\n  }\n\n  return TopologyType.Single;\n}\n\nconst RETRYABLE_WIRE_VERSION = 6;\n\n/**\n * Determines whether the provided topology supports retryable writes\n *\n * @param {Mongos|Replset} topology\n */\nconst isRetryableWritesSupported = function(topology) {\n  const maxWireVersion = topology.lastIsMaster().maxWireVersion;\n  if (maxWireVersion < RETRYABLE_WIRE_VERSION) {\n    return false;\n  }\n\n  if (!topology.logicalSessionTimeoutMinutes) {\n    return false;\n  }\n\n  if (topologyType(topology) === TopologyType.Single) {\n    return false;\n  }\n\n  return true;\n};\n\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE =\n  'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\nfunction getMMAPError(err) {\n  if (err.code !== MMAPv1_RETRY_WRITES_ERROR_CODE || !err.errmsg.includes('Transaction numbers')) {\n    return err;\n  }\n\n  // According to the retryable writes spec, we must replace the error message in this case.\n  // We need to replace err.message so the thrown message is correct and we need to replace err.errmsg to meet the spec requirement.\n  const newErr = new MongoError({\n    message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n    errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n    originalError: err\n  });\n  return newErr;\n}\n\n// NOTE: only used for legacy topology types\nfunction legacyIsRetryableWriteError(err, topology) {\n  if (!(err instanceof MongoError)) {\n    return false;\n  }\n\n  // if pre-4.4 server, then add error label if its a retryable write error\n  if (\n    isRetryableWritesSupported(topology) &&\n    (err instanceof MongoNetworkError ||\n      (maxWireVersion(topology) < 9 && isRetryableWriteError(err)))\n  ) {\n    err.addErrorLabel('RetryableWriteError');\n  }\n\n  return err.hasErrorLabel('RetryableWriteError');\n}\n\nmodule.exports = {\n  SessionMixins,\n  resolveClusterTime,\n  inquireServerState,\n  getTopologyType,\n  emitServerDescriptionChanged,\n  emitTopologyDescriptionChanged,\n  cloneOptions,\n  createCompressionInfo,\n  clone,\n  diff,\n  Interval,\n  Timeout,\n  isRetryableWritesSupported,\n  getMMAPError,\n  topologyType,\n  legacyIsRetryableWriteError\n};\n"]},"metadata":{},"sourceType":"script"}