{"ast":null,"code":"'use strict';\n\nconst net = require('net');\n\nconst tls = require('tls');\n\nconst Connection = require('./connection');\n\nconst MongoError = require('../error').MongoError;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst MongoNetworkTimeoutError = require('../error').MongoNetworkTimeoutError;\n\nconst defaultAuthProviders = require('../auth/defaultAuthProviders').defaultAuthProviders;\n\nconst AuthContext = require('../auth/auth_provider').AuthContext;\n\nconst WIRE_CONSTANTS = require('../wireprotocol/constants');\n\nconst makeClientMetadata = require('../utils').makeClientMetadata;\n\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nlet AUTH_PROVIDERS;\n\nfunction connect(options, cancellationToken, callback) {\n  if (typeof cancellationToken === 'function') {\n    callback = cancellationToken;\n    cancellationToken = undefined;\n  }\n\n  const ConnectionType = options && options.connectionType ? options.connectionType : Connection;\n\n  if (AUTH_PROVIDERS == null) {\n    AUTH_PROVIDERS = defaultAuthProviders(options.bson);\n  }\n\n  const family = options.family !== void 0 ? options.family : 0;\n  makeConnection(family, options, cancellationToken, (err, socket) => {\n    if (err) {\n      callback(err, socket); // in the error case, `socket` is the originating error event name\n\n      return;\n    }\n\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\n\nfunction isModernConnectionType(conn) {\n  return !(conn instanceof Connection);\n}\n\nfunction checkSupportedServer(ismaster, options) {\n  const serverVersionHighEnough = ismaster && typeof ismaster.maxWireVersion === 'number' && ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough = ismaster && typeof ismaster.minWireVersion === 'number' && ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.host}:${options.port} reports minimum wire version ${ismaster.minWireVersion}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n    return new MongoError(message);\n  }\n\n  const message = `Server at ${options.host}:${options.port} reports maximum wire version ${ismaster.maxWireVersion || 0}, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;\n  return new MongoError(message);\n}\n\nfunction performInitialHandshake(conn, options, _callback) {\n  const callback = function (err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  const credentials = options.credentials;\n\n  if (credentials) {\n    if (!credentials.mechanism.match(/DEFAULT/i) && !AUTH_PROVIDERS[credentials.mechanism]) {\n      callback(new MongoError(`authMechanism '${credentials.mechanism}' not supported`));\n      return;\n    }\n  }\n\n  const authContext = new AuthContext(conn, credentials, options);\n  prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const handshakeOptions = Object.assign({}, options);\n\n    if (options.connectTimeoutMS || options.connectionTimeout) {\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n      handshakeOptions.socketTimeout = options.connectTimeoutMS || options.connectionTimeout;\n    }\n\n    const start = new Date().getTime();\n    conn.command('admin.$cmd', handshakeDoc, handshakeOptions, (err, result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      const response = result.result;\n\n      if (response.ok === 0) {\n        callback(new MongoError(response));\n        return;\n      }\n\n      const supportedServerErr = checkSupportedServer(response, options);\n\n      if (supportedServerErr) {\n        callback(supportedServerErr);\n        return;\n      }\n\n      if (!isModernConnectionType(conn)) {\n        // resolve compression\n        if (response.compression) {\n          const agreedCompressors = handshakeDoc.compression.filter(compressor => response.compression.indexOf(compressor) !== -1);\n\n          if (agreedCompressors.length) {\n            conn.agreedCompressor = agreedCompressors[0];\n          }\n\n          if (options.compression && options.compression.zlibCompressionLevel) {\n            conn.zlibCompressionLevel = options.compression.zlibCompressionLevel;\n          }\n        }\n      } // NOTE: This is metadata attached to the connection while porting away from\n      //       handshake being done in the `Server` class. Likely, it should be\n      //       relocated, or at very least restructured.\n\n\n      conn.ismaster = response;\n      conn.lastIsMasterMS = new Date().getTime() - start;\n\n      if (!response.arbiterOnly && credentials) {\n        // store the response on auth context\n        Object.assign(authContext, {\n          response\n        });\n        const resolvedCredentials = credentials.resolveAuthMechanism(response);\n        const authProvider = AUTH_PROVIDERS[resolvedCredentials.mechanism];\n        authProvider.auth(authContext, err => {\n          if (err) return callback(err);\n          callback(undefined, conn);\n        });\n        return;\n      }\n\n      callback(undefined, conn);\n    });\n  });\n}\n\nfunction prepareHandshakeDocument(authContext, callback) {\n  const options = authContext.options;\n  const compressors = options.compression && options.compression.compressors ? options.compression.compressors : [];\n  const handshakeDoc = {\n    ismaster: true,\n    client: options.metadata || makeClientMetadata(options),\n    compression: compressors\n  };\n  const credentials = authContext.credentials;\n\n  if (credentials) {\n    if (credentials.mechanism.match(/DEFAULT/i) && credentials.username) {\n      Object.assign(handshakeDoc, {\n        saslSupportedMechs: `${credentials.source}.${credentials.username}`\n      });\n      AUTH_PROVIDERS['scram-sha-256'].prepare(handshakeDoc, authContext, callback);\n      return;\n    }\n\n    const authProvider = AUTH_PROVIDERS[credentials.mechanism];\n    authProvider.prepare(handshakeDoc, authContext, callback);\n    return;\n  }\n\n  callback(undefined, handshakeDoc);\n}\n\nconst LEGAL_SSL_SOCKET_OPTIONS = ['pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'NPNProtocols', 'ALPNProtocols', 'servername', 'ecdhCurve', 'secureProtocol', 'secureContext', 'session', 'minDHSize', 'crl', 'rejectUnauthorized'];\n\nfunction parseConnectOptions(family, options) {\n  const host = typeof options.host === 'string' ? options.host : 'localhost';\n\n  if (host.indexOf('/') !== -1) {\n    return {\n      path: host\n    };\n  }\n\n  const result = {\n    family,\n    host,\n    port: typeof options.port === 'number' ? options.port : 27017,\n    rejectUnauthorized: false\n  };\n  return result;\n}\n\nfunction parseSslOptions(family, options) {\n  const result = parseConnectOptions(family, options); // Merge in valid SSL options\n\n  for (const name in options) {\n    if (options[name] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name) !== -1) {\n      result[name] = options[name];\n    }\n  } // Override checkServerIdentity behavior\n\n\n  if (options.checkServerIdentity === false) {\n    // Skip the identiy check by retuning undefined as per node documents\n    // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback\n    result.checkServerIdentity = function () {\n      return undefined;\n    };\n  } else if (typeof options.checkServerIdentity === 'function') {\n    result.checkServerIdentity = options.checkServerIdentity;\n  } // Set default sni servername to be the same as host\n\n\n  if (result.servername == null) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nconst SOCKET_ERROR_EVENTS = new Set(['error', 'close', 'timeout', 'parseError']);\n\nfunction makeConnection(family, options, cancellationToken, _callback) {\n  const useSsl = typeof options.ssl === 'boolean' ? options.ssl : false;\n  const keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n  let keepAliveInitialDelay = typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 120000;\n  const noDelay = typeof options.noDelay === 'boolean' ? options.noDelay : true;\n  const connectionTimeout = typeof options.connectionTimeout === 'number' ? options.connectionTimeout : typeof options.connectTimeoutMS === 'number' ? options.connectTimeoutMS : 30000;\n  const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n  const rejectUnauthorized = typeof options.rejectUnauthorized === 'boolean' ? options.rejectUnauthorized : true;\n\n  if (keepAliveInitialDelay > socketTimeout) {\n    keepAliveInitialDelay = Math.round(socketTimeout / 2);\n  }\n\n  let socket;\n\n  const callback = function (err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  try {\n    if (useSsl) {\n      socket = tls.connect(parseSslOptions(family, options));\n\n      if (typeof socket.disableRenegotiation === 'function') {\n        socket.disableRenegotiation();\n      }\n    } else {\n      socket = net.createConnection(parseConnectOptions(family, options));\n    }\n  } catch (err) {\n    return callback(err);\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectionTimeout);\n  socket.setNoDelay(noDelay);\n  const connectEvent = useSsl ? 'secureConnect' : 'connect';\n  let cancellationHandler;\n\n  function errorHandler(eventName) {\n    return err => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n\n      if (cancellationHandler) {\n        cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n\n    if (cancellationHandler) {\n      cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if (socket.authorizationError && rejectUnauthorized) {\n      return callback(socket.authorizationError);\n    }\n\n    socket.setTimeout(socketTimeout);\n    callback(null, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n\n  if (cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  socket.once(connectEvent, connectHandler);\n}\n\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new MongoNetworkError(err);\n\n    case 'timeout':\n      return new MongoNetworkTimeoutError(`connection timed out`);\n\n    case 'close':\n      return new MongoNetworkError(`connection closed`);\n\n    case 'cancel':\n      return new MongoNetworkError(`connection establishment was cancelled`);\n\n    default:\n      return new MongoNetworkError(`unknown network error`);\n  }\n}\n\nmodule.exports = connect;","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/core/connection/connect.js"],"names":["net","require","tls","Connection","MongoError","MongoNetworkError","MongoNetworkTimeoutError","defaultAuthProviders","AuthContext","WIRE_CONSTANTS","makeClientMetadata","MAX_SUPPORTED_WIRE_VERSION","MAX_SUPPORTED_SERVER_VERSION","MIN_SUPPORTED_WIRE_VERSION","MIN_SUPPORTED_SERVER_VERSION","AUTH_PROVIDERS","connect","options","cancellationToken","callback","undefined","ConnectionType","connectionType","bson","family","makeConnection","err","socket","performInitialHandshake","isModernConnectionType","conn","checkSupportedServer","ismaster","serverVersionHighEnough","maxWireVersion","serverVersionLowEnough","minWireVersion","message","host","port","_callback","ret","destroy","credentials","mechanism","match","authContext","prepareHandshakeDocument","handshakeDoc","handshakeOptions","Object","assign","connectTimeoutMS","connectionTimeout","socketTimeout","start","Date","getTime","command","result","response","ok","supportedServerErr","compression","agreedCompressors","filter","compressor","indexOf","length","agreedCompressor","zlibCompressionLevel","lastIsMasterMS","arbiterOnly","resolvedCredentials","resolveAuthMechanism","authProvider","auth","compressors","client","metadata","username","saslSupportedMechs","source","prepare","LEGAL_SSL_SOCKET_OPTIONS","parseConnectOptions","path","rejectUnauthorized","parseSslOptions","name","checkServerIdentity","servername","SOCKET_ERROR_EVENTS","Set","useSsl","ssl","keepAlive","keepAliveInitialDelay","noDelay","Math","round","disableRenegotiation","createConnection","setKeepAlive","setTimeout","setNoDelay","connectEvent","cancellationHandler","errorHandler","eventName","forEach","event","removeAllListeners","removeListener","connectHandler","connectionFailureError","authorizationError","once","type","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst net = require('net');\nconst tls = require('tls');\nconst Connection = require('./connection');\nconst MongoError = require('../error').MongoError;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst MongoNetworkTimeoutError = require('../error').MongoNetworkTimeoutError;\nconst defaultAuthProviders = require('../auth/defaultAuthProviders').defaultAuthProviders;\nconst AuthContext = require('../auth/auth_provider').AuthContext;\nconst WIRE_CONSTANTS = require('../wireprotocol/constants');\nconst makeClientMetadata = require('../utils').makeClientMetadata;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nlet AUTH_PROVIDERS;\n\nfunction connect(options, cancellationToken, callback) {\n  if (typeof cancellationToken === 'function') {\n    callback = cancellationToken;\n    cancellationToken = undefined;\n  }\n\n  const ConnectionType = options && options.connectionType ? options.connectionType : Connection;\n  if (AUTH_PROVIDERS == null) {\n    AUTH_PROVIDERS = defaultAuthProviders(options.bson);\n  }\n\n  const family = options.family !== void 0 ? options.family : 0;\n  makeConnection(family, options, cancellationToken, (err, socket) => {\n    if (err) {\n      callback(err, socket); // in the error case, `socket` is the originating error event name\n      return;\n    }\n\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\n\nfunction isModernConnectionType(conn) {\n  return !(conn instanceof Connection);\n}\n\nfunction checkSupportedServer(ismaster, options) {\n  const serverVersionHighEnough =\n    ismaster &&\n    typeof ismaster.maxWireVersion === 'number' &&\n    ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough =\n    ismaster &&\n    typeof ismaster.minWireVersion === 'number' &&\n    ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.host}:${options.port} reports minimum wire version ${ismaster.minWireVersion}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n    return new MongoError(message);\n  }\n\n  const message = `Server at ${options.host}:${\n    options.port\n  } reports maximum wire version ${ismaster.maxWireVersion ||\n    0}, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;\n  return new MongoError(message);\n}\n\nfunction performInitialHandshake(conn, options, _callback) {\n  const callback = function(err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n    _callback(err, ret);\n  };\n\n  const credentials = options.credentials;\n  if (credentials) {\n    if (!credentials.mechanism.match(/DEFAULT/i) && !AUTH_PROVIDERS[credentials.mechanism]) {\n      callback(new MongoError(`authMechanism '${credentials.mechanism}' not supported`));\n      return;\n    }\n  }\n\n  const authContext = new AuthContext(conn, credentials, options);\n  prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const handshakeOptions = Object.assign({}, options);\n    if (options.connectTimeoutMS || options.connectionTimeout) {\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n      handshakeOptions.socketTimeout = options.connectTimeoutMS || options.connectionTimeout;\n    }\n\n    const start = new Date().getTime();\n    conn.command('admin.$cmd', handshakeDoc, handshakeOptions, (err, result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      const response = result.result;\n      if (response.ok === 0) {\n        callback(new MongoError(response));\n        return;\n      }\n\n      const supportedServerErr = checkSupportedServer(response, options);\n      if (supportedServerErr) {\n        callback(supportedServerErr);\n        return;\n      }\n\n      if (!isModernConnectionType(conn)) {\n        // resolve compression\n        if (response.compression) {\n          const agreedCompressors = handshakeDoc.compression.filter(\n            compressor => response.compression.indexOf(compressor) !== -1\n          );\n\n          if (agreedCompressors.length) {\n            conn.agreedCompressor = agreedCompressors[0];\n          }\n\n          if (options.compression && options.compression.zlibCompressionLevel) {\n            conn.zlibCompressionLevel = options.compression.zlibCompressionLevel;\n          }\n        }\n      }\n\n      // NOTE: This is metadata attached to the connection while porting away from\n      //       handshake being done in the `Server` class. Likely, it should be\n      //       relocated, or at very least restructured.\n      conn.ismaster = response;\n      conn.lastIsMasterMS = new Date().getTime() - start;\n\n      if (!response.arbiterOnly && credentials) {\n        // store the response on auth context\n        Object.assign(authContext, { response });\n\n        const resolvedCredentials = credentials.resolveAuthMechanism(response);\n        const authProvider = AUTH_PROVIDERS[resolvedCredentials.mechanism];\n        authProvider.auth(authContext, err => {\n          if (err) return callback(err);\n          callback(undefined, conn);\n        });\n\n        return;\n      }\n\n      callback(undefined, conn);\n    });\n  });\n}\n\nfunction prepareHandshakeDocument(authContext, callback) {\n  const options = authContext.options;\n  const compressors =\n    options.compression && options.compression.compressors ? options.compression.compressors : [];\n\n  const handshakeDoc = {\n    ismaster: true,\n    client: options.metadata || makeClientMetadata(options),\n    compression: compressors\n  };\n\n  const credentials = authContext.credentials;\n  if (credentials) {\n    if (credentials.mechanism.match(/DEFAULT/i) && credentials.username) {\n      Object.assign(handshakeDoc, {\n        saslSupportedMechs: `${credentials.source}.${credentials.username}`\n      });\n\n      AUTH_PROVIDERS['scram-sha-256'].prepare(handshakeDoc, authContext, callback);\n      return;\n    }\n\n    const authProvider = AUTH_PROVIDERS[credentials.mechanism];\n    authProvider.prepare(handshakeDoc, authContext, callback);\n    return;\n  }\n\n  callback(undefined, handshakeDoc);\n}\n\nconst LEGAL_SSL_SOCKET_OPTIONS = [\n  'pfx',\n  'key',\n  'passphrase',\n  'cert',\n  'ca',\n  'ciphers',\n  'NPNProtocols',\n  'ALPNProtocols',\n  'servername',\n  'ecdhCurve',\n  'secureProtocol',\n  'secureContext',\n  'session',\n  'minDHSize',\n  'crl',\n  'rejectUnauthorized'\n];\n\nfunction parseConnectOptions(family, options) {\n  const host = typeof options.host === 'string' ? options.host : 'localhost';\n  if (host.indexOf('/') !== -1) {\n    return { path: host };\n  }\n\n  const result = {\n    family,\n    host,\n    port: typeof options.port === 'number' ? options.port : 27017,\n    rejectUnauthorized: false\n  };\n\n  return result;\n}\n\nfunction parseSslOptions(family, options) {\n  const result = parseConnectOptions(family, options);\n\n  // Merge in valid SSL options\n  for (const name in options) {\n    if (options[name] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name) !== -1) {\n      result[name] = options[name];\n    }\n  }\n\n  // Override checkServerIdentity behavior\n  if (options.checkServerIdentity === false) {\n    // Skip the identiy check by retuning undefined as per node documents\n    // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback\n    result.checkServerIdentity = function() {\n      return undefined;\n    };\n  } else if (typeof options.checkServerIdentity === 'function') {\n    result.checkServerIdentity = options.checkServerIdentity;\n  }\n\n  // Set default sni servername to be the same as host\n  if (result.servername == null) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nconst SOCKET_ERROR_EVENTS = new Set(['error', 'close', 'timeout', 'parseError']);\nfunction makeConnection(family, options, cancellationToken, _callback) {\n  const useSsl = typeof options.ssl === 'boolean' ? options.ssl : false;\n  const keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n  let keepAliveInitialDelay =\n    typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 120000;\n  const noDelay = typeof options.noDelay === 'boolean' ? options.noDelay : true;\n  const connectionTimeout =\n    typeof options.connectionTimeout === 'number'\n      ? options.connectionTimeout\n      : typeof options.connectTimeoutMS === 'number'\n      ? options.connectTimeoutMS\n      : 30000;\n  const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n  const rejectUnauthorized =\n    typeof options.rejectUnauthorized === 'boolean' ? options.rejectUnauthorized : true;\n\n  if (keepAliveInitialDelay > socketTimeout) {\n    keepAliveInitialDelay = Math.round(socketTimeout / 2);\n  }\n\n  let socket;\n  const callback = function(err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  try {\n    if (useSsl) {\n      socket = tls.connect(parseSslOptions(family, options));\n      if (typeof socket.disableRenegotiation === 'function') {\n        socket.disableRenegotiation();\n      }\n    } else {\n      socket = net.createConnection(parseConnectOptions(family, options));\n    }\n  } catch (err) {\n    return callback(err);\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectionTimeout);\n  socket.setNoDelay(noDelay);\n\n  const connectEvent = useSsl ? 'secureConnect' : 'connect';\n  let cancellationHandler;\n  function errorHandler(eventName) {\n    return err => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n      if (cancellationHandler) {\n        cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n    if (cancellationHandler) {\n      cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if (socket.authorizationError && rejectUnauthorized) {\n      return callback(socket.authorizationError);\n    }\n\n    socket.setTimeout(socketTimeout);\n    callback(null, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n  if (cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  socket.once(connectEvent, connectHandler);\n}\n\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new MongoNetworkError(err);\n    case 'timeout':\n      return new MongoNetworkTimeoutError(`connection timed out`);\n    case 'close':\n      return new MongoNetworkError(`connection closed`);\n    case 'cancel':\n      return new MongoNetworkError(`connection establishment was cancelled`);\n    default:\n      return new MongoNetworkError(`unknown network error`);\n  }\n}\n\nmodule.exports = connect;\n"]},"metadata":{},"sourceType":"script"}