{"ast":null,"code":"'use strict';\n\nvar Emitter = require('events').EventEmitter;\n\nvar GridFSBucketReadStream = require('./download');\n\nvar GridFSBucketWriteStream = require('./upload');\n\nvar shallowClone = require('../utils').shallowClone;\n\nvar toError = require('../utils').toError;\n\nvar util = require('util');\n\nvar executeLegacyOperation = require('../utils').executeLegacyOperation;\n\nvar DEFAULT_GRIDFS_BUCKET_OPTIONS = {\n  bucketName: 'fs',\n  chunkSizeBytes: 255 * 1024\n};\nmodule.exports = GridFSBucket;\n/**\n * Constructor for a streaming GridFS interface\n * @class\n * @extends external:EventEmitter\n * @param {Db} db A db handle\n * @param {object} [options] Optional settings.\n * @param {string} [options.bucketName=\"fs\"] The 'files' and 'chunks' collections will be prefixed with the bucket name followed by a dot.\n * @param {number} [options.chunkSizeBytes=255 * 1024] Number of bytes stored in each chunk. Defaults to 255KB\n * @param {object} [options.writeConcern] Optional write concern to be passed to write operations, for instance `{ w: 1 }`\n * @param {object} [options.readPreference] Optional read preference to be passed to read operations\n * @fires GridFSBucketWriteStream#index\n */\n\nfunction GridFSBucket(db, options) {\n  Emitter.apply(this);\n  this.setMaxListeners(0);\n\n  if (options && typeof options === 'object') {\n    options = shallowClone(options);\n    var keys = Object.keys(DEFAULT_GRIDFS_BUCKET_OPTIONS);\n\n    for (var i = 0; i < keys.length; ++i) {\n      if (!options[keys[i]]) {\n        options[keys[i]] = DEFAULT_GRIDFS_BUCKET_OPTIONS[keys[i]];\n      }\n    }\n  } else {\n    options = DEFAULT_GRIDFS_BUCKET_OPTIONS;\n  }\n\n  this.s = {\n    db: db,\n    options: options,\n    _chunksCollection: db.collection(options.bucketName + '.chunks'),\n    _filesCollection: db.collection(options.bucketName + '.files'),\n    checkedIndexes: false,\n    calledOpenUploadStream: false,\n    promiseLibrary: db.s.promiseLibrary || Promise\n  };\n}\n\nutil.inherits(GridFSBucket, Emitter);\n/**\n * When the first call to openUploadStream is made, the upload stream will\n * check to see if it needs to create the proper indexes on the chunks and\n * files collections. This event is fired either when 1) it determines that\n * no index creation is necessary, 2) when it successfully creates the\n * necessary indexes.\n *\n * @event GridFSBucket#index\n * @type {Error}\n */\n\n/**\n * Returns a writable stream (GridFSBucketWriteStream) for writing\n * buffers to GridFS. The stream's 'id' property contains the resulting\n * file's id.\n * @method\n * @param {string} filename The value of the 'filename' key in the files doc\n * @param {object} [options] Optional settings.\n * @param {number} [options.chunkSizeBytes] Optional overwrite this bucket's chunkSizeBytes for this file\n * @param {object} [options.metadata] Optional object to store in the file document's `metadata` field\n * @param {string} [options.contentType] Optional string to store in the file document's `contentType` field\n * @param {array} [options.aliases] Optional array of strings to store in the file document's `aliases` field\n * @param {boolean} [options.disableMD5=false] If true, disables adding an md5 field to file data\n * @return {GridFSBucketWriteStream}\n */\n\nGridFSBucket.prototype.openUploadStream = function (filename, options) {\n  if (options) {\n    options = shallowClone(options);\n  } else {\n    options = {};\n  }\n\n  if (!options.chunkSizeBytes) {\n    options.chunkSizeBytes = this.s.options.chunkSizeBytes;\n  }\n\n  return new GridFSBucketWriteStream(this, filename, options);\n};\n/**\n * Returns a writable stream (GridFSBucketWriteStream) for writing\n * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\n * file's id.\n * @method\n * @param {string|number|object} id A custom id used to identify the file\n * @param {string} filename The value of the 'filename' key in the files doc\n * @param {object} [options] Optional settings.\n * @param {number} [options.chunkSizeBytes] Optional overwrite this bucket's chunkSizeBytes for this file\n * @param {object} [options.metadata] Optional object to store in the file document's `metadata` field\n * @param {string} [options.contentType] Optional string to store in the file document's `contentType` field\n * @param {array} [options.aliases] Optional array of strings to store in the file document's `aliases` field\n * @param {boolean} [options.disableMD5=false] If true, disables adding an md5 field to file data\n * @return {GridFSBucketWriteStream}\n */\n\n\nGridFSBucket.prototype.openUploadStreamWithId = function (id, filename, options) {\n  if (options) {\n    options = shallowClone(options);\n  } else {\n    options = {};\n  }\n\n  if (!options.chunkSizeBytes) {\n    options.chunkSizeBytes = this.s.options.chunkSizeBytes;\n  }\n\n  options.id = id;\n  return new GridFSBucketWriteStream(this, filename, options);\n};\n/**\n * Returns a readable stream (GridFSBucketReadStream) for streaming file\n * data from GridFS.\n * @method\n * @param {ObjectId} id The id of the file doc\n * @param {Object} [options] Optional settings.\n * @param {Number} [options.start] Optional 0-based offset in bytes to start streaming from\n * @param {Number} [options.end] Optional 0-based offset in bytes to stop streaming before\n * @return {GridFSBucketReadStream}\n */\n\n\nGridFSBucket.prototype.openDownloadStream = function (id, options) {\n  var filter = {\n    _id: id\n  };\n  options = {\n    start: options && options.start,\n    end: options && options.end\n  };\n  return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter, options);\n};\n/**\n * Deletes a file with the given id\n * @method\n * @param {ObjectId} id The id of the file doc\n * @param {GridFSBucket~errorCallback} [callback]\n */\n\n\nGridFSBucket.prototype.delete = function (id, callback) {\n  return executeLegacyOperation(this.s.db.s.topology, _delete, [this, id, callback], {\n    skipSessions: true\n  });\n};\n/**\n * @ignore\n */\n\n\nfunction _delete(_this, id, callback) {\n  _this.s._filesCollection.deleteOne({\n    _id: id\n  }, function (error, res) {\n    if (error) {\n      return callback(error);\n    }\n\n    _this.s._chunksCollection.deleteMany({\n      files_id: id\n    }, function (error) {\n      if (error) {\n        return callback(error);\n      } // Delete orphaned chunks before returning FileNotFound\n\n\n      if (!res.result.n) {\n        var errmsg = 'FileNotFound: no file with id ' + id + ' found';\n        return callback(new Error(errmsg));\n      }\n\n      callback();\n    });\n  });\n}\n/**\n * Convenience wrapper around find on the files collection\n * @method\n * @param {Object} filter\n * @param {Object} [options] Optional settings for cursor\n * @param {number} [options.batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find|find command documentation}.\n * @param {number} [options.limit] Optional limit for cursor\n * @param {number} [options.maxTimeMS] Optional maxTimeMS for cursor\n * @param {boolean} [options.noCursorTimeout] Optionally set cursor's `noCursorTimeout` flag\n * @param {number} [options.skip] Optional skip for cursor\n * @param {object} [options.sort] Optional sort for cursor\n * @return {Cursor}\n */\n\n\nGridFSBucket.prototype.find = function (filter, options) {\n  filter = filter || {};\n  options = options || {};\n\n  var cursor = this.s._filesCollection.find(filter);\n\n  if (options.batchSize != null) {\n    cursor.batchSize(options.batchSize);\n  }\n\n  if (options.limit != null) {\n    cursor.limit(options.limit);\n  }\n\n  if (options.maxTimeMS != null) {\n    cursor.maxTimeMS(options.maxTimeMS);\n  }\n\n  if (options.noCursorTimeout != null) {\n    cursor.addCursorFlag('noCursorTimeout', options.noCursorTimeout);\n  }\n\n  if (options.skip != null) {\n    cursor.skip(options.skip);\n  }\n\n  if (options.sort != null) {\n    cursor.sort(options.sort);\n  }\n\n  return cursor;\n};\n/**\n * Returns a readable stream (GridFSBucketReadStream) for streaming the\n * file with the given name from GridFS. If there are multiple files with\n * the same name, this will stream the most recent file with the given name\n * (as determined by the `uploadDate` field). You can set the `revision`\n * option to change this behavior.\n * @method\n * @param {String} filename The name of the file to stream\n * @param {Object} [options] Optional settings\n * @param {number} [options.revision=-1] The revision number relative to the oldest file with the given filename. 0 gets you the oldest file, 1 gets you the 2nd oldest, -1 gets you the newest.\n * @param {Number} [options.start] Optional 0-based offset in bytes to start streaming from\n * @param {Number} [options.end] Optional 0-based offset in bytes to stop streaming before\n * @return {GridFSBucketReadStream}\n */\n\n\nGridFSBucket.prototype.openDownloadStreamByName = function (filename, options) {\n  var sort = {\n    uploadDate: -1\n  };\n  var skip = null;\n\n  if (options && options.revision != null) {\n    if (options.revision >= 0) {\n      sort = {\n        uploadDate: 1\n      };\n      skip = options.revision;\n    } else {\n      skip = -options.revision - 1;\n    }\n  }\n\n  var filter = {\n    filename: filename\n  };\n  options = {\n    sort: sort,\n    skip: skip,\n    start: options && options.start,\n    end: options && options.end\n  };\n  return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter, options);\n};\n/**\n * Renames the file with the given _id to the given string\n * @method\n * @param {ObjectId} id the id of the file to rename\n * @param {String} filename new name for the file\n * @param {GridFSBucket~errorCallback} [callback]\n */\n\n\nGridFSBucket.prototype.rename = function (id, filename, callback) {\n  return executeLegacyOperation(this.s.db.s.topology, _rename, [this, id, filename, callback], {\n    skipSessions: true\n  });\n};\n/**\n * @ignore\n */\n\n\nfunction _rename(_this, id, filename, callback) {\n  var filter = {\n    _id: id\n  };\n  var update = {\n    $set: {\n      filename: filename\n    }\n  };\n\n  _this.s._filesCollection.updateOne(filter, update, function (error, res) {\n    if (error) {\n      return callback(error);\n    }\n\n    if (!res.result.n) {\n      return callback(toError('File with id ' + id + ' not found'));\n    }\n\n    callback();\n  });\n}\n/**\n * Removes this bucket's files collection, followed by its chunks collection.\n * @method\n * @param {GridFSBucket~errorCallback} [callback]\n */\n\n\nGridFSBucket.prototype.drop = function (callback) {\n  return executeLegacyOperation(this.s.db.s.topology, _drop, [this, callback], {\n    skipSessions: true\n  });\n};\n/**\n * Return the db logger\n * @method\n * @return {Logger} return the db logger\n * @ignore\n */\n\n\nGridFSBucket.prototype.getLogger = function () {\n  return this.s.db.s.logger;\n};\n/**\n * @ignore\n */\n\n\nfunction _drop(_this, callback) {\n  _this.s._filesCollection.drop(function (error) {\n    if (error) {\n      return callback(error);\n    }\n\n    _this.s._chunksCollection.drop(function (error) {\n      if (error) {\n        return callback(error);\n      }\n\n      return callback();\n    });\n  });\n}\n/**\n * Callback format for all GridFSBucket methods that can accept a callback.\n * @callback GridFSBucket~errorCallback\n * @param {MongoError|undefined} error If present, an error instance representing any errors that occurred\n * @param {*} result If present, a returned result for the method\n */","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/gridfs-stream/index.js"],"names":["Emitter","require","EventEmitter","GridFSBucketReadStream","GridFSBucketWriteStream","shallowClone","toError","util","executeLegacyOperation","DEFAULT_GRIDFS_BUCKET_OPTIONS","bucketName","chunkSizeBytes","module","exports","GridFSBucket","db","options","apply","setMaxListeners","keys","Object","i","length","s","_chunksCollection","collection","_filesCollection","checkedIndexes","calledOpenUploadStream","promiseLibrary","Promise","inherits","prototype","openUploadStream","filename","openUploadStreamWithId","id","openDownloadStream","filter","_id","start","end","readPreference","delete","callback","topology","_delete","skipSessions","_this","deleteOne","error","res","deleteMany","files_id","result","n","errmsg","Error","find","cursor","batchSize","limit","maxTimeMS","noCursorTimeout","addCursorFlag","skip","sort","openDownloadStreamByName","uploadDate","revision","rename","_rename","update","$set","updateOne","drop","_drop","getLogger","logger"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Emitter = require('events').EventEmitter;\nvar GridFSBucketReadStream = require('./download');\nvar GridFSBucketWriteStream = require('./upload');\nvar shallowClone = require('../utils').shallowClone;\nvar toError = require('../utils').toError;\nvar util = require('util');\nvar executeLegacyOperation = require('../utils').executeLegacyOperation;\n\nvar DEFAULT_GRIDFS_BUCKET_OPTIONS = {\n  bucketName: 'fs',\n  chunkSizeBytes: 255 * 1024\n};\n\nmodule.exports = GridFSBucket;\n\n/**\n * Constructor for a streaming GridFS interface\n * @class\n * @extends external:EventEmitter\n * @param {Db} db A db handle\n * @param {object} [options] Optional settings.\n * @param {string} [options.bucketName=\"fs\"] The 'files' and 'chunks' collections will be prefixed with the bucket name followed by a dot.\n * @param {number} [options.chunkSizeBytes=255 * 1024] Number of bytes stored in each chunk. Defaults to 255KB\n * @param {object} [options.writeConcern] Optional write concern to be passed to write operations, for instance `{ w: 1 }`\n * @param {object} [options.readPreference] Optional read preference to be passed to read operations\n * @fires GridFSBucketWriteStream#index\n */\n\nfunction GridFSBucket(db, options) {\n  Emitter.apply(this);\n  this.setMaxListeners(0);\n\n  if (options && typeof options === 'object') {\n    options = shallowClone(options);\n    var keys = Object.keys(DEFAULT_GRIDFS_BUCKET_OPTIONS);\n    for (var i = 0; i < keys.length; ++i) {\n      if (!options[keys[i]]) {\n        options[keys[i]] = DEFAULT_GRIDFS_BUCKET_OPTIONS[keys[i]];\n      }\n    }\n  } else {\n    options = DEFAULT_GRIDFS_BUCKET_OPTIONS;\n  }\n\n  this.s = {\n    db: db,\n    options: options,\n    _chunksCollection: db.collection(options.bucketName + '.chunks'),\n    _filesCollection: db.collection(options.bucketName + '.files'),\n    checkedIndexes: false,\n    calledOpenUploadStream: false,\n    promiseLibrary: db.s.promiseLibrary || Promise\n  };\n}\n\nutil.inherits(GridFSBucket, Emitter);\n\n/**\n * When the first call to openUploadStream is made, the upload stream will\n * check to see if it needs to create the proper indexes on the chunks and\n * files collections. This event is fired either when 1) it determines that\n * no index creation is necessary, 2) when it successfully creates the\n * necessary indexes.\n *\n * @event GridFSBucket#index\n * @type {Error}\n */\n\n/**\n * Returns a writable stream (GridFSBucketWriteStream) for writing\n * buffers to GridFS. The stream's 'id' property contains the resulting\n * file's id.\n * @method\n * @param {string} filename The value of the 'filename' key in the files doc\n * @param {object} [options] Optional settings.\n * @param {number} [options.chunkSizeBytes] Optional overwrite this bucket's chunkSizeBytes for this file\n * @param {object} [options.metadata] Optional object to store in the file document's `metadata` field\n * @param {string} [options.contentType] Optional string to store in the file document's `contentType` field\n * @param {array} [options.aliases] Optional array of strings to store in the file document's `aliases` field\n * @param {boolean} [options.disableMD5=false] If true, disables adding an md5 field to file data\n * @return {GridFSBucketWriteStream}\n */\n\nGridFSBucket.prototype.openUploadStream = function(filename, options) {\n  if (options) {\n    options = shallowClone(options);\n  } else {\n    options = {};\n  }\n  if (!options.chunkSizeBytes) {\n    options.chunkSizeBytes = this.s.options.chunkSizeBytes;\n  }\n  return new GridFSBucketWriteStream(this, filename, options);\n};\n\n/**\n * Returns a writable stream (GridFSBucketWriteStream) for writing\n * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\n * file's id.\n * @method\n * @param {string|number|object} id A custom id used to identify the file\n * @param {string} filename The value of the 'filename' key in the files doc\n * @param {object} [options] Optional settings.\n * @param {number} [options.chunkSizeBytes] Optional overwrite this bucket's chunkSizeBytes for this file\n * @param {object} [options.metadata] Optional object to store in the file document's `metadata` field\n * @param {string} [options.contentType] Optional string to store in the file document's `contentType` field\n * @param {array} [options.aliases] Optional array of strings to store in the file document's `aliases` field\n * @param {boolean} [options.disableMD5=false] If true, disables adding an md5 field to file data\n * @return {GridFSBucketWriteStream}\n */\n\nGridFSBucket.prototype.openUploadStreamWithId = function(id, filename, options) {\n  if (options) {\n    options = shallowClone(options);\n  } else {\n    options = {};\n  }\n\n  if (!options.chunkSizeBytes) {\n    options.chunkSizeBytes = this.s.options.chunkSizeBytes;\n  }\n\n  options.id = id;\n\n  return new GridFSBucketWriteStream(this, filename, options);\n};\n\n/**\n * Returns a readable stream (GridFSBucketReadStream) for streaming file\n * data from GridFS.\n * @method\n * @param {ObjectId} id The id of the file doc\n * @param {Object} [options] Optional settings.\n * @param {Number} [options.start] Optional 0-based offset in bytes to start streaming from\n * @param {Number} [options.end] Optional 0-based offset in bytes to stop streaming before\n * @return {GridFSBucketReadStream}\n */\n\nGridFSBucket.prototype.openDownloadStream = function(id, options) {\n  var filter = { _id: id };\n  options = {\n    start: options && options.start,\n    end: options && options.end\n  };\n\n  return new GridFSBucketReadStream(\n    this.s._chunksCollection,\n    this.s._filesCollection,\n    this.s.options.readPreference,\n    filter,\n    options\n  );\n};\n\n/**\n * Deletes a file with the given id\n * @method\n * @param {ObjectId} id The id of the file doc\n * @param {GridFSBucket~errorCallback} [callback]\n */\n\nGridFSBucket.prototype.delete = function(id, callback) {\n  return executeLegacyOperation(this.s.db.s.topology, _delete, [this, id, callback], {\n    skipSessions: true\n  });\n};\n\n/**\n * @ignore\n */\n\nfunction _delete(_this, id, callback) {\n  _this.s._filesCollection.deleteOne({ _id: id }, function(error, res) {\n    if (error) {\n      return callback(error);\n    }\n\n    _this.s._chunksCollection.deleteMany({ files_id: id }, function(error) {\n      if (error) {\n        return callback(error);\n      }\n\n      // Delete orphaned chunks before returning FileNotFound\n      if (!res.result.n) {\n        var errmsg = 'FileNotFound: no file with id ' + id + ' found';\n        return callback(new Error(errmsg));\n      }\n\n      callback();\n    });\n  });\n}\n\n/**\n * Convenience wrapper around find on the files collection\n * @method\n * @param {Object} filter\n * @param {Object} [options] Optional settings for cursor\n * @param {number} [options.batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find|find command documentation}.\n * @param {number} [options.limit] Optional limit for cursor\n * @param {number} [options.maxTimeMS] Optional maxTimeMS for cursor\n * @param {boolean} [options.noCursorTimeout] Optionally set cursor's `noCursorTimeout` flag\n * @param {number} [options.skip] Optional skip for cursor\n * @param {object} [options.sort] Optional sort for cursor\n * @return {Cursor}\n */\n\nGridFSBucket.prototype.find = function(filter, options) {\n  filter = filter || {};\n  options = options || {};\n\n  var cursor = this.s._filesCollection.find(filter);\n\n  if (options.batchSize != null) {\n    cursor.batchSize(options.batchSize);\n  }\n  if (options.limit != null) {\n    cursor.limit(options.limit);\n  }\n  if (options.maxTimeMS != null) {\n    cursor.maxTimeMS(options.maxTimeMS);\n  }\n  if (options.noCursorTimeout != null) {\n    cursor.addCursorFlag('noCursorTimeout', options.noCursorTimeout);\n  }\n  if (options.skip != null) {\n    cursor.skip(options.skip);\n  }\n  if (options.sort != null) {\n    cursor.sort(options.sort);\n  }\n\n  return cursor;\n};\n\n/**\n * Returns a readable stream (GridFSBucketReadStream) for streaming the\n * file with the given name from GridFS. If there are multiple files with\n * the same name, this will stream the most recent file with the given name\n * (as determined by the `uploadDate` field). You can set the `revision`\n * option to change this behavior.\n * @method\n * @param {String} filename The name of the file to stream\n * @param {Object} [options] Optional settings\n * @param {number} [options.revision=-1] The revision number relative to the oldest file with the given filename. 0 gets you the oldest file, 1 gets you the 2nd oldest, -1 gets you the newest.\n * @param {Number} [options.start] Optional 0-based offset in bytes to start streaming from\n * @param {Number} [options.end] Optional 0-based offset in bytes to stop streaming before\n * @return {GridFSBucketReadStream}\n */\n\nGridFSBucket.prototype.openDownloadStreamByName = function(filename, options) {\n  var sort = { uploadDate: -1 };\n  var skip = null;\n  if (options && options.revision != null) {\n    if (options.revision >= 0) {\n      sort = { uploadDate: 1 };\n      skip = options.revision;\n    } else {\n      skip = -options.revision - 1;\n    }\n  }\n\n  var filter = { filename: filename };\n  options = {\n    sort: sort,\n    skip: skip,\n    start: options && options.start,\n    end: options && options.end\n  };\n  return new GridFSBucketReadStream(\n    this.s._chunksCollection,\n    this.s._filesCollection,\n    this.s.options.readPreference,\n    filter,\n    options\n  );\n};\n\n/**\n * Renames the file with the given _id to the given string\n * @method\n * @param {ObjectId} id the id of the file to rename\n * @param {String} filename new name for the file\n * @param {GridFSBucket~errorCallback} [callback]\n */\n\nGridFSBucket.prototype.rename = function(id, filename, callback) {\n  return executeLegacyOperation(this.s.db.s.topology, _rename, [this, id, filename, callback], {\n    skipSessions: true\n  });\n};\n\n/**\n * @ignore\n */\n\nfunction _rename(_this, id, filename, callback) {\n  var filter = { _id: id };\n  var update = { $set: { filename: filename } };\n  _this.s._filesCollection.updateOne(filter, update, function(error, res) {\n    if (error) {\n      return callback(error);\n    }\n    if (!res.result.n) {\n      return callback(toError('File with id ' + id + ' not found'));\n    }\n    callback();\n  });\n}\n\n/**\n * Removes this bucket's files collection, followed by its chunks collection.\n * @method\n * @param {GridFSBucket~errorCallback} [callback]\n */\n\nGridFSBucket.prototype.drop = function(callback) {\n  return executeLegacyOperation(this.s.db.s.topology, _drop, [this, callback], {\n    skipSessions: true\n  });\n};\n\n/**\n * Return the db logger\n * @method\n * @return {Logger} return the db logger\n * @ignore\n */\nGridFSBucket.prototype.getLogger = function() {\n  return this.s.db.s.logger;\n};\n\n/**\n * @ignore\n */\n\nfunction _drop(_this, callback) {\n  _this.s._filesCollection.drop(function(error) {\n    if (error) {\n      return callback(error);\n    }\n    _this.s._chunksCollection.drop(function(error) {\n      if (error) {\n        return callback(error);\n      }\n\n      return callback();\n    });\n  });\n}\n\n/**\n * Callback format for all GridFSBucket methods that can accept a callback.\n * @callback GridFSBucket~errorCallback\n * @param {MongoError|undefined} error If present, an error instance representing any errors that occurred\n * @param {*} result If present, a returned result for the method\n */\n"]},"metadata":{},"sourceType":"script"}