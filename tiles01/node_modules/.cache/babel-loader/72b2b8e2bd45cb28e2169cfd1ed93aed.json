{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst crypto = require('crypto');\n\nconst debugOptions = require('./utils').debugOptions;\n\nconst parseHeader = require('../wireprotocol/shared').parseHeader;\n\nconst decompress = require('../wireprotocol/compression').decompress;\n\nconst Response = require('./commands').Response;\n\nconst BinMsg = require('./msg').BinMsg;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst MongoNetworkTimeoutError = require('../error').MongoNetworkTimeoutError;\n\nconst MongoError = require('../error').MongoError;\n\nconst Logger = require('./logger');\n\nconst OP_COMPRESSED = require('../wireprotocol/shared').opcodes.OP_COMPRESSED;\n\nconst OP_MSG = require('../wireprotocol/shared').opcodes.OP_MSG;\n\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst Query = require('./commands').Query;\n\nconst CommandResult = require('./command_result');\n\nlet _id = 0;\nconst DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;\nconst DEBUG_FIELDS = ['host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'socketTimeout', 'ssl', 'ca', 'crl', 'cert', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'checkServerIdentity'];\nlet connectionAccountingSpy = undefined;\nlet connectionAccounting = false;\nlet connections = {};\n/**\n * A class representing a single connection to a MongoDB server\n *\n * @fires Connection#connect\n * @fires Connection#close\n * @fires Connection#error\n * @fires Connection#timeout\n * @fires Connection#parseError\n * @fires Connection#message\n */\n\nclass Connection extends EventEmitter {\n  /**\n   * Creates a new Connection instance\n   *\n   * **NOTE**: Internal class, do not instantiate directly\n   *\n   * @param {Socket} socket The socket this connection wraps\n   * @param {Object} options Various settings\n   * @param {object} options.bson An implementation of bson serialize and deserialize\n   * @param {string} [options.host='localhost'] The host the socket is connected to\n   * @param {number} [options.port=27017] The port used for the socket connection\n   * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n   * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\n   * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n   * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n   * @param {boolean} [options.promoteLongs] Convert Long values from the db into Numbers if they fit into 53 bits\n   * @param {boolean} [options.promoteValues] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n   * @param {boolean} [options.promoteBuffers] Promotes Binary BSON values to native Node Buffers.\n   * @param {number} [options.maxBsonMessageSize=0x4000000] Largest possible size of a BSON message (for legacy purposes)\n   */\n  constructor(socket, options) {\n    super();\n    options = options || {};\n\n    if (!options.bson) {\n      throw new TypeError('must pass in valid bson parser');\n    }\n\n    this.id = _id++;\n    this.options = options;\n    this.logger = Logger('Connection', options);\n    this.bson = options.bson;\n    this.tag = options.tag;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;\n    this.port = options.port || 27017;\n    this.host = options.host || 'localhost';\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0; // These values are inspected directly in tests, but maybe not necessary to keep around\n\n    this.keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n    this.keepAliveInitialDelay = typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 120000;\n    this.connectionTimeout = typeof options.connectionTimeout === 'number' ? options.connectionTimeout : 30000;\n\n    if (this.keepAliveInitialDelay > this.socketTimeout) {\n      this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);\n    } // Debug information\n\n\n    if (this.logger.isDebug()) {\n      this.logger.debug(`creating connection ${this.id} with options [${JSON.stringify(debugOptions(DEBUG_FIELDS, options))}]`);\n    } // Response options\n\n\n    this.responseOptions = {\n      promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n      promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n      promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false\n    }; // Flushing\n\n    this.flushing = false;\n    this.queue = []; // Internal state\n\n    this.writeStream = null;\n    this.destroyed = false;\n    this.timedOut = false; // Create hash method\n\n    const hash = crypto.createHash('sha1');\n    hash.update(this.address);\n    this.hashedName = hash.digest('hex'); // All operations in flight on the connection\n\n    this.workItems = []; // setup socket\n\n    this.socket = socket;\n    this.socket.once('error', errorHandler(this));\n    this.socket.once('timeout', timeoutHandler(this));\n    this.socket.once('close', closeHandler(this));\n    this.socket.on('data', dataHandler(this));\n\n    if (connectionAccounting) {\n      addConnection(this.id, this);\n    }\n  }\n\n  setSocketTimeout(value) {\n    if (this.socket) {\n      this.socket.setTimeout(value);\n    }\n  }\n\n  resetSocketTimeout() {\n    if (this.socket) {\n      this.socket.setTimeout(this.socketTimeout);\n    }\n  }\n\n  static enableConnectionAccounting(spy) {\n    if (spy) {\n      connectionAccountingSpy = spy;\n    }\n\n    connectionAccounting = true;\n    connections = {};\n  }\n\n  static disableConnectionAccounting() {\n    connectionAccounting = false;\n    connectionAccountingSpy = undefined;\n  }\n\n  static connections() {\n    return connections;\n  }\n\n  get address() {\n    return `${this.host}:${this.port}`;\n  }\n  /**\n   * Unref this connection\n   * @method\n   * @return {boolean}\n   */\n\n\n  unref() {\n    if (this.socket == null) {\n      this.once('connect', () => this.socket.unref());\n      return;\n    }\n\n    this.socket.unref();\n  }\n  /**\n   * Flush all work Items on this connection\n   *\n   * @param {*} err The error to propagate to the flushed work items\n   */\n\n\n  flush(err) {\n    while (this.workItems.length > 0) {\n      const workItem = this.workItems.shift();\n\n      if (workItem.cb) {\n        workItem.cb(err);\n      }\n    }\n  }\n  /**\n   * Destroy connection\n   * @method\n   */\n\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({\n      force: false\n    }, options);\n\n    if (connectionAccounting) {\n      deleteConnection(this.id);\n    }\n\n    if (this.socket == null) {\n      this.destroyed = true;\n      return;\n    }\n\n    if (options.force || this.timedOut) {\n      this.socket.destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(null, null);\n      return;\n    }\n\n    this.socket.end(err => {\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(err, null);\n    });\n  }\n  /**\n   * Write to connection\n   * @method\n   * @param {Command} command Command to write out need to implement toBin and toBinUnified\n   */\n\n\n  write(buffer) {\n    // Debug Log\n    if (this.logger.isDebug()) {\n      if (!Array.isArray(buffer)) {\n        this.logger.debug(`writing buffer [${buffer.toString('hex')}] to ${this.address}`);\n      } else {\n        for (let i = 0; i < buffer.length; i++) this.logger.debug(`writing buffer [${buffer[i].toString('hex')}] to ${this.address}`);\n      }\n    } // Double check that the connection is not destroyed\n\n\n    if (this.socket.destroyed === false) {\n      // Write out the command\n      if (!Array.isArray(buffer)) {\n        this.socket.write(buffer, 'binary');\n        return true;\n      } // Iterate over all buffers and write them in order to the socket\n\n\n      for (let i = 0; i < buffer.length; i++) {\n        this.socket.write(buffer[i], 'binary');\n      }\n\n      return true;\n    } // Connection is destroyed return write failed\n\n\n    return false;\n  }\n  /**\n   * Return id of connection as a string\n   * @method\n   * @return {string}\n   */\n\n\n  toString() {\n    return '' + this.id;\n  }\n  /**\n   * Return json object of connection\n   * @method\n   * @return {object}\n   */\n\n\n  toJSON() {\n    return {\n      id: this.id,\n      host: this.host,\n      port: this.port\n    };\n  }\n  /**\n   * Is the connection connected\n   * @method\n   * @return {boolean}\n   */\n\n\n  isConnected() {\n    if (this.destroyed) return false;\n    return !this.socket.destroyed && this.socket.writable;\n  }\n  /**\n   * @ignore\n   */\n\n\n  command(ns, command, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    const conn = this;\n    const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n    const bson = conn.options.bson;\n    const query = new Query(bson, ns, command, {\n      numberToSkip: 0,\n      numberToReturn: 1\n    });\n\n    const noop = () => {};\n\n    function _callback(err, result) {\n      callback(err, result);\n      callback = noop;\n    }\n\n    function errorHandler(err) {\n      conn.resetSocketTimeout();\n      CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\n      conn.removeListener('message', messageHandler);\n\n      if (err == null) {\n        err = new MongoError(`runCommand failed for connection to '${conn.address}'`);\n      } // ignore all future errors\n\n\n      conn.on('error', noop);\n\n      _callback(err);\n    }\n\n    function messageHandler(msg) {\n      if (msg.responseTo !== query.requestId) {\n        return;\n      }\n\n      conn.resetSocketTimeout();\n      CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\n      conn.removeListener('message', messageHandler);\n      msg.parse({\n        promoteValues: true\n      });\n      const response = msg.documents[0];\n\n      if (response.ok === 0 || response.$err || response.errmsg || response.code) {\n        _callback(new MongoError(response));\n\n        return;\n      }\n\n      _callback(undefined, new CommandResult(response, this, msg));\n    }\n\n    conn.setSocketTimeout(socketTimeout);\n    CONNECTION_ERROR_EVENTS.forEach(eventName => conn.once(eventName, errorHandler));\n    conn.on('message', messageHandler);\n    conn.write(query.toBin());\n  }\n\n}\n\nconst CONNECTION_ERROR_EVENTS = ['error', 'close', 'timeout', 'parseError'];\n\nfunction deleteConnection(id) {\n  // console.log(\"=== deleted connection \" + id + \" :: \" + (connections[id] ? connections[id].port : ''))\n  delete connections[id];\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.deleteConnection(id);\n  }\n}\n\nfunction addConnection(id, connection) {\n  // console.log(\"=== added connection \" + id + \" :: \" + connection.port)\n  connections[id] = connection;\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.addConnection(id, connection);\n  }\n} //\n// Connection handlers\n\n\nfunction errorHandler(conn) {\n  return function (err) {\n    if (connectionAccounting) deleteConnection(conn.id); // Debug information\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`);\n    }\n\n    conn.emit('error', new MongoNetworkError(err), conn);\n  };\n}\n\nfunction timeoutHandler(conn) {\n  return function () {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);\n    }\n\n    conn.timedOut = true;\n    conn.emit('timeout', new MongoNetworkTimeoutError(`connection ${conn.id} to ${conn.address} timed out`, {\n      beforeHandshake: conn.ismaster == null\n    }), conn);\n  };\n}\n\nfunction closeHandler(conn) {\n  return function (hadError) {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);\n    }\n\n    if (!hadError) {\n      conn.emit('close', new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`), conn);\n    }\n  };\n} // Handle a message once it is received\n\n\nfunction processMessage(conn, message) {\n  const msgHeader = parseHeader(message);\n\n  if (msgHeader.opCode !== OP_COMPRESSED) {\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit('message', new ResponseConstructor(conn.bson, message, msgHeader, message.slice(MESSAGE_HEADER_SIZE), conn.responseOptions), conn);\n    return;\n  }\n\n  msgHeader.fromCompressed = true;\n  let index = MESSAGE_HEADER_SIZE;\n  msgHeader.opCode = message.readInt32LE(index);\n  index += 4;\n  msgHeader.length = message.readInt32LE(index);\n  index += 4;\n  const compressorID = message[index];\n  index++;\n  decompress(compressorID, message.slice(index), (err, decompressedMsgBody) => {\n    if (err) {\n      conn.emit('error', err);\n      return;\n    }\n\n    if (decompressedMsgBody.length !== msgHeader.length) {\n      conn.emit('error', new MongoError('Decompressing a compressed message from the server failed. The message is corrupt.'));\n      return;\n    }\n\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit('message', new ResponseConstructor(conn.bson, message, msgHeader, decompressedMsgBody, conn.responseOptions), conn);\n  });\n}\n\nfunction dataHandler(conn) {\n  return function (data) {\n    // Parse until we are done with the data\n    while (data.length > 0) {\n      // If we still have bytes to read on the current message\n      if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead; // Check if the current chunk contains the rest of the message\n\n        if (remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(conn.buffer, conn.bytesRead); // Adjust the number of bytes read so it point to the correct index in the buffer\n\n          conn.bytesRead = conn.bytesRead + data.length; // Reset state of buffer\n\n          data = Buffer.alloc(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead); // Slice the overflow into a new buffer that we will then re-parse\n\n          data = data.slice(remainingBytesToRead); // Emit current complete message\n\n          const emitBuffer = conn.buffer; // Reset state of buffer\n\n          conn.buffer = null;\n          conn.sizeOfMessage = 0;\n          conn.bytesRead = 0;\n          conn.stubBuffer = null;\n          processMessage(conn, emitBuffer);\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 4 bytes)\n        if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if (conn.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            const newData = Buffer.alloc(conn.stubBuffer.length + data.length);\n            conn.stubBuffer.copy(newData, 0);\n            data.copy(newData, conn.stubBuffer.length); // Reassign for parsing\n\n            data = newData; // Reset state of buffer\n\n            conn.buffer = null;\n            conn.sizeOfMessage = 0;\n            conn.bytesRead = 0;\n            conn.stubBuffer = null;\n          } else {\n            // Add the the bytes to the stub buffer\n            const newStubBuffer = Buffer.alloc(conn.stubBuffer.length + data.length); // Copy existing stub buffer\n\n            conn.stubBuffer.copy(newStubBuffer, 0); // Copy missing part of the data\n\n            data.copy(newStubBuffer, conn.stubBuffer.length); // Exit parsing loop\n\n            data = Buffer.alloc(0);\n          }\n        } else {\n          if (data.length > 4) {\n            // Retrieve the message size\n            const sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24; // If we have a negative sizeOfMessage emit error and return\n\n            if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: '',\n                bin: conn.buffer,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: conn.bytesRead,\n                  stubBuffer: conn.stubBuffer\n                }\n              }; // We got a parse Error fire it off then keep going\n\n              conn.emit('parseError', errorObject, conn);\n              return;\n            } // Ensure that the size of message is larger than 0 and less than the max allowed\n\n\n            if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage > data.length) {\n              conn.buffer = Buffer.alloc(sizeOfMessage); // Copy all the data into the buffer\n\n              data.copy(conn.buffer, 0); // Update bytes read\n\n              conn.bytesRead = data.length; // Update sizeOfMessage\n\n              conn.sizeOfMessage = sizeOfMessage; // Ensure stub buffer is null\n\n              conn.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0);\n            } else if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage === data.length) {\n              const emitBuffer = data; // Reset state of buffer\n\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0); // Emit the message\n\n              processMessage(conn, emitBuffer);\n            } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: null,\n                bin: data,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: 0,\n                  buffer: null,\n                  stubBuffer: null\n                }\n              }; // We got a parse Error fire it off then keep going\n\n              conn.emit('parseError', errorObject, conn); // Clear out the state of the parser\n\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0);\n            } else {\n              const emitBuffer = data.slice(0, sizeOfMessage); // Reset state of buffer\n\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null; // Copy rest of message\n\n              data = data.slice(sizeOfMessage); // Emit the message\n\n              processMessage(conn, emitBuffer);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            conn.stubBuffer = Buffer.alloc(data.length); // Copy the data to the stub buffer\n\n            data.copy(conn.stubBuffer, 0); // Exit parsing loop\n\n            data = Buffer.alloc(0);\n          }\n        }\n      }\n    }\n  };\n}\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Connection#connect\n * @type {Connection}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Connection#close\n * @type {Connection}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Connection#error\n * @type {Connection}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Connection#timeout\n * @type {Connection}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Connection#parseError\n * @type {Connection}\n */\n\n/**\n * An event emitted each time the connection receives a parsed message from the wire\n *\n * @event Connection#message\n * @type {Connection}\n */\n\n\nmodule.exports = Connection;","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/core/connection/connection.js"],"names":["EventEmitter","require","crypto","debugOptions","parseHeader","decompress","Response","BinMsg","MongoNetworkError","MongoNetworkTimeoutError","MongoError","Logger","OP_COMPRESSED","opcodes","OP_MSG","MESSAGE_HEADER_SIZE","Buffer","Query","CommandResult","_id","DEFAULT_MAX_BSON_MESSAGE_SIZE","DEBUG_FIELDS","connectionAccountingSpy","undefined","connectionAccounting","connections","Connection","constructor","socket","options","bson","TypeError","id","logger","tag","maxBsonMessageSize","port","host","socketTimeout","keepAlive","keepAliveInitialDelay","connectionTimeout","Math","round","isDebug","debug","JSON","stringify","responseOptions","promoteLongs","promoteValues","promoteBuffers","flushing","queue","writeStream","destroyed","timedOut","hash","createHash","update","address","hashedName","digest","workItems","once","errorHandler","timeoutHandler","closeHandler","on","dataHandler","addConnection","setSocketTimeout","value","setTimeout","resetSocketTimeout","enableConnectionAccounting","spy","disableConnectionAccounting","unref","flush","err","length","workItem","shift","cb","destroy","callback","Object","assign","force","deleteConnection","end","write","buffer","Array","isArray","toString","i","toJSON","isConnected","writable","command","ns","conn","query","numberToSkip","numberToReturn","noop","_callback","result","CONNECTION_ERROR_EVENTS","forEach","eventName","removeListener","messageHandler","msg","responseTo","requestId","parse","response","documents","ok","$err","errmsg","code","toBin","connection","emit","beforeHandshake","ismaster","hadError","processMessage","message","msgHeader","opCode","ResponseConstructor","slice","fromCompressed","index","readInt32LE","compressorID","decompressedMsgBody","data","bytesRead","sizeOfMessage","remainingBytesToRead","copy","alloc","emitBuffer","stubBuffer","newData","newStubBuffer","errorObject","trace","bin","parseState","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,YAAY,GAAGC,OAAO,CAAC,QAAD,CAAP,CAAkBD,YAAvC;;AACA,MAAME,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,SAAD,CAAP,CAAmBE,YAAxC;;AACA,MAAMC,WAAW,GAAGH,OAAO,CAAC,wBAAD,CAAP,CAAkCG,WAAtD;;AACA,MAAMC,UAAU,GAAGJ,OAAO,CAAC,6BAAD,CAAP,CAAuCI,UAA1D;;AACA,MAAMC,QAAQ,GAAGL,OAAO,CAAC,YAAD,CAAP,CAAsBK,QAAvC;;AACA,MAAMC,MAAM,GAAGN,OAAO,CAAC,OAAD,CAAP,CAAiBM,MAAhC;;AACA,MAAMC,iBAAiB,GAAGP,OAAO,CAAC,UAAD,CAAP,CAAoBO,iBAA9C;;AACA,MAAMC,wBAAwB,GAAGR,OAAO,CAAC,UAAD,CAAP,CAAoBQ,wBAArD;;AACA,MAAMC,UAAU,GAAGT,OAAO,CAAC,UAAD,CAAP,CAAoBS,UAAvC;;AACA,MAAMC,MAAM,GAAGV,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMW,aAAa,GAAGX,OAAO,CAAC,wBAAD,CAAP,CAAkCY,OAAlC,CAA0CD,aAAhE;;AACA,MAAME,MAAM,GAAGb,OAAO,CAAC,wBAAD,CAAP,CAAkCY,OAAlC,CAA0CC,MAAzD;;AACA,MAAMC,mBAAmB,GAAGd,OAAO,CAAC,wBAAD,CAAP,CAAkCc,mBAA9D;;AACA,MAAMC,MAAM,GAAGf,OAAO,CAAC,aAAD,CAAP,CAAuBe,MAAtC;;AACA,MAAMC,KAAK,GAAGhB,OAAO,CAAC,YAAD,CAAP,CAAsBgB,KAApC;;AACA,MAAMC,aAAa,GAAGjB,OAAO,CAAC,kBAAD,CAA7B;;AAEA,IAAIkB,GAAG,GAAG,CAAV;AAEA,MAAMC,6BAA6B,GAAG,OAAO,IAAP,GAAc,EAAd,GAAmB,CAAzD;AACA,MAAMC,YAAY,GAAG,CACnB,MADmB,EAEnB,MAFmB,EAGnB,MAHmB,EAInB,WAJmB,EAKnB,uBALmB,EAMnB,SANmB,EAOnB,mBAPmB,EAQnB,eARmB,EASnB,KATmB,EAUnB,IAVmB,EAWnB,KAXmB,EAYnB,MAZmB,EAanB,oBAbmB,EAcnB,cAdmB,EAenB,eAfmB,EAgBnB,gBAhBmB,EAiBnB,qBAjBmB,CAArB;AAoBA,IAAIC,uBAAuB,GAAGC,SAA9B;AACA,IAAIC,oBAAoB,GAAG,KAA3B;AACA,IAAIC,WAAW,GAAG,EAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,UAAN,SAAyB1B,YAAzB,CAAsC;AACpC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE2B,EAAAA,WAAW,CAACC,MAAD,EAASC,OAAT,EAAkB;AAC3B;AAEAA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AACA,QAAI,CAACA,OAAO,CAACC,IAAb,EAAmB;AACjB,YAAM,IAAIC,SAAJ,CAAc,gCAAd,CAAN;AACD;;AAED,SAAKC,EAAL,GAAUb,GAAG,EAAb;AACA,SAAKU,OAAL,GAAeA,OAAf;AACA,SAAKI,MAAL,GAActB,MAAM,CAAC,YAAD,EAAekB,OAAf,CAApB;AACA,SAAKC,IAAL,GAAYD,OAAO,CAACC,IAApB;AACA,SAAKI,GAAL,GAAWL,OAAO,CAACK,GAAnB;AACA,SAAKC,kBAAL,GAA0BN,OAAO,CAACM,kBAAR,IAA8Bf,6BAAxD;AAEA,SAAKgB,IAAL,GAAYP,OAAO,CAACO,IAAR,IAAgB,KAA5B;AACA,SAAKC,IAAL,GAAYR,OAAO,CAACQ,IAAR,IAAgB,WAA5B;AACA,SAAKC,aAAL,GAAqB,OAAOT,OAAO,CAACS,aAAf,KAAiC,QAAjC,GAA4CT,OAAO,CAACS,aAApD,GAAoE,CAAzF,CAjB2B,CAmB3B;;AACA,SAAKC,SAAL,GAAiB,OAAOV,OAAO,CAACU,SAAf,KAA6B,SAA7B,GAAyCV,OAAO,CAACU,SAAjD,GAA6D,IAA9E;AACA,SAAKC,qBAAL,GACE,OAAOX,OAAO,CAACW,qBAAf,KAAyC,QAAzC,GAAoDX,OAAO,CAACW,qBAA5D,GAAoF,MADtF;AAEA,SAAKC,iBAAL,GACE,OAAOZ,OAAO,CAACY,iBAAf,KAAqC,QAArC,GAAgDZ,OAAO,CAACY,iBAAxD,GAA4E,KAD9E;;AAEA,QAAI,KAAKD,qBAAL,GAA6B,KAAKF,aAAtC,EAAqD;AACnD,WAAKE,qBAAL,GAA6BE,IAAI,CAACC,KAAL,CAAW,KAAKL,aAAL,GAAqB,CAAhC,CAA7B;AACD,KA3B0B,CA6B3B;;;AACA,QAAI,KAAKL,MAAL,CAAYW,OAAZ,EAAJ,EAA2B;AACzB,WAAKX,MAAL,CAAYY,KAAZ,CACG,uBAAsB,KAAKb,EAAG,kBAAiBc,IAAI,CAACC,SAAL,CAC9C5C,YAAY,CAACkB,YAAD,EAAeQ,OAAf,CADkC,CAE9C,GAHJ;AAKD,KApC0B,CAsC3B;;;AACA,SAAKmB,eAAL,GAAuB;AACrBC,MAAAA,YAAY,EAAE,OAAOpB,OAAO,CAACoB,YAAf,KAAgC,SAAhC,GAA4CpB,OAAO,CAACoB,YAApD,GAAmE,IAD5D;AAErBC,MAAAA,aAAa,EAAE,OAAOrB,OAAO,CAACqB,aAAf,KAAiC,SAAjC,GAA6CrB,OAAO,CAACqB,aAArD,GAAqE,IAF/D;AAGrBC,MAAAA,cAAc,EAAE,OAAOtB,OAAO,CAACsB,cAAf,KAAkC,SAAlC,GAA8CtB,OAAO,CAACsB,cAAtD,GAAuE;AAHlE,KAAvB,CAvC2B,CA6C3B;;AACA,SAAKC,QAAL,GAAgB,KAAhB;AACA,SAAKC,KAAL,GAAa,EAAb,CA/C2B,CAiD3B;;AACA,SAAKC,WAAL,GAAmB,IAAnB;AACA,SAAKC,SAAL,GAAiB,KAAjB;AACA,SAAKC,QAAL,GAAgB,KAAhB,CApD2B,CAsD3B;;AACA,UAAMC,IAAI,GAAGvD,MAAM,CAACwD,UAAP,CAAkB,MAAlB,CAAb;AACAD,IAAAA,IAAI,CAACE,MAAL,CAAY,KAAKC,OAAjB;AACA,SAAKC,UAAL,GAAkBJ,IAAI,CAACK,MAAL,CAAY,KAAZ,CAAlB,CAzD2B,CA2D3B;;AACA,SAAKC,SAAL,GAAiB,EAAjB,CA5D2B,CA8D3B;;AACA,SAAKnC,MAAL,GAAcA,MAAd;AACA,SAAKA,MAAL,CAAYoC,IAAZ,CAAiB,OAAjB,EAA0BC,YAAY,CAAC,IAAD,CAAtC;AACA,SAAKrC,MAAL,CAAYoC,IAAZ,CAAiB,SAAjB,EAA4BE,cAAc,CAAC,IAAD,CAA1C;AACA,SAAKtC,MAAL,CAAYoC,IAAZ,CAAiB,OAAjB,EAA0BG,YAAY,CAAC,IAAD,CAAtC;AACA,SAAKvC,MAAL,CAAYwC,EAAZ,CAAe,MAAf,EAAuBC,WAAW,CAAC,IAAD,CAAlC;;AAEA,QAAI7C,oBAAJ,EAA0B;AACxB8C,MAAAA,aAAa,CAAC,KAAKtC,EAAN,EAAU,IAAV,CAAb;AACD;AACF;;AAEDuC,EAAAA,gBAAgB,CAACC,KAAD,EAAQ;AACtB,QAAI,KAAK5C,MAAT,EAAiB;AACf,WAAKA,MAAL,CAAY6C,UAAZ,CAAuBD,KAAvB;AACD;AACF;;AAEDE,EAAAA,kBAAkB,GAAG;AACnB,QAAI,KAAK9C,MAAT,EAAiB;AACf,WAAKA,MAAL,CAAY6C,UAAZ,CAAuB,KAAKnC,aAA5B;AACD;AACF;;AAED,SAAOqC,0BAAP,CAAkCC,GAAlC,EAAuC;AACrC,QAAIA,GAAJ,EAAS;AACPtD,MAAAA,uBAAuB,GAAGsD,GAA1B;AACD;;AAEDpD,IAAAA,oBAAoB,GAAG,IAAvB;AACAC,IAAAA,WAAW,GAAG,EAAd;AACD;;AAED,SAAOoD,2BAAP,GAAqC;AACnCrD,IAAAA,oBAAoB,GAAG,KAAvB;AACAF,IAAAA,uBAAuB,GAAGC,SAA1B;AACD;;AAED,SAAOE,WAAP,GAAqB;AACnB,WAAOA,WAAP;AACD;;AAED,MAAImC,OAAJ,GAAc;AACZ,WAAQ,GAAE,KAAKvB,IAAK,IAAG,KAAKD,IAAK,EAAjC;AACD;AAED;AACF;AACA;AACA;AACA;;;AACE0C,EAAAA,KAAK,GAAG;AACN,QAAI,KAAKlD,MAAL,IAAe,IAAnB,EAAyB;AACvB,WAAKoC,IAAL,CAAU,SAAV,EAAqB,MAAM,KAAKpC,MAAL,CAAYkD,KAAZ,EAA3B;AACA;AACD;;AAED,SAAKlD,MAAL,CAAYkD,KAAZ;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEC,EAAAA,KAAK,CAACC,GAAD,EAAM;AACT,WAAO,KAAKjB,SAAL,CAAekB,MAAf,GAAwB,CAA/B,EAAkC;AAChC,YAAMC,QAAQ,GAAG,KAAKnB,SAAL,CAAeoB,KAAf,EAAjB;;AACA,UAAID,QAAQ,CAACE,EAAb,EAAiB;AACfF,QAAAA,QAAQ,CAACE,EAAT,CAAYJ,GAAZ;AACD;AACF;AACF;AAED;AACF;AACA;AACA;;;AACEK,EAAAA,OAAO,CAACxD,OAAD,EAAUyD,QAAV,EAAoB;AACzB,QAAI,OAAOzD,OAAP,KAAmB,UAAvB,EAAmC;AACjCyD,MAAAA,QAAQ,GAAGzD,OAAX;AACAA,MAAAA,OAAO,GAAG,EAAV;AACD;;AAEDA,IAAAA,OAAO,GAAG0D,MAAM,CAACC,MAAP,CAAc;AAAEC,MAAAA,KAAK,EAAE;AAAT,KAAd,EAAgC5D,OAAhC,CAAV;;AAEA,QAAIL,oBAAJ,EAA0B;AACxBkE,MAAAA,gBAAgB,CAAC,KAAK1D,EAAN,CAAhB;AACD;;AAED,QAAI,KAAKJ,MAAL,IAAe,IAAnB,EAAyB;AACvB,WAAK2B,SAAL,GAAiB,IAAjB;AACA;AACD;;AAED,QAAI1B,OAAO,CAAC4D,KAAR,IAAiB,KAAKjC,QAA1B,EAAoC;AAClC,WAAK5B,MAAL,CAAYyD,OAAZ;AACA,WAAK9B,SAAL,GAAiB,IAAjB;AACA,UAAI,OAAO+B,QAAP,KAAoB,UAAxB,EAAoCA,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAR;AACpC;AACD;;AAED,SAAK1D,MAAL,CAAY+D,GAAZ,CAAgBX,GAAG,IAAI;AACrB,WAAKzB,SAAL,GAAiB,IAAjB;AACA,UAAI,OAAO+B,QAAP,KAAoB,UAAxB,EAAoCA,QAAQ,CAACN,GAAD,EAAM,IAAN,CAAR;AACrC,KAHD;AAID;AAED;AACF;AACA;AACA;AACA;;;AACEY,EAAAA,KAAK,CAACC,MAAD,EAAS;AACZ;AACA,QAAI,KAAK5D,MAAL,CAAYW,OAAZ,EAAJ,EAA2B;AACzB,UAAI,CAACkD,KAAK,CAACC,OAAN,CAAcF,MAAd,CAAL,EAA4B;AAC1B,aAAK5D,MAAL,CAAYY,KAAZ,CAAmB,mBAAkBgD,MAAM,CAACG,QAAP,CAAgB,KAAhB,CAAuB,QAAO,KAAKpC,OAAQ,EAAhF;AACD,OAFD,MAEO;AACL,aAAK,IAAIqC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAAM,CAACZ,MAA3B,EAAmCgB,CAAC,EAApC,EACE,KAAKhE,MAAL,CAAYY,KAAZ,CAAmB,mBAAkBgD,MAAM,CAACI,CAAD,CAAN,CAAUD,QAAV,CAAmB,KAAnB,CAA0B,QAAO,KAAKpC,OAAQ,EAAnF;AACH;AACF,KATW,CAWZ;;;AACA,QAAI,KAAKhC,MAAL,CAAY2B,SAAZ,KAA0B,KAA9B,EAAqC;AACnC;AACA,UAAI,CAACuC,KAAK,CAACC,OAAN,CAAcF,MAAd,CAAL,EAA4B;AAC1B,aAAKjE,MAAL,CAAYgE,KAAZ,CAAkBC,MAAlB,EAA0B,QAA1B;AACA,eAAO,IAAP;AACD,OALkC,CAOnC;;;AACA,WAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAAM,CAACZ,MAA3B,EAAmCgB,CAAC,EAApC,EAAwC;AACtC,aAAKrE,MAAL,CAAYgE,KAAZ,CAAkBC,MAAM,CAACI,CAAD,CAAxB,EAA6B,QAA7B;AACD;;AAED,aAAO,IAAP;AACD,KAzBW,CA2BZ;;;AACA,WAAO,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACED,EAAAA,QAAQ,GAAG;AACT,WAAO,KAAK,KAAKhE,EAAjB;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEkE,EAAAA,MAAM,GAAG;AACP,WAAO;AAAElE,MAAAA,EAAE,EAAE,KAAKA,EAAX;AAAeK,MAAAA,IAAI,EAAE,KAAKA,IAA1B;AAAgCD,MAAAA,IAAI,EAAE,KAAKA;AAA3C,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACE+D,EAAAA,WAAW,GAAG;AACZ,QAAI,KAAK5C,SAAT,EAAoB,OAAO,KAAP;AACpB,WAAO,CAAC,KAAK3B,MAAL,CAAY2B,SAAb,IAA0B,KAAK3B,MAAL,CAAYwE,QAA7C;AACD;AAED;AACF;AACA;;;AACEC,EAAAA,OAAO,CAACC,EAAD,EAAKD,OAAL,EAAcxE,OAAd,EAAuByD,QAAvB,EAAiC;AACtC,QAAI,OAAOzD,OAAP,KAAmB,UAAvB,EAAoCyD,QAAQ,GAAGzD,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;AAEnC,UAAM0E,IAAI,GAAG,IAAb;AACA,UAAMjE,aAAa,GAAG,OAAOT,OAAO,CAACS,aAAf,KAAiC,QAAjC,GAA4CT,OAAO,CAACS,aAApD,GAAoE,CAA1F;AACA,UAAMR,IAAI,GAAGyE,IAAI,CAAC1E,OAAL,CAAaC,IAA1B;AACA,UAAM0E,KAAK,GAAG,IAAIvF,KAAJ,CAAUa,IAAV,EAAgBwE,EAAhB,EAAoBD,OAApB,EAA6B;AACzCI,MAAAA,YAAY,EAAE,CAD2B;AAEzCC,MAAAA,cAAc,EAAE;AAFyB,KAA7B,CAAd;;AAKA,UAAMC,IAAI,GAAG,MAAM,CAAE,CAArB;;AACA,aAASC,SAAT,CAAmB5B,GAAnB,EAAwB6B,MAAxB,EAAgC;AAC9BvB,MAAAA,QAAQ,CAACN,GAAD,EAAM6B,MAAN,CAAR;AACAvB,MAAAA,QAAQ,GAAGqB,IAAX;AACD;;AAED,aAAS1C,YAAT,CAAsBe,GAAtB,EAA2B;AACzBuB,MAAAA,IAAI,CAAC7B,kBAAL;AACAoC,MAAAA,uBAAuB,CAACC,OAAxB,CAAgCC,SAAS,IAAIT,IAAI,CAACU,cAAL,CAAoBD,SAApB,EAA+B/C,YAA/B,CAA7C;AACAsC,MAAAA,IAAI,CAACU,cAAL,CAAoB,SAApB,EAA+BC,cAA/B;;AAEA,UAAIlC,GAAG,IAAI,IAAX,EAAiB;AACfA,QAAAA,GAAG,GAAG,IAAItE,UAAJ,CAAgB,wCAAuC6F,IAAI,CAAC3C,OAAQ,GAApE,CAAN;AACD,OAPwB,CASzB;;;AACA2C,MAAAA,IAAI,CAACnC,EAAL,CAAQ,OAAR,EAAiBuC,IAAjB;;AACAC,MAAAA,SAAS,CAAC5B,GAAD,CAAT;AACD;;AAED,aAASkC,cAAT,CAAwBC,GAAxB,EAA6B;AAC3B,UAAIA,GAAG,CAACC,UAAJ,KAAmBZ,KAAK,CAACa,SAA7B,EAAwC;AACtC;AACD;;AAEDd,MAAAA,IAAI,CAAC7B,kBAAL;AACAoC,MAAAA,uBAAuB,CAACC,OAAxB,CAAgCC,SAAS,IAAIT,IAAI,CAACU,cAAL,CAAoBD,SAApB,EAA+B/C,YAA/B,CAA7C;AACAsC,MAAAA,IAAI,CAACU,cAAL,CAAoB,SAApB,EAA+BC,cAA/B;AAEAC,MAAAA,GAAG,CAACG,KAAJ,CAAU;AAAEpE,QAAAA,aAAa,EAAE;AAAjB,OAAV;AAEA,YAAMqE,QAAQ,GAAGJ,GAAG,CAACK,SAAJ,CAAc,CAAd,CAAjB;;AACA,UAAID,QAAQ,CAACE,EAAT,KAAgB,CAAhB,IAAqBF,QAAQ,CAACG,IAA9B,IAAsCH,QAAQ,CAACI,MAA/C,IAAyDJ,QAAQ,CAACK,IAAtE,EAA4E;AAC1EhB,QAAAA,SAAS,CAAC,IAAIlG,UAAJ,CAAe6G,QAAf,CAAD,CAAT;;AACA;AACD;;AAEDX,MAAAA,SAAS,CAACrF,SAAD,EAAY,IAAIL,aAAJ,CAAkBqG,QAAlB,EAA4B,IAA5B,EAAkCJ,GAAlC,CAAZ,CAAT;AACD;;AAEDZ,IAAAA,IAAI,CAAChC,gBAAL,CAAsBjC,aAAtB;AACAwE,IAAAA,uBAAuB,CAACC,OAAxB,CAAgCC,SAAS,IAAIT,IAAI,CAACvC,IAAL,CAAUgD,SAAV,EAAqB/C,YAArB,CAA7C;AACAsC,IAAAA,IAAI,CAACnC,EAAL,CAAQ,SAAR,EAAmB8C,cAAnB;AACAX,IAAAA,IAAI,CAACX,KAAL,CAAWY,KAAK,CAACqB,KAAN,EAAX;AACD;;AAxTmC;;AA2TtC,MAAMf,uBAAuB,GAAG,CAAC,OAAD,EAAU,OAAV,EAAmB,SAAnB,EAA8B,YAA9B,CAAhC;;AAEA,SAASpB,gBAAT,CAA0B1D,EAA1B,EAA8B;AAC5B;AACA,SAAOP,WAAW,CAACO,EAAD,CAAlB;;AAEA,MAAIV,uBAAJ,EAA6B;AAC3BA,IAAAA,uBAAuB,CAACoE,gBAAxB,CAAyC1D,EAAzC;AACD;AACF;;AAED,SAASsC,aAAT,CAAuBtC,EAAvB,EAA2B8F,UAA3B,EAAuC;AACrC;AACArG,EAAAA,WAAW,CAACO,EAAD,CAAX,GAAkB8F,UAAlB;;AAEA,MAAIxG,uBAAJ,EAA6B;AAC3BA,IAAAA,uBAAuB,CAACgD,aAAxB,CAAsCtC,EAAtC,EAA0C8F,UAA1C;AACD;AACF,C,CAED;AACA;;;AACA,SAAS7D,YAAT,CAAsBsC,IAAtB,EAA4B;AAC1B,SAAO,UAASvB,GAAT,EAAc;AACnB,QAAIxD,oBAAJ,EAA0BkE,gBAAgB,CAACa,IAAI,CAACvE,EAAN,CAAhB,CADP,CAEnB;;AACA,QAAIuE,IAAI,CAACtE,MAAL,CAAYW,OAAZ,EAAJ,EAA2B;AACzB2D,MAAAA,IAAI,CAACtE,MAAL,CAAYY,KAAZ,CACG,cAAa0D,IAAI,CAACvE,EAAG,SAAQuE,IAAI,CAAC3C,OAAQ,uBAAsBd,IAAI,CAACC,SAAL,CAAeiC,GAAf,CAAoB,GADvF;AAGD;;AAEDuB,IAAAA,IAAI,CAACwB,IAAL,CAAU,OAAV,EAAmB,IAAIvH,iBAAJ,CAAsBwE,GAAtB,CAAnB,EAA+CuB,IAA/C;AACD,GAVD;AAWD;;AAED,SAASrC,cAAT,CAAwBqC,IAAxB,EAA8B;AAC5B,SAAO,YAAW;AAChB,QAAI/E,oBAAJ,EAA0BkE,gBAAgB,CAACa,IAAI,CAACvE,EAAN,CAAhB;;AAE1B,QAAIuE,IAAI,CAACtE,MAAL,CAAYW,OAAZ,EAAJ,EAA2B;AACzB2D,MAAAA,IAAI,CAACtE,MAAL,CAAYY,KAAZ,CAAmB,cAAa0D,IAAI,CAACvE,EAAG,SAAQuE,IAAI,CAAC3C,OAAQ,aAA7D;AACD;;AAED2C,IAAAA,IAAI,CAAC/C,QAAL,GAAgB,IAAhB;AACA+C,IAAAA,IAAI,CAACwB,IAAL,CACE,SADF,EAEE,IAAItH,wBAAJ,CAA8B,cAAa8F,IAAI,CAACvE,EAAG,OAAMuE,IAAI,CAAC3C,OAAQ,YAAtE,EAAmF;AACjFoE,MAAAA,eAAe,EAAEzB,IAAI,CAAC0B,QAAL,IAAiB;AAD+C,KAAnF,CAFF,EAKE1B,IALF;AAOD,GAfD;AAgBD;;AAED,SAASpC,YAAT,CAAsBoC,IAAtB,EAA4B;AAC1B,SAAO,UAAS2B,QAAT,EAAmB;AACxB,QAAI1G,oBAAJ,EAA0BkE,gBAAgB,CAACa,IAAI,CAACvE,EAAN,CAAhB;;AAE1B,QAAIuE,IAAI,CAACtE,MAAL,CAAYW,OAAZ,EAAJ,EAA2B;AACzB2D,MAAAA,IAAI,CAACtE,MAAL,CAAYY,KAAZ,CAAmB,cAAa0D,IAAI,CAACvE,EAAG,cAAauE,IAAI,CAAC3C,OAAQ,UAAlE;AACD;;AAED,QAAI,CAACsE,QAAL,EAAe;AACb3B,MAAAA,IAAI,CAACwB,IAAL,CACE,OADF,EAEE,IAAIvH,iBAAJ,CAAuB,cAAa+F,IAAI,CAACvE,EAAG,OAAMuE,IAAI,CAAC3C,OAAQ,SAA/D,CAFF,EAGE2C,IAHF;AAKD;AACF,GAdD;AAeD,C,CAED;;;AACA,SAAS4B,cAAT,CAAwB5B,IAAxB,EAA8B6B,OAA9B,EAAuC;AACrC,QAAMC,SAAS,GAAGjI,WAAW,CAACgI,OAAD,CAA7B;;AACA,MAAIC,SAAS,CAACC,MAAV,KAAqB1H,aAAzB,EAAwC;AACtC,UAAM2H,mBAAmB,GAAGF,SAAS,CAACC,MAAV,KAAqBxH,MAArB,GAA8BP,MAA9B,GAAuCD,QAAnE;AACAiG,IAAAA,IAAI,CAACwB,IAAL,CACE,SADF,EAEE,IAAIQ,mBAAJ,CACEhC,IAAI,CAACzE,IADP,EAEEsG,OAFF,EAGEC,SAHF,EAIED,OAAO,CAACI,KAAR,CAAczH,mBAAd,CAJF,EAKEwF,IAAI,CAACvD,eALP,CAFF,EASEuD,IATF;AAYA;AACD;;AAED8B,EAAAA,SAAS,CAACI,cAAV,GAA2B,IAA3B;AACA,MAAIC,KAAK,GAAG3H,mBAAZ;AACAsH,EAAAA,SAAS,CAACC,MAAV,GAAmBF,OAAO,CAACO,WAAR,CAAoBD,KAApB,CAAnB;AACAA,EAAAA,KAAK,IAAI,CAAT;AACAL,EAAAA,SAAS,CAACpD,MAAV,GAAmBmD,OAAO,CAACO,WAAR,CAAoBD,KAApB,CAAnB;AACAA,EAAAA,KAAK,IAAI,CAAT;AACA,QAAME,YAAY,GAAGR,OAAO,CAACM,KAAD,CAA5B;AACAA,EAAAA,KAAK;AAELrI,EAAAA,UAAU,CAACuI,YAAD,EAAeR,OAAO,CAACI,KAAR,CAAcE,KAAd,CAAf,EAAqC,CAAC1D,GAAD,EAAM6D,mBAAN,KAA8B;AAC3E,QAAI7D,GAAJ,EAAS;AACPuB,MAAAA,IAAI,CAACwB,IAAL,CAAU,OAAV,EAAmB/C,GAAnB;AACA;AACD;;AAED,QAAI6D,mBAAmB,CAAC5D,MAApB,KAA+BoD,SAAS,CAACpD,MAA7C,EAAqD;AACnDsB,MAAAA,IAAI,CAACwB,IAAL,CACE,OADF,EAEE,IAAIrH,UAAJ,CACE,oFADF,CAFF;AAOA;AACD;;AAED,UAAM6H,mBAAmB,GAAGF,SAAS,CAACC,MAAV,KAAqBxH,MAArB,GAA8BP,MAA9B,GAAuCD,QAAnE;AACAiG,IAAAA,IAAI,CAACwB,IAAL,CACE,SADF,EAEE,IAAIQ,mBAAJ,CACEhC,IAAI,CAACzE,IADP,EAEEsG,OAFF,EAGEC,SAHF,EAIEQ,mBAJF,EAKEtC,IAAI,CAACvD,eALP,CAFF,EASEuD,IATF;AAWD,GA7BS,CAAV;AA8BD;;AAED,SAASlC,WAAT,CAAqBkC,IAArB,EAA2B;AACzB,SAAO,UAASuC,IAAT,EAAe;AACpB;AACA,WAAOA,IAAI,CAAC7D,MAAL,GAAc,CAArB,EAAwB;AACtB;AACA,UAAIsB,IAAI,CAACwC,SAAL,GAAiB,CAAjB,IAAsBxC,IAAI,CAACyC,aAAL,GAAqB,CAA/C,EAAkD;AAChD;AACA,cAAMC,oBAAoB,GAAG1C,IAAI,CAACyC,aAAL,GAAqBzC,IAAI,CAACwC,SAAvD,CAFgD,CAGhD;;AACA,YAAIE,oBAAoB,GAAGH,IAAI,CAAC7D,MAAhC,EAAwC;AACtC;AACA6D,UAAAA,IAAI,CAACI,IAAL,CAAU3C,IAAI,CAACV,MAAf,EAAuBU,IAAI,CAACwC,SAA5B,EAFsC,CAGtC;;AACAxC,UAAAA,IAAI,CAACwC,SAAL,GAAiBxC,IAAI,CAACwC,SAAL,GAAiBD,IAAI,CAAC7D,MAAvC,CAJsC,CAMtC;;AACA6D,UAAAA,IAAI,GAAG9H,MAAM,CAACmI,KAAP,CAAa,CAAb,CAAP;AACD,SARD,MAQO;AACL;AACAL,UAAAA,IAAI,CAACI,IAAL,CAAU3C,IAAI,CAACV,MAAf,EAAuBU,IAAI,CAACwC,SAA5B,EAAuC,CAAvC,EAA0CE,oBAA1C,EAFK,CAGL;;AACAH,UAAAA,IAAI,GAAGA,IAAI,CAACN,KAAL,CAAWS,oBAAX,CAAP,CAJK,CAML;;AACA,gBAAMG,UAAU,GAAG7C,IAAI,CAACV,MAAxB,CAPK,CAQL;;AACAU,UAAAA,IAAI,CAACV,MAAL,GAAc,IAAd;AACAU,UAAAA,IAAI,CAACyC,aAAL,GAAqB,CAArB;AACAzC,UAAAA,IAAI,CAACwC,SAAL,GAAiB,CAAjB;AACAxC,UAAAA,IAAI,CAAC8C,UAAL,GAAkB,IAAlB;AAEAlB,UAAAA,cAAc,CAAC5B,IAAD,EAAO6C,UAAP,CAAd;AACD;AACF,OA5BD,MA4BO;AACL;AACA;AACA,YAAI7C,IAAI,CAAC8C,UAAL,IAAmB,IAAnB,IAA2B9C,IAAI,CAAC8C,UAAL,CAAgBpE,MAAhB,GAAyB,CAAxD,EAA2D;AACzD;AACA,cAAIsB,IAAI,CAAC8C,UAAL,CAAgBpE,MAAhB,GAAyB6D,IAAI,CAAC7D,MAA9B,GAAuC,CAA3C,EAA8C;AAC5C;AACA,kBAAMqE,OAAO,GAAGtI,MAAM,CAACmI,KAAP,CAAa5C,IAAI,CAAC8C,UAAL,CAAgBpE,MAAhB,GAAyB6D,IAAI,CAAC7D,MAA3C,CAAhB;AACAsB,YAAAA,IAAI,CAAC8C,UAAL,CAAgBH,IAAhB,CAAqBI,OAArB,EAA8B,CAA9B;AACAR,YAAAA,IAAI,CAACI,IAAL,CAAUI,OAAV,EAAmB/C,IAAI,CAAC8C,UAAL,CAAgBpE,MAAnC,EAJ4C,CAK5C;;AACA6D,YAAAA,IAAI,GAAGQ,OAAP,CAN4C,CAQ5C;;AACA/C,YAAAA,IAAI,CAACV,MAAL,GAAc,IAAd;AACAU,YAAAA,IAAI,CAACyC,aAAL,GAAqB,CAArB;AACAzC,YAAAA,IAAI,CAACwC,SAAL,GAAiB,CAAjB;AACAxC,YAAAA,IAAI,CAAC8C,UAAL,GAAkB,IAAlB;AACD,WAbD,MAaO;AACL;AACA,kBAAME,aAAa,GAAGvI,MAAM,CAACmI,KAAP,CAAa5C,IAAI,CAAC8C,UAAL,CAAgBpE,MAAhB,GAAyB6D,IAAI,CAAC7D,MAA3C,CAAtB,CAFK,CAGL;;AACAsB,YAAAA,IAAI,CAAC8C,UAAL,CAAgBH,IAAhB,CAAqBK,aAArB,EAAoC,CAApC,EAJK,CAKL;;AACAT,YAAAA,IAAI,CAACI,IAAL,CAAUK,aAAV,EAAyBhD,IAAI,CAAC8C,UAAL,CAAgBpE,MAAzC,EANK,CAOL;;AACA6D,YAAAA,IAAI,GAAG9H,MAAM,CAACmI,KAAP,CAAa,CAAb,CAAP;AACD;AACF,SAzBD,MAyBO;AACL,cAAIL,IAAI,CAAC7D,MAAL,GAAc,CAAlB,EAAqB;AACnB;AACA,kBAAM+D,aAAa,GAAGF,IAAI,CAAC,CAAD,CAAJ,GAAWA,IAAI,CAAC,CAAD,CAAJ,IAAW,CAAtB,GAA4BA,IAAI,CAAC,CAAD,CAAJ,IAAW,EAAvC,GAA8CA,IAAI,CAAC,CAAD,CAAJ,IAAW,EAA/E,CAFmB,CAGnB;;AACA,gBAAIE,aAAa,GAAG,CAAhB,IAAqBA,aAAa,GAAGzC,IAAI,CAACpE,kBAA9C,EAAkE;AAChE,oBAAMqH,WAAW,GAAG;AAClBxE,gBAAAA,GAAG,EAAE,eADa;AAElByE,gBAAAA,KAAK,EAAE,EAFW;AAGlBC,gBAAAA,GAAG,EAAEnD,IAAI,CAACV,MAHQ;AAIlB8D,gBAAAA,UAAU,EAAE;AACVX,kBAAAA,aAAa,EAAEA,aADL;AAEVD,kBAAAA,SAAS,EAAExC,IAAI,CAACwC,SAFN;AAGVM,kBAAAA,UAAU,EAAE9C,IAAI,CAAC8C;AAHP;AAJM,eAApB,CADgE,CAWhE;;AACA9C,cAAAA,IAAI,CAACwB,IAAL,CAAU,YAAV,EAAwByB,WAAxB,EAAqCjD,IAArC;AACA;AACD,aAlBkB,CAoBnB;;;AACA,gBACEyC,aAAa,GAAG,CAAhB,IACAA,aAAa,GAAGzC,IAAI,CAACpE,kBADrB,IAEA6G,aAAa,GAAGF,IAAI,CAAC7D,MAHvB,EAIE;AACAsB,cAAAA,IAAI,CAACV,MAAL,GAAc7E,MAAM,CAACmI,KAAP,CAAaH,aAAb,CAAd,CADA,CAEA;;AACAF,cAAAA,IAAI,CAACI,IAAL,CAAU3C,IAAI,CAACV,MAAf,EAAuB,CAAvB,EAHA,CAIA;;AACAU,cAAAA,IAAI,CAACwC,SAAL,GAAiBD,IAAI,CAAC7D,MAAtB,CALA,CAMA;;AACAsB,cAAAA,IAAI,CAACyC,aAAL,GAAqBA,aAArB,CAPA,CAQA;;AACAzC,cAAAA,IAAI,CAAC8C,UAAL,GAAkB,IAAlB,CATA,CAUA;;AACAP,cAAAA,IAAI,GAAG9H,MAAM,CAACmI,KAAP,CAAa,CAAb,CAAP;AACD,aAhBD,MAgBO,IACLH,aAAa,GAAG,CAAhB,IACAA,aAAa,GAAGzC,IAAI,CAACpE,kBADrB,IAEA6G,aAAa,KAAKF,IAAI,CAAC7D,MAHlB,EAIL;AACA,oBAAMmE,UAAU,GAAGN,IAAnB,CADA,CAEA;;AACAvC,cAAAA,IAAI,CAACV,MAAL,GAAc,IAAd;AACAU,cAAAA,IAAI,CAACyC,aAAL,GAAqB,CAArB;AACAzC,cAAAA,IAAI,CAACwC,SAAL,GAAiB,CAAjB;AACAxC,cAAAA,IAAI,CAAC8C,UAAL,GAAkB,IAAlB,CANA,CAOA;;AACAP,cAAAA,IAAI,GAAG9H,MAAM,CAACmI,KAAP,CAAa,CAAb,CAAP,CARA,CASA;;AACAhB,cAAAA,cAAc,CAAC5B,IAAD,EAAO6C,UAAP,CAAd;AACD,aAfM,MAeA,IAAIJ,aAAa,IAAI,CAAjB,IAAsBA,aAAa,GAAGzC,IAAI,CAACpE,kBAA/C,EAAmE;AACxE,oBAAMqH,WAAW,GAAG;AAClBxE,gBAAAA,GAAG,EAAE,eADa;AAElByE,gBAAAA,KAAK,EAAE,IAFW;AAGlBC,gBAAAA,GAAG,EAAEZ,IAHa;AAIlBa,gBAAAA,UAAU,EAAE;AACVX,kBAAAA,aAAa,EAAEA,aADL;AAEVD,kBAAAA,SAAS,EAAE,CAFD;AAGVlD,kBAAAA,MAAM,EAAE,IAHE;AAIVwD,kBAAAA,UAAU,EAAE;AAJF;AAJM,eAApB,CADwE,CAYxE;;AACA9C,cAAAA,IAAI,CAACwB,IAAL,CAAU,YAAV,EAAwByB,WAAxB,EAAqCjD,IAArC,EAbwE,CAexE;;AACAA,cAAAA,IAAI,CAACV,MAAL,GAAc,IAAd;AACAU,cAAAA,IAAI,CAACyC,aAAL,GAAqB,CAArB;AACAzC,cAAAA,IAAI,CAACwC,SAAL,GAAiB,CAAjB;AACAxC,cAAAA,IAAI,CAAC8C,UAAL,GAAkB,IAAlB,CAnBwE,CAoBxE;;AACAP,cAAAA,IAAI,GAAG9H,MAAM,CAACmI,KAAP,CAAa,CAAb,CAAP;AACD,aAtBM,MAsBA;AACL,oBAAMC,UAAU,GAAGN,IAAI,CAACN,KAAL,CAAW,CAAX,EAAcQ,aAAd,CAAnB,CADK,CAEL;;AACAzC,cAAAA,IAAI,CAACV,MAAL,GAAc,IAAd;AACAU,cAAAA,IAAI,CAACyC,aAAL,GAAqB,CAArB;AACAzC,cAAAA,IAAI,CAACwC,SAAL,GAAiB,CAAjB;AACAxC,cAAAA,IAAI,CAAC8C,UAAL,GAAkB,IAAlB,CANK,CAOL;;AACAP,cAAAA,IAAI,GAAGA,IAAI,CAACN,KAAL,CAAWQ,aAAX,CAAP,CARK,CASL;;AACAb,cAAAA,cAAc,CAAC5B,IAAD,EAAO6C,UAAP,CAAd;AACD;AACF,WAtFD,MAsFO;AACL;AACA7C,YAAAA,IAAI,CAAC8C,UAAL,GAAkBrI,MAAM,CAACmI,KAAP,CAAaL,IAAI,CAAC7D,MAAlB,CAAlB,CAFK,CAGL;;AACA6D,YAAAA,IAAI,CAACI,IAAL,CAAU3C,IAAI,CAAC8C,UAAf,EAA2B,CAA3B,EAJK,CAKL;;AACAP,YAAAA,IAAI,GAAG9H,MAAM,CAACmI,KAAP,CAAa,CAAb,CAAP;AACD;AACF;AACF;AACF;AACF,GA9JD;AA+JD;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEAS,MAAM,CAACC,OAAP,GAAiBnI,UAAjB","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\nconst crypto = require('crypto');\nconst debugOptions = require('./utils').debugOptions;\nconst parseHeader = require('../wireprotocol/shared').parseHeader;\nconst decompress = require('../wireprotocol/compression').decompress;\nconst Response = require('./commands').Response;\nconst BinMsg = require('./msg').BinMsg;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst MongoNetworkTimeoutError = require('../error').MongoNetworkTimeoutError;\nconst MongoError = require('../error').MongoError;\nconst Logger = require('./logger');\nconst OP_COMPRESSED = require('../wireprotocol/shared').opcodes.OP_COMPRESSED;\nconst OP_MSG = require('../wireprotocol/shared').opcodes.OP_MSG;\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\nconst Buffer = require('safe-buffer').Buffer;\nconst Query = require('./commands').Query;\nconst CommandResult = require('./command_result');\n\nlet _id = 0;\n\nconst DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;\nconst DEBUG_FIELDS = [\n  'host',\n  'port',\n  'size',\n  'keepAlive',\n  'keepAliveInitialDelay',\n  'noDelay',\n  'connectionTimeout',\n  'socketTimeout',\n  'ssl',\n  'ca',\n  'crl',\n  'cert',\n  'rejectUnauthorized',\n  'promoteLongs',\n  'promoteValues',\n  'promoteBuffers',\n  'checkServerIdentity'\n];\n\nlet connectionAccountingSpy = undefined;\nlet connectionAccounting = false;\nlet connections = {};\n\n/**\n * A class representing a single connection to a MongoDB server\n *\n * @fires Connection#connect\n * @fires Connection#close\n * @fires Connection#error\n * @fires Connection#timeout\n * @fires Connection#parseError\n * @fires Connection#message\n */\nclass Connection extends EventEmitter {\n  /**\n   * Creates a new Connection instance\n   *\n   * **NOTE**: Internal class, do not instantiate directly\n   *\n   * @param {Socket} socket The socket this connection wraps\n   * @param {Object} options Various settings\n   * @param {object} options.bson An implementation of bson serialize and deserialize\n   * @param {string} [options.host='localhost'] The host the socket is connected to\n   * @param {number} [options.port=27017] The port used for the socket connection\n   * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n   * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\n   * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n   * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n   * @param {boolean} [options.promoteLongs] Convert Long values from the db into Numbers if they fit into 53 bits\n   * @param {boolean} [options.promoteValues] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n   * @param {boolean} [options.promoteBuffers] Promotes Binary BSON values to native Node Buffers.\n   * @param {number} [options.maxBsonMessageSize=0x4000000] Largest possible size of a BSON message (for legacy purposes)\n   */\n  constructor(socket, options) {\n    super();\n\n    options = options || {};\n    if (!options.bson) {\n      throw new TypeError('must pass in valid bson parser');\n    }\n\n    this.id = _id++;\n    this.options = options;\n    this.logger = Logger('Connection', options);\n    this.bson = options.bson;\n    this.tag = options.tag;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;\n\n    this.port = options.port || 27017;\n    this.host = options.host || 'localhost';\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n\n    // These values are inspected directly in tests, but maybe not necessary to keep around\n    this.keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n    this.keepAliveInitialDelay =\n      typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 120000;\n    this.connectionTimeout =\n      typeof options.connectionTimeout === 'number' ? options.connectionTimeout : 30000;\n    if (this.keepAliveInitialDelay > this.socketTimeout) {\n      this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);\n    }\n\n    // Debug information\n    if (this.logger.isDebug()) {\n      this.logger.debug(\n        `creating connection ${this.id} with options [${JSON.stringify(\n          debugOptions(DEBUG_FIELDS, options)\n        )}]`\n      );\n    }\n\n    // Response options\n    this.responseOptions = {\n      promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n      promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n      promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false\n    };\n\n    // Flushing\n    this.flushing = false;\n    this.queue = [];\n\n    // Internal state\n    this.writeStream = null;\n    this.destroyed = false;\n    this.timedOut = false;\n\n    // Create hash method\n    const hash = crypto.createHash('sha1');\n    hash.update(this.address);\n    this.hashedName = hash.digest('hex');\n\n    // All operations in flight on the connection\n    this.workItems = [];\n\n    // setup socket\n    this.socket = socket;\n    this.socket.once('error', errorHandler(this));\n    this.socket.once('timeout', timeoutHandler(this));\n    this.socket.once('close', closeHandler(this));\n    this.socket.on('data', dataHandler(this));\n\n    if (connectionAccounting) {\n      addConnection(this.id, this);\n    }\n  }\n\n  setSocketTimeout(value) {\n    if (this.socket) {\n      this.socket.setTimeout(value);\n    }\n  }\n\n  resetSocketTimeout() {\n    if (this.socket) {\n      this.socket.setTimeout(this.socketTimeout);\n    }\n  }\n\n  static enableConnectionAccounting(spy) {\n    if (spy) {\n      connectionAccountingSpy = spy;\n    }\n\n    connectionAccounting = true;\n    connections = {};\n  }\n\n  static disableConnectionAccounting() {\n    connectionAccounting = false;\n    connectionAccountingSpy = undefined;\n  }\n\n  static connections() {\n    return connections;\n  }\n\n  get address() {\n    return `${this.host}:${this.port}`;\n  }\n\n  /**\n   * Unref this connection\n   * @method\n   * @return {boolean}\n   */\n  unref() {\n    if (this.socket == null) {\n      this.once('connect', () => this.socket.unref());\n      return;\n    }\n\n    this.socket.unref();\n  }\n\n  /**\n   * Flush all work Items on this connection\n   *\n   * @param {*} err The error to propagate to the flushed work items\n   */\n  flush(err) {\n    while (this.workItems.length > 0) {\n      const workItem = this.workItems.shift();\n      if (workItem.cb) {\n        workItem.cb(err);\n      }\n    }\n  }\n\n  /**\n   * Destroy connection\n   * @method\n   */\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({ force: false }, options);\n\n    if (connectionAccounting) {\n      deleteConnection(this.id);\n    }\n\n    if (this.socket == null) {\n      this.destroyed = true;\n      return;\n    }\n\n    if (options.force || this.timedOut) {\n      this.socket.destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(null, null);\n      return;\n    }\n\n    this.socket.end(err => {\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(err, null);\n    });\n  }\n\n  /**\n   * Write to connection\n   * @method\n   * @param {Command} command Command to write out need to implement toBin and toBinUnified\n   */\n  write(buffer) {\n    // Debug Log\n    if (this.logger.isDebug()) {\n      if (!Array.isArray(buffer)) {\n        this.logger.debug(`writing buffer [${buffer.toString('hex')}] to ${this.address}`);\n      } else {\n        for (let i = 0; i < buffer.length; i++)\n          this.logger.debug(`writing buffer [${buffer[i].toString('hex')}] to ${this.address}`);\n      }\n    }\n\n    // Double check that the connection is not destroyed\n    if (this.socket.destroyed === false) {\n      // Write out the command\n      if (!Array.isArray(buffer)) {\n        this.socket.write(buffer, 'binary');\n        return true;\n      }\n\n      // Iterate over all buffers and write them in order to the socket\n      for (let i = 0; i < buffer.length; i++) {\n        this.socket.write(buffer[i], 'binary');\n      }\n\n      return true;\n    }\n\n    // Connection is destroyed return write failed\n    return false;\n  }\n\n  /**\n   * Return id of connection as a string\n   * @method\n   * @return {string}\n   */\n  toString() {\n    return '' + this.id;\n  }\n\n  /**\n   * Return json object of connection\n   * @method\n   * @return {object}\n   */\n  toJSON() {\n    return { id: this.id, host: this.host, port: this.port };\n  }\n\n  /**\n   * Is the connection connected\n   * @method\n   * @return {boolean}\n   */\n  isConnected() {\n    if (this.destroyed) return false;\n    return !this.socket.destroyed && this.socket.writable;\n  }\n\n  /**\n   * @ignore\n   */\n  command(ns, command, options, callback) {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    const conn = this;\n    const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n    const bson = conn.options.bson;\n    const query = new Query(bson, ns, command, {\n      numberToSkip: 0,\n      numberToReturn: 1\n    });\n\n    const noop = () => {};\n    function _callback(err, result) {\n      callback(err, result);\n      callback = noop;\n    }\n\n    function errorHandler(err) {\n      conn.resetSocketTimeout();\n      CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\n      conn.removeListener('message', messageHandler);\n\n      if (err == null) {\n        err = new MongoError(`runCommand failed for connection to '${conn.address}'`);\n      }\n\n      // ignore all future errors\n      conn.on('error', noop);\n      _callback(err);\n    }\n\n    function messageHandler(msg) {\n      if (msg.responseTo !== query.requestId) {\n        return;\n      }\n\n      conn.resetSocketTimeout();\n      CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\n      conn.removeListener('message', messageHandler);\n\n      msg.parse({ promoteValues: true });\n\n      const response = msg.documents[0];\n      if (response.ok === 0 || response.$err || response.errmsg || response.code) {\n        _callback(new MongoError(response));\n        return;\n      }\n\n      _callback(undefined, new CommandResult(response, this, msg));\n    }\n\n    conn.setSocketTimeout(socketTimeout);\n    CONNECTION_ERROR_EVENTS.forEach(eventName => conn.once(eventName, errorHandler));\n    conn.on('message', messageHandler);\n    conn.write(query.toBin());\n  }\n}\n\nconst CONNECTION_ERROR_EVENTS = ['error', 'close', 'timeout', 'parseError'];\n\nfunction deleteConnection(id) {\n  // console.log(\"=== deleted connection \" + id + \" :: \" + (connections[id] ? connections[id].port : ''))\n  delete connections[id];\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.deleteConnection(id);\n  }\n}\n\nfunction addConnection(id, connection) {\n  // console.log(\"=== added connection \" + id + \" :: \" + connection.port)\n  connections[id] = connection;\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.addConnection(id, connection);\n  }\n}\n\n//\n// Connection handlers\nfunction errorHandler(conn) {\n  return function(err) {\n    if (connectionAccounting) deleteConnection(conn.id);\n    // Debug information\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(\n        `connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`\n      );\n    }\n\n    conn.emit('error', new MongoNetworkError(err), conn);\n  };\n}\n\nfunction timeoutHandler(conn) {\n  return function() {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);\n    }\n\n    conn.timedOut = true;\n    conn.emit(\n      'timeout',\n      new MongoNetworkTimeoutError(`connection ${conn.id} to ${conn.address} timed out`, {\n        beforeHandshake: conn.ismaster == null\n      }),\n      conn\n    );\n  };\n}\n\nfunction closeHandler(conn) {\n  return function(hadError) {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);\n    }\n\n    if (!hadError) {\n      conn.emit(\n        'close',\n        new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`),\n        conn\n      );\n    }\n  };\n}\n\n// Handle a message once it is received\nfunction processMessage(conn, message) {\n  const msgHeader = parseHeader(message);\n  if (msgHeader.opCode !== OP_COMPRESSED) {\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit(\n      'message',\n      new ResponseConstructor(\n        conn.bson,\n        message,\n        msgHeader,\n        message.slice(MESSAGE_HEADER_SIZE),\n        conn.responseOptions\n      ),\n      conn\n    );\n\n    return;\n  }\n\n  msgHeader.fromCompressed = true;\n  let index = MESSAGE_HEADER_SIZE;\n  msgHeader.opCode = message.readInt32LE(index);\n  index += 4;\n  msgHeader.length = message.readInt32LE(index);\n  index += 4;\n  const compressorID = message[index];\n  index++;\n\n  decompress(compressorID, message.slice(index), (err, decompressedMsgBody) => {\n    if (err) {\n      conn.emit('error', err);\n      return;\n    }\n\n    if (decompressedMsgBody.length !== msgHeader.length) {\n      conn.emit(\n        'error',\n        new MongoError(\n          'Decompressing a compressed message from the server failed. The message is corrupt.'\n        )\n      );\n\n      return;\n    }\n\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit(\n      'message',\n      new ResponseConstructor(\n        conn.bson,\n        message,\n        msgHeader,\n        decompressedMsgBody,\n        conn.responseOptions\n      ),\n      conn\n    );\n  });\n}\n\nfunction dataHandler(conn) {\n  return function(data) {\n    // Parse until we are done with the data\n    while (data.length > 0) {\n      // If we still have bytes to read on the current message\n      if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead;\n        // Check if the current chunk contains the rest of the message\n        if (remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(conn.buffer, conn.bytesRead);\n          // Adjust the number of bytes read so it point to the correct index in the buffer\n          conn.bytesRead = conn.bytesRead + data.length;\n\n          // Reset state of buffer\n          data = Buffer.alloc(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead);\n          // Slice the overflow into a new buffer that we will then re-parse\n          data = data.slice(remainingBytesToRead);\n\n          // Emit current complete message\n          const emitBuffer = conn.buffer;\n          // Reset state of buffer\n          conn.buffer = null;\n          conn.sizeOfMessage = 0;\n          conn.bytesRead = 0;\n          conn.stubBuffer = null;\n\n          processMessage(conn, emitBuffer);\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 4 bytes)\n        if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if (conn.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            const newData = Buffer.alloc(conn.stubBuffer.length + data.length);\n            conn.stubBuffer.copy(newData, 0);\n            data.copy(newData, conn.stubBuffer.length);\n            // Reassign for parsing\n            data = newData;\n\n            // Reset state of buffer\n            conn.buffer = null;\n            conn.sizeOfMessage = 0;\n            conn.bytesRead = 0;\n            conn.stubBuffer = null;\n          } else {\n            // Add the the bytes to the stub buffer\n            const newStubBuffer = Buffer.alloc(conn.stubBuffer.length + data.length);\n            // Copy existing stub buffer\n            conn.stubBuffer.copy(newStubBuffer, 0);\n            // Copy missing part of the data\n            data.copy(newStubBuffer, conn.stubBuffer.length);\n            // Exit parsing loop\n            data = Buffer.alloc(0);\n          }\n        } else {\n          if (data.length > 4) {\n            // Retrieve the message size\n            const sizeOfMessage = data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);\n            // If we have a negative sizeOfMessage emit error and return\n            if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: '',\n                bin: conn.buffer,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: conn.bytesRead,\n                  stubBuffer: conn.stubBuffer\n                }\n              };\n              // We got a parse Error fire it off then keep going\n              conn.emit('parseError', errorObject, conn);\n              return;\n            }\n\n            // Ensure that the size of message is larger than 0 and less than the max allowed\n            if (\n              sizeOfMessage > 4 &&\n              sizeOfMessage < conn.maxBsonMessageSize &&\n              sizeOfMessage > data.length\n            ) {\n              conn.buffer = Buffer.alloc(sizeOfMessage);\n              // Copy all the data into the buffer\n              data.copy(conn.buffer, 0);\n              // Update bytes read\n              conn.bytesRead = data.length;\n              // Update sizeOfMessage\n              conn.sizeOfMessage = sizeOfMessage;\n              // Ensure stub buffer is null\n              conn.stubBuffer = null;\n              // Exit parsing loop\n              data = Buffer.alloc(0);\n            } else if (\n              sizeOfMessage > 4 &&\n              sizeOfMessage < conn.maxBsonMessageSize &&\n              sizeOfMessage === data.length\n            ) {\n              const emitBuffer = data;\n              // Reset state of buffer\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null;\n              // Exit parsing loop\n              data = Buffer.alloc(0);\n              // Emit the message\n              processMessage(conn, emitBuffer);\n            } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: null,\n                bin: data,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: 0,\n                  buffer: null,\n                  stubBuffer: null\n                }\n              };\n              // We got a parse Error fire it off then keep going\n              conn.emit('parseError', errorObject, conn);\n\n              // Clear out the state of the parser\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null;\n              // Exit parsing loop\n              data = Buffer.alloc(0);\n            } else {\n              const emitBuffer = data.slice(0, sizeOfMessage);\n              // Reset state of buffer\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null;\n              // Copy rest of message\n              data = data.slice(sizeOfMessage);\n              // Emit the message\n              processMessage(conn, emitBuffer);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            conn.stubBuffer = Buffer.alloc(data.length);\n            // Copy the data to the stub buffer\n            data.copy(conn.stubBuffer, 0);\n            // Exit parsing loop\n            data = Buffer.alloc(0);\n          }\n        }\n      }\n    }\n  };\n}\n\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Connection#connect\n * @type {Connection}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Connection#close\n * @type {Connection}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Connection#error\n * @type {Connection}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Connection#timeout\n * @type {Connection}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Connection#parseError\n * @type {Connection}\n */\n\n/**\n * An event emitted each time the connection receives a parsed message from the wire\n *\n * @event Connection#message\n * @type {Connection}\n */\n\nmodule.exports = Connection;\n"]},"metadata":{},"sourceType":"script"}