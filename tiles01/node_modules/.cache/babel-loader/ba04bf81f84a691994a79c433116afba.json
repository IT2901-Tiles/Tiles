{"ast":null,"code":"'use strict';\n\nconst common = require('./common');\n\nconst BulkOperationBase = common.BulkOperationBase;\nconst Batch = common.Batch;\nconst bson = common.bson;\n\nconst utils = require('../utils');\n\nconst toError = utils.toError;\n/**\n * Add to internal list of Operations\n *\n * @ignore\n * @param {OrderedBulkOperation} bulkOperation\n * @param {number} docType number indicating the document type\n * @param {object} document\n * @return {OrderedBulkOperation}\n */\n\nfunction addToOperationsList(bulkOperation, docType, document) {\n  // Get the bsonSize\n  const bsonSize = bson.calculateObjectSize(document, {\n    checkKeys: false,\n    // Since we don't know what the user selected for BSON options here,\n    // err on the safe side, and check the size with ignoreUndefined: false.\n    ignoreUndefined: false\n  }); // Throw error if the doc is bigger than the max BSON size\n\n  if (bsonSize >= bulkOperation.s.maxBsonObjectSize) throw toError('document is larger than the maximum size ' + bulkOperation.s.maxBsonObjectSize); // Create a new batch object if we don't have a current one\n\n  if (bulkOperation.s.currentBatch == null) bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);\n  const maxKeySize = bulkOperation.s.maxKeySize; // Check if we need to create a new batch\n\n  if ( // New batch if we exceed the max batch op size\n  bulkOperation.s.currentBatchSize + 1 >= bulkOperation.s.maxWriteBatchSize || // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,\n  // since we can't sent an empty batch\n  bulkOperation.s.currentBatchSize > 0 && bulkOperation.s.currentBatchSizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || // New batch if the new op does not have the same op type as the current batch\n  bulkOperation.s.currentBatch.batchType !== docType) {\n    // Save the batch to the execution stack\n    bulkOperation.s.batches.push(bulkOperation.s.currentBatch); // Create a new batch\n\n    bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex); // Reset the current size trackers\n\n    bulkOperation.s.currentBatchSize = 0;\n    bulkOperation.s.currentBatchSizeBytes = 0;\n  }\n\n  if (docType === common.INSERT) {\n    bulkOperation.s.bulkResult.insertedIds.push({\n      index: bulkOperation.s.currentIndex,\n      _id: document._id\n    });\n  } // We have an array of documents\n\n\n  if (Array.isArray(document)) {\n    throw toError('operation passed in cannot be an Array');\n  }\n\n  bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);\n  bulkOperation.s.currentBatch.operations.push(document);\n  bulkOperation.s.currentBatchSize += 1;\n  bulkOperation.s.currentBatchSizeBytes += maxKeySize + bsonSize;\n  bulkOperation.s.currentIndex += 1; // Return bulkOperation\n\n  return bulkOperation;\n}\n/**\n * Create a new OrderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)\n * @class\n * @extends BulkOperationBase\n * @property {number} length Get the number of operations in the bulk.\n * @return {OrderedBulkOperation} a OrderedBulkOperation instance.\n */\n\n\nclass OrderedBulkOperation extends BulkOperationBase {\n  constructor(topology, collection, options) {\n    options = options || {};\n    options = Object.assign(options, {\n      addToOperationsList\n    });\n    super(topology, collection, options, true);\n  }\n\n}\n/**\n * Returns an unordered batch object\n * @ignore\n */\n\n\nfunction initializeOrderedBulkOp(topology, collection, options) {\n  return new OrderedBulkOperation(topology, collection, options);\n}\n\ninitializeOrderedBulkOp.OrderedBulkOperation = OrderedBulkOperation;\nmodule.exports = initializeOrderedBulkOp;\nmodule.exports.Bulk = OrderedBulkOperation;","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/bulk/ordered.js"],"names":["common","require","BulkOperationBase","Batch","bson","utils","toError","addToOperationsList","bulkOperation","docType","document","bsonSize","calculateObjectSize","checkKeys","ignoreUndefined","s","maxBsonObjectSize","currentBatch","currentIndex","maxKeySize","currentBatchSize","maxWriteBatchSize","currentBatchSizeBytes","maxBatchSizeBytes","batchType","batches","push","INSERT","bulkResult","insertedIds","index","_id","Array","isArray","originalIndexes","operations","OrderedBulkOperation","constructor","topology","collection","options","Object","assign","initializeOrderedBulkOp","module","exports","Bulk"],"mappings":"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","sourcesContent":["'use strict';\n\nconst common = require('./common');\nconst BulkOperationBase = common.BulkOperationBase;\nconst Batch = common.Batch;\nconst bson = common.bson;\nconst utils = require('../utils');\nconst toError = utils.toError;\n\n/**\n * Add to internal list of Operations\n *\n * @ignore\n * @param {OrderedBulkOperation} bulkOperation\n * @param {number} docType number indicating the document type\n * @param {object} document\n * @return {OrderedBulkOperation}\n */\nfunction addToOperationsList(bulkOperation, docType, document) {\n  // Get the bsonSize\n  const bsonSize = bson.calculateObjectSize(document, {\n    checkKeys: false,\n\n    // Since we don't know what the user selected for BSON options here,\n    // err on the safe side, and check the size with ignoreUndefined: false.\n    ignoreUndefined: false\n  });\n\n  // Throw error if the doc is bigger than the max BSON size\n  if (bsonSize >= bulkOperation.s.maxBsonObjectSize)\n    throw toError('document is larger than the maximum size ' + bulkOperation.s.maxBsonObjectSize);\n\n  // Create a new batch object if we don't have a current one\n  if (bulkOperation.s.currentBatch == null)\n    bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);\n\n  const maxKeySize = bulkOperation.s.maxKeySize;\n\n  // Check if we need to create a new batch\n  if (\n    // New batch if we exceed the max batch op size\n    bulkOperation.s.currentBatchSize + 1 >= bulkOperation.s.maxWriteBatchSize ||\n    // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,\n    // since we can't sent an empty batch\n    (bulkOperation.s.currentBatchSize > 0 &&\n      bulkOperation.s.currentBatchSizeBytes + maxKeySize + bsonSize >=\n        bulkOperation.s.maxBatchSizeBytes) ||\n    // New batch if the new op does not have the same op type as the current batch\n    bulkOperation.s.currentBatch.batchType !== docType\n  ) {\n    // Save the batch to the execution stack\n    bulkOperation.s.batches.push(bulkOperation.s.currentBatch);\n\n    // Create a new batch\n    bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);\n\n    // Reset the current size trackers\n    bulkOperation.s.currentBatchSize = 0;\n    bulkOperation.s.currentBatchSizeBytes = 0;\n  }\n\n  if (docType === common.INSERT) {\n    bulkOperation.s.bulkResult.insertedIds.push({\n      index: bulkOperation.s.currentIndex,\n      _id: document._id\n    });\n  }\n\n  // We have an array of documents\n  if (Array.isArray(document)) {\n    throw toError('operation passed in cannot be an Array');\n  }\n\n  bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);\n  bulkOperation.s.currentBatch.operations.push(document);\n  bulkOperation.s.currentBatchSize += 1;\n  bulkOperation.s.currentBatchSizeBytes += maxKeySize + bsonSize;\n  bulkOperation.s.currentIndex += 1;\n\n  // Return bulkOperation\n  return bulkOperation;\n}\n\n/**\n * Create a new OrderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)\n * @class\n * @extends BulkOperationBase\n * @property {number} length Get the number of operations in the bulk.\n * @return {OrderedBulkOperation} a OrderedBulkOperation instance.\n */\nclass OrderedBulkOperation extends BulkOperationBase {\n  constructor(topology, collection, options) {\n    options = options || {};\n    options = Object.assign(options, { addToOperationsList });\n\n    super(topology, collection, options, true);\n  }\n}\n\n/**\n * Returns an unordered batch object\n * @ignore\n */\nfunction initializeOrderedBulkOp(topology, collection, options) {\n  return new OrderedBulkOperation(topology, collection, options);\n}\n\ninitializeOrderedBulkOp.OrderedBulkOperation = OrderedBulkOperation;\nmodule.exports = initializeOrderedBulkOp;\nmodule.exports.Bulk = OrderedBulkOperation;\n"]},"metadata":{},"sourceType":"script"}