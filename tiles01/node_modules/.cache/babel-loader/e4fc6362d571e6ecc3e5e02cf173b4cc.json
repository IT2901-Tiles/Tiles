{"ast":null,"code":"// Custom inspect property name / symbol.\nvar inspect = 'inspect';\n\nvar utils = require('./parser/utils');\n/**\n * Machine id.\n *\n * Create a random 3-byte value (i.e. unique for this\n * process). Other drivers use a md5 of the machine id here, but\n * that would mean an asyc call to gethostname, so we don't bother.\n * @ignore\n */\n\n\nvar MACHINE_ID = parseInt(Math.random() * 0xffffff, 10); // Regular expression that checks for hex value\n\nvar checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$'); // Check if buffer exists\n\ntry {\n  if (Buffer && Buffer.from) {\n    var hasBufferType = true;\n    inspect = require('util').inspect.custom || 'inspect';\n  }\n} catch (err) {\n  hasBufferType = false;\n}\n/**\n* Create a new ObjectID instance\n*\n* @class\n* @param {(string|number)} id Can be a 24 byte hex string, 12 byte binary string or a Number.\n* @property {number} generationTime The generation time of this ObjectId instance\n* @return {ObjectID} instance of ObjectID.\n*/\n\n\nvar ObjectID = function ObjectID(id) {\n  // Duck-typing to support ObjectId from different npm packages\n  if (id instanceof ObjectID) return id;\n  if (!(this instanceof ObjectID)) return new ObjectID(id);\n  this._bsontype = 'ObjectID'; // The most common usecase (blank id, new objectId instance)\n\n  if (id == null || typeof id === 'number') {\n    // Generate a new id\n    this.id = this.generate(id); // If we are caching the hex string\n\n    if (ObjectID.cacheHexString) this.__id = this.toString('hex'); // Return the object\n\n    return;\n  } // Check if the passed in id is valid\n\n\n  var valid = ObjectID.isValid(id); // Throw an error if it's not a valid setup\n\n  if (!valid && id != null) {\n    throw new Error('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');\n  } else if (valid && typeof id === 'string' && id.length === 24 && hasBufferType) {\n    return new ObjectID(utils.toBuffer(id, 'hex'));\n  } else if (valid && typeof id === 'string' && id.length === 24) {\n    return ObjectID.createFromHexString(id);\n  } else if (id != null && id.length === 12) {\n    // assume 12 byte string\n    this.id = id;\n  } else if (id != null && typeof id.toHexString === 'function') {\n    // Duck-typing to support ObjectId from different npm packages\n    return id;\n  } else {\n    throw new Error('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');\n  }\n\n  if (ObjectID.cacheHexString) this.__id = this.toString('hex');\n}; // Allow usage of ObjectId as well as ObjectID\n// var ObjectId = ObjectID;\n// Precomputed hex table enables speedy hex string conversion\n\n\nvar hexTable = [];\n\nfor (var i = 0; i < 256; i++) {\n  hexTable[i] = (i <= 15 ? '0' : '') + i.toString(16);\n}\n/**\n* Return the ObjectID id as a 24 byte hex string representation\n*\n* @method\n* @return {string} return the 24 byte hex string representation.\n*/\n\n\nObjectID.prototype.toHexString = function () {\n  if (ObjectID.cacheHexString && this.__id) return this.__id;\n  var hexString = '';\n\n  if (!this.id || !this.id.length) {\n    throw new Error('invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [' + JSON.stringify(this.id) + ']');\n  }\n\n  if (this.id instanceof _Buffer) {\n    hexString = convertToHex(this.id);\n    if (ObjectID.cacheHexString) this.__id = hexString;\n    return hexString;\n  }\n\n  for (var i = 0; i < this.id.length; i++) {\n    hexString += hexTable[this.id.charCodeAt(i)];\n  }\n\n  if (ObjectID.cacheHexString) this.__id = hexString;\n  return hexString;\n};\n/**\n* Update the ObjectID index used in generating new ObjectID's on the driver\n*\n* @method\n* @return {number} returns next index value.\n* @ignore\n*/\n\n\nObjectID.prototype.get_inc = function () {\n  return ObjectID.index = (ObjectID.index + 1) % 0xffffff;\n};\n/**\n* Update the ObjectID index used in generating new ObjectID's on the driver\n*\n* @method\n* @return {number} returns next index value.\n* @ignore\n*/\n\n\nObjectID.prototype.getInc = function () {\n  return this.get_inc();\n};\n/**\n* Generate a 12 byte id buffer used in ObjectID's\n*\n* @method\n* @param {number} [time] optional parameter allowing to pass in a second based timestamp.\n* @return {Buffer} return the 12 byte id buffer string.\n*/\n\n\nObjectID.prototype.generate = function (time) {\n  if ('number' !== typeof time) {\n    time = ~~(Date.now() / 1000);\n  } // Use pid\n\n\n  var pid = (typeof process === 'undefined' || process.pid === 1 ? Math.floor(Math.random() * 100000) : process.pid) % 0xffff;\n  var inc = this.get_inc(); // Buffer used\n\n  var buffer = utils.allocBuffer(12); // Encode time\n\n  buffer[3] = time & 0xff;\n  buffer[2] = time >> 8 & 0xff;\n  buffer[1] = time >> 16 & 0xff;\n  buffer[0] = time >> 24 & 0xff; // Encode machine\n\n  buffer[6] = MACHINE_ID & 0xff;\n  buffer[5] = MACHINE_ID >> 8 & 0xff;\n  buffer[4] = MACHINE_ID >> 16 & 0xff; // Encode pid\n\n  buffer[8] = pid & 0xff;\n  buffer[7] = pid >> 8 & 0xff; // Encode index\n\n  buffer[11] = inc & 0xff;\n  buffer[10] = inc >> 8 & 0xff;\n  buffer[9] = inc >> 16 & 0xff; // Return the buffer\n\n  return buffer;\n};\n/**\n* Converts the id into a 24 byte hex string for printing\n*\n* @param {String} format The Buffer toString format parameter.\n* @return {String} return the 24 byte hex string representation.\n* @ignore\n*/\n\n\nObjectID.prototype.toString = function (format) {\n  // Is the id a buffer then use the buffer toString method to return the format\n  if (this.id && this.id.copy) {\n    return this.id.toString(typeof format === 'string' ? format : 'hex');\n  } // if(this.buffer )\n\n\n  return this.toHexString();\n};\n/**\n* Converts to a string representation of this Id.\n*\n* @return {String} return the 24 byte hex string representation.\n* @ignore\n*/\n\n\nObjectID.prototype[inspect] = ObjectID.prototype.toString;\n/**\n* Converts to its JSON representation.\n*\n* @return {String} return the 24 byte hex string representation.\n* @ignore\n*/\n\nObjectID.prototype.toJSON = function () {\n  return this.toHexString();\n};\n/**\n* Compares the equality of this ObjectID with `otherID`.\n*\n* @method\n* @param {object} otherID ObjectID instance to compare against.\n* @return {boolean} the result of comparing two ObjectID's\n*/\n\n\nObjectID.prototype.equals = function equals(otherId) {\n  // var id;\n  if (otherId instanceof ObjectID) {\n    return this.toString() === otherId.toString();\n  } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 12 && this.id instanceof _Buffer) {\n    return otherId === this.id.toString('binary');\n  } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 24) {\n    return otherId.toLowerCase() === this.toHexString();\n  } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 12) {\n    return otherId === this.id;\n  } else if (otherId != null && (otherId instanceof ObjectID || otherId.toHexString)) {\n    return otherId.toHexString() === this.toHexString();\n  } else {\n    return false;\n  }\n};\n/**\n* Returns the generation date (accurate up to the second) that this ID was generated.\n*\n* @method\n* @return {date} the generation date\n*/\n\n\nObjectID.prototype.getTimestamp = function () {\n  var timestamp = new Date();\n  var time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;\n  timestamp.setTime(Math.floor(time) * 1000);\n  return timestamp;\n};\n/**\n* @ignore\n*/\n\n\nObjectID.index = ~~(Math.random() * 0xffffff);\n/**\n* @ignore\n*/\n\nObjectID.createPk = function createPk() {\n  return new ObjectID();\n};\n/**\n* Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.\n*\n* @method\n* @param {number} time an integer number representing a number of seconds.\n* @return {ObjectID} return the created ObjectID\n*/\n\n\nObjectID.createFromTime = function createFromTime(time) {\n  var buffer = utils.toBuffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]); // Encode time into first 4 bytes\n\n  buffer[3] = time & 0xff;\n  buffer[2] = time >> 8 & 0xff;\n  buffer[1] = time >> 16 & 0xff;\n  buffer[0] = time >> 24 & 0xff; // Return the new objectId\n\n  return new ObjectID(buffer);\n}; // Lookup tables\n//var encodeLookup = '0123456789abcdef'.split('');\n\n\nvar decodeLookup = [];\ni = 0;\n\nwhile (i < 10) decodeLookup[0x30 + i] = i++;\n\nwhile (i < 16) decodeLookup[0x41 - 10 + i] = decodeLookup[0x61 - 10 + i] = i++;\n\nvar _Buffer = Buffer;\n\nvar convertToHex = function (bytes) {\n  return bytes.toString('hex');\n};\n/**\n* Creates an ObjectID from a hex string representation of an ObjectID.\n*\n* @method\n* @param {string} hexString create a ObjectID from a passed in 24 byte hexstring.\n* @return {ObjectID} return the created ObjectID\n*/\n\n\nObjectID.createFromHexString = function createFromHexString(string) {\n  // Throw an error if it's not a valid setup\n  if (typeof string === 'undefined' || string != null && string.length !== 24) {\n    throw new Error('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');\n  } // Use Buffer.from method if available\n\n\n  if (hasBufferType) return new ObjectID(utils.toBuffer(string, 'hex')); // Calculate lengths\n\n  var array = new _Buffer(12);\n  var n = 0;\n  var i = 0;\n\n  while (i < 24) {\n    array[n++] = decodeLookup[string.charCodeAt(i++)] << 4 | decodeLookup[string.charCodeAt(i++)];\n  }\n\n  return new ObjectID(array);\n};\n/**\n* Checks if a value is a valid bson ObjectId\n*\n* @method\n* @return {boolean} return true if the value is a valid bson ObjectId, return false otherwise.\n*/\n\n\nObjectID.isValid = function isValid(id) {\n  if (id == null) return false;\n\n  if (typeof id === 'number') {\n    return true;\n  }\n\n  if (typeof id === 'string') {\n    return id.length === 12 || id.length === 24 && checkForHexRegExp.test(id);\n  }\n\n  if (id instanceof ObjectID) {\n    return true;\n  }\n\n  if (id instanceof _Buffer) {\n    return true;\n  } // Duck-Typing detection of ObjectId like objects\n\n\n  if (typeof id.toHexString === 'function' && (id.id instanceof _Buffer || typeof id.id === 'string')) {\n    return id.id.length === 12 || id.id.length === 24 && checkForHexRegExp.test(id.id);\n  }\n\n  return false;\n};\n/**\n* @ignore\n*/\n\n\nObject.defineProperty(ObjectID.prototype, 'generationTime', {\n  enumerable: true,\n  get: function () {\n    return this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;\n  },\n  set: function (value) {\n    // Encode time into first 4 bytes\n    this.id[3] = value & 0xff;\n    this.id[2] = value >> 8 & 0xff;\n    this.id[1] = value >> 16 & 0xff;\n    this.id[0] = value >> 24 & 0xff;\n  }\n});\n/**\n * Expose.\n */\n\nmodule.exports = ObjectID;\nmodule.exports.ObjectID = ObjectID;\nmodule.exports.ObjectId = ObjectID;","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/bson/lib/bson/objectid.js"],"names":["inspect","utils","require","MACHINE_ID","parseInt","Math","random","checkForHexRegExp","RegExp","Buffer","from","hasBufferType","custom","err","ObjectID","id","_bsontype","generate","cacheHexString","__id","toString","valid","isValid","Error","length","toBuffer","createFromHexString","toHexString","hexTable","i","prototype","hexString","JSON","stringify","_Buffer","convertToHex","charCodeAt","get_inc","index","getInc","time","Date","now","pid","process","floor","inc","buffer","allocBuffer","format","copy","toJSON","equals","otherId","toLowerCase","getTimestamp","timestamp","setTime","createPk","createFromTime","decodeLookup","bytes","string","array","n","test","Object","defineProperty","enumerable","get","set","value","module","exports","ObjectId"],"mappings":"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","sourcesContent":["// Custom inspect property name / symbol.\nvar inspect = 'inspect';\n\nvar utils = require('./parser/utils');\n\n/**\n * Machine id.\n *\n * Create a random 3-byte value (i.e. unique for this\n * process). Other drivers use a md5 of the machine id here, but\n * that would mean an asyc call to gethostname, so we don't bother.\n * @ignore\n */\nvar MACHINE_ID = parseInt(Math.random() * 0xffffff, 10);\n\n// Regular expression that checks for hex value\nvar checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$');\n\n// Check if buffer exists\ntry {\n  if (Buffer && Buffer.from) {\n    var hasBufferType = true;\n    inspect = require('util').inspect.custom || 'inspect';\n  }\n} catch (err) {\n  hasBufferType = false;\n}\n\n/**\n* Create a new ObjectID instance\n*\n* @class\n* @param {(string|number)} id Can be a 24 byte hex string, 12 byte binary string or a Number.\n* @property {number} generationTime The generation time of this ObjectId instance\n* @return {ObjectID} instance of ObjectID.\n*/\nvar ObjectID = function ObjectID(id) {\n  // Duck-typing to support ObjectId from different npm packages\n  if (id instanceof ObjectID) return id;\n  if (!(this instanceof ObjectID)) return new ObjectID(id);\n\n  this._bsontype = 'ObjectID';\n\n  // The most common usecase (blank id, new objectId instance)\n  if (id == null || typeof id === 'number') {\n    // Generate a new id\n    this.id = this.generate(id);\n    // If we are caching the hex string\n    if (ObjectID.cacheHexString) this.__id = this.toString('hex');\n    // Return the object\n    return;\n  }\n\n  // Check if the passed in id is valid\n  var valid = ObjectID.isValid(id);\n\n  // Throw an error if it's not a valid setup\n  if (!valid && id != null) {\n    throw new Error(\n      'Argument passed in must be a single String of 12 bytes or a string of 24 hex characters'\n    );\n  } else if (valid && typeof id === 'string' && id.length === 24 && hasBufferType) {\n    return new ObjectID(utils.toBuffer(id, 'hex'));\n  } else if (valid && typeof id === 'string' && id.length === 24) {\n    return ObjectID.createFromHexString(id);\n  } else if (id != null && id.length === 12) {\n    // assume 12 byte string\n    this.id = id;\n  } else if (id != null && typeof id.toHexString === 'function') {\n    // Duck-typing to support ObjectId from different npm packages\n    return id;\n  } else {\n    throw new Error(\n      'Argument passed in must be a single String of 12 bytes or a string of 24 hex characters'\n    );\n  }\n\n  if (ObjectID.cacheHexString) this.__id = this.toString('hex');\n};\n\n// Allow usage of ObjectId as well as ObjectID\n// var ObjectId = ObjectID;\n\n// Precomputed hex table enables speedy hex string conversion\nvar hexTable = [];\nfor (var i = 0; i < 256; i++) {\n  hexTable[i] = (i <= 15 ? '0' : '') + i.toString(16);\n}\n\n/**\n* Return the ObjectID id as a 24 byte hex string representation\n*\n* @method\n* @return {string} return the 24 byte hex string representation.\n*/\nObjectID.prototype.toHexString = function() {\n  if (ObjectID.cacheHexString && this.__id) return this.__id;\n\n  var hexString = '';\n  if (!this.id || !this.id.length) {\n    throw new Error(\n      'invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [' +\n        JSON.stringify(this.id) +\n        ']'\n    );\n  }\n\n  if (this.id instanceof _Buffer) {\n    hexString = convertToHex(this.id);\n    if (ObjectID.cacheHexString) this.__id = hexString;\n    return hexString;\n  }\n\n  for (var i = 0; i < this.id.length; i++) {\n    hexString += hexTable[this.id.charCodeAt(i)];\n  }\n\n  if (ObjectID.cacheHexString) this.__id = hexString;\n  return hexString;\n};\n\n/**\n* Update the ObjectID index used in generating new ObjectID's on the driver\n*\n* @method\n* @return {number} returns next index value.\n* @ignore\n*/\nObjectID.prototype.get_inc = function() {\n  return (ObjectID.index = (ObjectID.index + 1) % 0xffffff);\n};\n\n/**\n* Update the ObjectID index used in generating new ObjectID's on the driver\n*\n* @method\n* @return {number} returns next index value.\n* @ignore\n*/\nObjectID.prototype.getInc = function() {\n  return this.get_inc();\n};\n\n/**\n* Generate a 12 byte id buffer used in ObjectID's\n*\n* @method\n* @param {number} [time] optional parameter allowing to pass in a second based timestamp.\n* @return {Buffer} return the 12 byte id buffer string.\n*/\nObjectID.prototype.generate = function(time) {\n  if ('number' !== typeof time) {\n    time = ~~(Date.now() / 1000);\n  }\n\n  // Use pid\n  var pid =\n    (typeof process === 'undefined' || process.pid === 1\n      ? Math.floor(Math.random() * 100000)\n      : process.pid) % 0xffff;\n  var inc = this.get_inc();\n  // Buffer used\n  var buffer = utils.allocBuffer(12);\n  // Encode time\n  buffer[3] = time & 0xff;\n  buffer[2] = (time >> 8) & 0xff;\n  buffer[1] = (time >> 16) & 0xff;\n  buffer[0] = (time >> 24) & 0xff;\n  // Encode machine\n  buffer[6] = MACHINE_ID & 0xff;\n  buffer[5] = (MACHINE_ID >> 8) & 0xff;\n  buffer[4] = (MACHINE_ID >> 16) & 0xff;\n  // Encode pid\n  buffer[8] = pid & 0xff;\n  buffer[7] = (pid >> 8) & 0xff;\n  // Encode index\n  buffer[11] = inc & 0xff;\n  buffer[10] = (inc >> 8) & 0xff;\n  buffer[9] = (inc >> 16) & 0xff;\n  // Return the buffer\n  return buffer;\n};\n\n/**\n* Converts the id into a 24 byte hex string for printing\n*\n* @param {String} format The Buffer toString format parameter.\n* @return {String} return the 24 byte hex string representation.\n* @ignore\n*/\nObjectID.prototype.toString = function(format) {\n  // Is the id a buffer then use the buffer toString method to return the format\n  if (this.id && this.id.copy) {\n    return this.id.toString(typeof format === 'string' ? format : 'hex');\n  }\n\n  // if(this.buffer )\n  return this.toHexString();\n};\n\n/**\n* Converts to a string representation of this Id.\n*\n* @return {String} return the 24 byte hex string representation.\n* @ignore\n*/\nObjectID.prototype[inspect] = ObjectID.prototype.toString;\n\n/**\n* Converts to its JSON representation.\n*\n* @return {String} return the 24 byte hex string representation.\n* @ignore\n*/\nObjectID.prototype.toJSON = function() {\n  return this.toHexString();\n};\n\n/**\n* Compares the equality of this ObjectID with `otherID`.\n*\n* @method\n* @param {object} otherID ObjectID instance to compare against.\n* @return {boolean} the result of comparing two ObjectID's\n*/\nObjectID.prototype.equals = function equals(otherId) {\n  // var id;\n\n  if (otherId instanceof ObjectID) {\n    return this.toString() === otherId.toString();\n  } else if (\n    typeof otherId === 'string' &&\n    ObjectID.isValid(otherId) &&\n    otherId.length === 12 &&\n    this.id instanceof _Buffer\n  ) {\n    return otherId === this.id.toString('binary');\n  } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 24) {\n    return otherId.toLowerCase() === this.toHexString();\n  } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 12) {\n    return otherId === this.id;\n  } else if (otherId != null && (otherId instanceof ObjectID || otherId.toHexString)) {\n    return otherId.toHexString() === this.toHexString();\n  } else {\n    return false;\n  }\n};\n\n/**\n* Returns the generation date (accurate up to the second) that this ID was generated.\n*\n* @method\n* @return {date} the generation date\n*/\nObjectID.prototype.getTimestamp = function() {\n  var timestamp = new Date();\n  var time = this.id[3] | (this.id[2] << 8) | (this.id[1] << 16) | (this.id[0] << 24);\n  timestamp.setTime(Math.floor(time) * 1000);\n  return timestamp;\n};\n\n/**\n* @ignore\n*/\nObjectID.index = ~~(Math.random() * 0xffffff);\n\n/**\n* @ignore\n*/\nObjectID.createPk = function createPk() {\n  return new ObjectID();\n};\n\n/**\n* Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.\n*\n* @method\n* @param {number} time an integer number representing a number of seconds.\n* @return {ObjectID} return the created ObjectID\n*/\nObjectID.createFromTime = function createFromTime(time) {\n  var buffer = utils.toBuffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n  // Encode time into first 4 bytes\n  buffer[3] = time & 0xff;\n  buffer[2] = (time >> 8) & 0xff;\n  buffer[1] = (time >> 16) & 0xff;\n  buffer[0] = (time >> 24) & 0xff;\n  // Return the new objectId\n  return new ObjectID(buffer);\n};\n\n// Lookup tables\n//var encodeLookup = '0123456789abcdef'.split('');\nvar decodeLookup = [];\ni = 0;\nwhile (i < 10) decodeLookup[0x30 + i] = i++;\nwhile (i < 16) decodeLookup[0x41 - 10 + i] = decodeLookup[0x61 - 10 + i] = i++;\n\nvar _Buffer = Buffer;\nvar convertToHex = function(bytes) {\n  return bytes.toString('hex');\n};\n\n/**\n* Creates an ObjectID from a hex string representation of an ObjectID.\n*\n* @method\n* @param {string} hexString create a ObjectID from a passed in 24 byte hexstring.\n* @return {ObjectID} return the created ObjectID\n*/\nObjectID.createFromHexString = function createFromHexString(string) {\n  // Throw an error if it's not a valid setup\n  if (typeof string === 'undefined' || (string != null && string.length !== 24)) {\n    throw new Error(\n      'Argument passed in must be a single String of 12 bytes or a string of 24 hex characters'\n    );\n  }\n\n  // Use Buffer.from method if available\n  if (hasBufferType) return new ObjectID(utils.toBuffer(string, 'hex'));\n\n  // Calculate lengths\n  var array = new _Buffer(12);\n  var n = 0;\n  var i = 0;\n\n  while (i < 24) {\n    array[n++] = (decodeLookup[string.charCodeAt(i++)] << 4) | decodeLookup[string.charCodeAt(i++)];\n  }\n\n  return new ObjectID(array);\n};\n\n/**\n* Checks if a value is a valid bson ObjectId\n*\n* @method\n* @return {boolean} return true if the value is a valid bson ObjectId, return false otherwise.\n*/\nObjectID.isValid = function isValid(id) {\n  if (id == null) return false;\n\n  if (typeof id === 'number') {\n    return true;\n  }\n\n  if (typeof id === 'string') {\n    return id.length === 12 || (id.length === 24 && checkForHexRegExp.test(id));\n  }\n\n  if (id instanceof ObjectID) {\n    return true;\n  }\n\n  if (id instanceof _Buffer) {\n    return true;\n  }\n\n  // Duck-Typing detection of ObjectId like objects\n  if (\n      typeof id.toHexString === 'function' &&\n      (id.id instanceof _Buffer || typeof id.id === 'string')\n  ) {\n    return id.id.length === 12 || (id.id.length === 24 && checkForHexRegExp.test(id.id));\n  }\n\n  return false;\n};\n\n/**\n* @ignore\n*/\nObject.defineProperty(ObjectID.prototype, 'generationTime', {\n  enumerable: true,\n  get: function() {\n    return this.id[3] | (this.id[2] << 8) | (this.id[1] << 16) | (this.id[0] << 24);\n  },\n  set: function(value) {\n    // Encode time into first 4 bytes\n    this.id[3] = value & 0xff;\n    this.id[2] = (value >> 8) & 0xff;\n    this.id[1] = (value >> 16) & 0xff;\n    this.id[0] = (value >> 24) & 0xff;\n  }\n});\n\n/**\n * Expose.\n */\nmodule.exports = ObjectID;\nmodule.exports.ObjectID = ObjectID;\nmodule.exports.ObjectId = ObjectID;\n"]},"metadata":{},"sourceType":"script"}