{"ast":null,"code":"'use strict';\n\nconst applyRetryableWrites = require('../utils').applyRetryableWrites;\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst decorateWithCollation = require('../utils').decorateWithCollation;\n\nconst decorateWithReadConcern = require('../utils').decorateWithReadConcern;\n\nconst executeCommand = require('./db_ops').executeCommand;\n\nconst formattedOrderClause = require('../utils').formattedOrderClause;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst MongoError = require('../core').MongoError;\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst toError = require('../utils').toError;\n\nconst CursorState = require('../core/cursor').CursorState;\n\nconst maxWireVersion = require('../core/utils').maxWireVersion;\n/**\n * Build the count command.\n *\n * @method\n * @param {collectionOrCursor} an instance of a collection or cursor\n * @param {object} query The query for the count.\n * @param {object} [options] Optional settings. See Collection.prototype.count and Cursor.prototype.count for a list of options.\n */\n\n\nfunction buildCountCommand(collectionOrCursor, query, options) {\n  const skip = options.skip;\n  const limit = options.limit;\n  let hint = options.hint;\n  const maxTimeMS = options.maxTimeMS;\n  query = query || {}; // Final query\n\n  const cmd = {\n    count: options.collectionName,\n    query: query\n  };\n\n  if (collectionOrCursor.s.numberOfRetries) {\n    // collectionOrCursor is a cursor\n    if (collectionOrCursor.options.hint) {\n      hint = collectionOrCursor.options.hint;\n    } else if (collectionOrCursor.cmd.hint) {\n      hint = collectionOrCursor.cmd.hint;\n    }\n\n    decorateWithCollation(cmd, collectionOrCursor, collectionOrCursor.cmd);\n  } else {\n    decorateWithCollation(cmd, collectionOrCursor, options);\n  } // Add limit, skip and maxTimeMS if defined\n\n\n  if (typeof skip === 'number') cmd.skip = skip;\n  if (typeof limit === 'number') cmd.limit = limit;\n  if (typeof maxTimeMS === 'number') cmd.maxTimeMS = maxTimeMS;\n  if (hint) cmd.hint = hint; // Do we have a readConcern specified\n\n  decorateWithReadConcern(cmd, collectionOrCursor);\n  return cmd;\n}\n/**\n * Find and update a document.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} query Query object to locate the object to modify.\n * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.\n * @param {object} doc The fields/vals to be updated.\n * @param {object} [options] Optional settings. See Collection.prototype.findAndModify for a list of options.\n * @param {Collection~findAndModifyCallback} [callback] The command result callback\n * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead\n */\n\n\nfunction findAndModify(coll, query, sort, doc, options, callback) {\n  // Create findAndModify command object\n  const queryObject = {\n    findAndModify: coll.collectionName,\n    query: query\n  };\n  sort = formattedOrderClause(sort);\n\n  if (sort) {\n    queryObject.sort = sort;\n  }\n\n  queryObject.new = options.new ? true : false;\n  queryObject.remove = options.remove ? true : false;\n  queryObject.upsert = options.upsert ? true : false;\n  const projection = options.projection || options.fields;\n\n  if (projection) {\n    queryObject.fields = projection;\n  }\n\n  if (options.arrayFilters) {\n    queryObject.arrayFilters = options.arrayFilters;\n    delete options.arrayFilters;\n  }\n\n  if (doc && !options.remove) {\n    queryObject.update = doc;\n  }\n\n  if (options.maxTimeMS) queryObject.maxTimeMS = options.maxTimeMS; // Either use override on the function, or go back to default on either the collection\n  // level or db\n\n  options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions; // No check on the documents\n\n  options.checkKeys = false; // Final options for retryable writes and write concern\n\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // Decorate the findAndModify command with the write Concern\n\n  if (finalOptions.writeConcern) {\n    queryObject.writeConcern = finalOptions.writeConcern;\n  } // Have we specified bypassDocumentValidation\n\n\n  if (finalOptions.bypassDocumentValidation === true) {\n    queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;\n  }\n\n  finalOptions.readPreference = ReadPreference.primary; // Have we specified collation\n\n  try {\n    decorateWithCollation(queryObject, coll, finalOptions);\n  } catch (err) {\n    return callback(err, null);\n  } // Execute the command\n\n\n  executeCommand(coll.s.db, queryObject, finalOptions, (err, result) => {\n    if (err) return handleCallback(callback, err, null);\n    return handleCallback(callback, null, result);\n  });\n}\n/**\n * Retrieves this collections index info.\n *\n * @method\n * @param {Db} db The Db instance on which to retrieve the index info.\n * @param {string} name The name of the collection.\n * @param {object} [options] Optional settings. See Db.prototype.indexInformation for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\n\n\nfunction indexInformation(db, name, options, callback) {\n  // If we specified full information\n  const full = options['full'] == null ? false : options['full']; // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Process all the results from the index command and collection\n\n  function processResults(indexes) {\n    // Contains all the information\n    let info = {}; // Process all the indexes\n\n    for (let i = 0; i < indexes.length; i++) {\n      const index = indexes[i]; // Let's unpack the object\n\n      info[index.name] = [];\n\n      for (let name in index.key) {\n        info[index.name].push([name, index.key[name]]);\n      }\n    }\n\n    return info;\n  } // Get the list of indexes of the specified collection\n\n\n  db.collection(name).listIndexes(options).toArray((err, indexes) => {\n    if (err) return callback(toError(err));\n    if (!Array.isArray(indexes)) return handleCallback(callback, null, []);\n    if (full) return handleCallback(callback, null, indexes);\n    handleCallback(callback, null, processResults(indexes));\n  });\n}\n\nfunction prepareDocs(coll, docs, options) {\n  const forceServerObjectId = typeof options.forceServerObjectId === 'boolean' ? options.forceServerObjectId : coll.s.db.options.forceServerObjectId; // no need to modify the docs if server sets the ObjectId\n\n  if (forceServerObjectId === true) {\n    return docs;\n  }\n\n  return docs.map(doc => {\n    if (forceServerObjectId !== true && doc._id == null) {\n      doc._id = coll.s.pkFactory.createPk();\n    }\n\n    return doc;\n  });\n} // Get the next available document from the cursor, returns null if no more documents are available.\n\n\nfunction nextObject(cursor, callback) {\n  if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {\n    return handleCallback(callback, MongoError.create({\n      message: 'Cursor is closed',\n      driver: true\n    }));\n  }\n\n  if (cursor.s.state === CursorState.INIT && cursor.cmd && cursor.cmd.sort) {\n    try {\n      cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);\n    } catch (err) {\n      return handleCallback(callback, err);\n    }\n  } // Get the next object\n\n\n  cursor._next((err, doc) => {\n    cursor.s.state = CursorState.OPEN;\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, doc);\n  });\n}\n\nfunction insertDocuments(coll, docs, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // Ensure we are operating on an array op docs\n\n  docs = Array.isArray(docs) ? docs : [docs]; // Final options for retryable writes and write concern\n\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // If keep going set unordered\n\n  if (finalOptions.keepGoing === true) finalOptions.ordered = false;\n  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;\n  docs = prepareDocs(coll, docs, options); // File inserts\n\n  coll.s.topology.insert(coll.s.namespace, docs, finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0])); // Add docs to the list\n\n    result.ops = docs; // Return the results\n\n    handleCallback(callback, null, result);\n  });\n}\n\nfunction removeDocuments(coll, selector, options, callback) {\n  if (typeof options === 'function') {\n    callback = options, options = {};\n  } else if (typeof selector === 'function') {\n    callback = selector;\n    options = {};\n    selector = {};\n  } // Create an empty options object if the provided one is null\n\n\n  options = options || {}; // Final options for retryable writes and write concern\n\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // If selector is null set empty\n\n  if (selector == null) selector = {}; // Build the op\n\n  const op = {\n    q: selector,\n    limit: 0\n  };\n\n  if (options.single) {\n    op.limit = 1;\n  } else if (finalOptions.retryWrites) {\n    finalOptions.retryWrites = false;\n  }\n\n  if (options.hint) {\n    op.hint = options.hint;\n  } // Have we specified collation\n\n\n  try {\n    decorateWithCollation(finalOptions, coll, options);\n  } catch (err) {\n    return callback(err, null);\n  }\n\n  if (options.explain !== undefined && maxWireVersion(coll.s.topology) < 3) {\n    return callback ? callback(new MongoError(`server does not support explain on remove`)) : undefined;\n  } // Execute the remove\n\n\n  coll.s.topology.remove(coll.s.namespace, [op], finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n\n    if (result.result.writeErrors) {\n      return handleCallback(callback, toError(result.result.writeErrors[0]));\n    } // Return the results\n\n\n    handleCallback(callback, null, result);\n  });\n}\n\nfunction updateDocuments(coll, selector, document, options, callback) {\n  if ('function' === typeof options) callback = options, options = null;\n  if (options == null) options = {};\n  if (!('function' === typeof callback)) callback = null; // If we are not providing a selector or document throw\n\n  if (selector == null || typeof selector !== 'object') return callback(toError('selector must be a valid JavaScript object'));\n  if (document == null || typeof document !== 'object') return callback(toError('document must be a valid JavaScript object')); // Final options for retryable writes and write concern\n\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // Do we return the actual result document\n  // Either use override on the function, or go back to default on either the collection\n  // level or db\n\n  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions; // Execute the operation\n\n  const op = {\n    q: selector,\n    u: document\n  };\n  op.upsert = options.upsert !== void 0 ? !!options.upsert : false;\n  op.multi = options.multi !== void 0 ? !!options.multi : false;\n\n  if (options.hint) {\n    op.hint = options.hint;\n  }\n\n  if (finalOptions.arrayFilters) {\n    op.arrayFilters = finalOptions.arrayFilters;\n    delete finalOptions.arrayFilters;\n  }\n\n  if (finalOptions.retryWrites && op.multi) {\n    finalOptions.retryWrites = false;\n  } // Have we specified collation\n\n\n  try {\n    decorateWithCollation(finalOptions, coll, options);\n  } catch (err) {\n    return callback(err, null);\n  }\n\n  if (options.explain !== undefined && maxWireVersion(coll.s.topology) < 3) {\n    return callback ? callback(new MongoError(`server does not support explain on update`)) : undefined;\n  } // Update options\n\n\n  coll.s.topology.update(coll.s.namespace, [op], finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0])); // Return the results\n\n    handleCallback(callback, null, result);\n  });\n}\n\nmodule.exports = {\n  buildCountCommand,\n  findAndModify,\n  indexInformation,\n  nextObject,\n  prepareDocs,\n  insertDocuments,\n  removeDocuments,\n  updateDocuments\n};","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/operations/common_functions.js"],"names":["applyRetryableWrites","require","applyWriteConcern","decorateWithCollation","decorateWithReadConcern","executeCommand","formattedOrderClause","handleCallback","MongoError","ReadPreference","toError","CursorState","maxWireVersion","buildCountCommand","collectionOrCursor","query","options","skip","limit","hint","maxTimeMS","cmd","count","collectionName","s","numberOfRetries","findAndModify","coll","sort","doc","callback","queryObject","new","remove","upsert","projection","fields","arrayFilters","update","serializeFunctions","checkKeys","finalOptions","Object","assign","db","collection","writeConcern","bypassDocumentValidation","readPreference","primary","err","result","indexInformation","name","full","serverConfig","isDestroyed","processResults","indexes","info","i","length","index","key","push","listIndexes","toArray","Array","isArray","prepareDocs","docs","forceServerObjectId","map","_id","pkFactory","createPk","nextObject","cursor","state","CLOSED","isDead","create","message","driver","INIT","_next","OPEN","insertDocuments","keepGoing","ordered","topology","insert","namespace","code","writeErrors","ops","removeDocuments","selector","op","q","single","retryWrites","explain","undefined","updateDocuments","document","u","multi","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst applyRetryableWrites = require('../utils').applyRetryableWrites;\nconst applyWriteConcern = require('../utils').applyWriteConcern;\nconst decorateWithCollation = require('../utils').decorateWithCollation;\nconst decorateWithReadConcern = require('../utils').decorateWithReadConcern;\nconst executeCommand = require('./db_ops').executeCommand;\nconst formattedOrderClause = require('../utils').formattedOrderClause;\nconst handleCallback = require('../utils').handleCallback;\nconst MongoError = require('../core').MongoError;\nconst ReadPreference = require('../core').ReadPreference;\nconst toError = require('../utils').toError;\nconst CursorState = require('../core/cursor').CursorState;\nconst maxWireVersion = require('../core/utils').maxWireVersion;\n\n/**\n * Build the count command.\n *\n * @method\n * @param {collectionOrCursor} an instance of a collection or cursor\n * @param {object} query The query for the count.\n * @param {object} [options] Optional settings. See Collection.prototype.count and Cursor.prototype.count for a list of options.\n */\nfunction buildCountCommand(collectionOrCursor, query, options) {\n  const skip = options.skip;\n  const limit = options.limit;\n  let hint = options.hint;\n  const maxTimeMS = options.maxTimeMS;\n  query = query || {};\n\n  // Final query\n  const cmd = {\n    count: options.collectionName,\n    query: query\n  };\n\n  if (collectionOrCursor.s.numberOfRetries) {\n    // collectionOrCursor is a cursor\n    if (collectionOrCursor.options.hint) {\n      hint = collectionOrCursor.options.hint;\n    } else if (collectionOrCursor.cmd.hint) {\n      hint = collectionOrCursor.cmd.hint;\n    }\n    decorateWithCollation(cmd, collectionOrCursor, collectionOrCursor.cmd);\n  } else {\n    decorateWithCollation(cmd, collectionOrCursor, options);\n  }\n\n  // Add limit, skip and maxTimeMS if defined\n  if (typeof skip === 'number') cmd.skip = skip;\n  if (typeof limit === 'number') cmd.limit = limit;\n  if (typeof maxTimeMS === 'number') cmd.maxTimeMS = maxTimeMS;\n  if (hint) cmd.hint = hint;\n\n  // Do we have a readConcern specified\n  decorateWithReadConcern(cmd, collectionOrCursor);\n\n  return cmd;\n}\n\n/**\n * Find and update a document.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} query Query object to locate the object to modify.\n * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.\n * @param {object} doc The fields/vals to be updated.\n * @param {object} [options] Optional settings. See Collection.prototype.findAndModify for a list of options.\n * @param {Collection~findAndModifyCallback} [callback] The command result callback\n * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead\n */\nfunction findAndModify(coll, query, sort, doc, options, callback) {\n  // Create findAndModify command object\n  const queryObject = {\n    findAndModify: coll.collectionName,\n    query: query\n  };\n\n  sort = formattedOrderClause(sort);\n  if (sort) {\n    queryObject.sort = sort;\n  }\n\n  queryObject.new = options.new ? true : false;\n  queryObject.remove = options.remove ? true : false;\n  queryObject.upsert = options.upsert ? true : false;\n\n  const projection = options.projection || options.fields;\n\n  if (projection) {\n    queryObject.fields = projection;\n  }\n\n  if (options.arrayFilters) {\n    queryObject.arrayFilters = options.arrayFilters;\n    delete options.arrayFilters;\n  }\n\n  if (doc && !options.remove) {\n    queryObject.update = doc;\n  }\n\n  if (options.maxTimeMS) queryObject.maxTimeMS = options.maxTimeMS;\n\n  // Either use override on the function, or go back to default on either the collection\n  // level or db\n  options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;\n\n  // No check on the documents\n  options.checkKeys = false;\n\n  // Final options for retryable writes and write concern\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);\n\n  // Decorate the findAndModify command with the write Concern\n  if (finalOptions.writeConcern) {\n    queryObject.writeConcern = finalOptions.writeConcern;\n  }\n\n  // Have we specified bypassDocumentValidation\n  if (finalOptions.bypassDocumentValidation === true) {\n    queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;\n  }\n\n  finalOptions.readPreference = ReadPreference.primary;\n\n  // Have we specified collation\n  try {\n    decorateWithCollation(queryObject, coll, finalOptions);\n  } catch (err) {\n    return callback(err, null);\n  }\n\n  // Execute the command\n  executeCommand(coll.s.db, queryObject, finalOptions, (err, result) => {\n    if (err) return handleCallback(callback, err, null);\n\n    return handleCallback(callback, null, result);\n  });\n}\n\n/**\n * Retrieves this collections index info.\n *\n * @method\n * @param {Db} db The Db instance on which to retrieve the index info.\n * @param {string} name The name of the collection.\n * @param {object} [options] Optional settings. See Db.prototype.indexInformation for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\nfunction indexInformation(db, name, options, callback) {\n  // If we specified full information\n  const full = options['full'] == null ? false : options['full'];\n\n  // Did the user destroy the topology\n  if (db.serverConfig && db.serverConfig.isDestroyed())\n    return callback(new MongoError('topology was destroyed'));\n  // Process all the results from the index command and collection\n  function processResults(indexes) {\n    // Contains all the information\n    let info = {};\n    // Process all the indexes\n    for (let i = 0; i < indexes.length; i++) {\n      const index = indexes[i];\n      // Let's unpack the object\n      info[index.name] = [];\n      for (let name in index.key) {\n        info[index.name].push([name, index.key[name]]);\n      }\n    }\n\n    return info;\n  }\n\n  // Get the list of indexes of the specified collection\n  db.collection(name)\n    .listIndexes(options)\n    .toArray((err, indexes) => {\n      if (err) return callback(toError(err));\n      if (!Array.isArray(indexes)) return handleCallback(callback, null, []);\n      if (full) return handleCallback(callback, null, indexes);\n      handleCallback(callback, null, processResults(indexes));\n    });\n}\n\nfunction prepareDocs(coll, docs, options) {\n  const forceServerObjectId =\n    typeof options.forceServerObjectId === 'boolean'\n      ? options.forceServerObjectId\n      : coll.s.db.options.forceServerObjectId;\n\n  // no need to modify the docs if server sets the ObjectId\n  if (forceServerObjectId === true) {\n    return docs;\n  }\n\n  return docs.map(doc => {\n    if (forceServerObjectId !== true && doc._id == null) {\n      doc._id = coll.s.pkFactory.createPk();\n    }\n\n    return doc;\n  });\n}\n\n// Get the next available document from the cursor, returns null if no more documents are available.\nfunction nextObject(cursor, callback) {\n  if (cursor.s.state === CursorState.CLOSED || (cursor.isDead && cursor.isDead())) {\n    return handleCallback(\n      callback,\n      MongoError.create({ message: 'Cursor is closed', driver: true })\n    );\n  }\n\n  if (cursor.s.state === CursorState.INIT && cursor.cmd && cursor.cmd.sort) {\n    try {\n      cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);\n    } catch (err) {\n      return handleCallback(callback, err);\n    }\n  }\n\n  // Get the next object\n  cursor._next((err, doc) => {\n    cursor.s.state = CursorState.OPEN;\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, doc);\n  });\n}\n\nfunction insertDocuments(coll, docs, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n  // Ensure we are operating on an array op docs\n  docs = Array.isArray(docs) ? docs : [docs];\n\n  // Final options for retryable writes and write concern\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);\n\n  // If keep going set unordered\n  if (finalOptions.keepGoing === true) finalOptions.ordered = false;\n  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;\n\n  docs = prepareDocs(coll, docs, options);\n\n  // File inserts\n  coll.s.topology.insert(coll.s.namespace, docs, finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors)\n      return handleCallback(callback, toError(result.result.writeErrors[0]));\n    // Add docs to the list\n    result.ops = docs;\n    // Return the results\n    handleCallback(callback, null, result);\n  });\n}\n\nfunction removeDocuments(coll, selector, options, callback) {\n  if (typeof options === 'function') {\n    (callback = options), (options = {});\n  } else if (typeof selector === 'function') {\n    callback = selector;\n    options = {};\n    selector = {};\n  }\n\n  // Create an empty options object if the provided one is null\n  options = options || {};\n\n  // Final options for retryable writes and write concern\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);\n\n  // If selector is null set empty\n  if (selector == null) selector = {};\n\n  // Build the op\n  const op = { q: selector, limit: 0 };\n  if (options.single) {\n    op.limit = 1;\n  } else if (finalOptions.retryWrites) {\n    finalOptions.retryWrites = false;\n  }\n  if (options.hint) {\n    op.hint = options.hint;\n  }\n\n  // Have we specified collation\n  try {\n    decorateWithCollation(finalOptions, coll, options);\n  } catch (err) {\n    return callback(err, null);\n  }\n\n  if (options.explain !== undefined && maxWireVersion(coll.s.topology) < 3) {\n    return callback\n      ? callback(new MongoError(`server does not support explain on remove`))\n      : undefined;\n  }\n\n  // Execute the remove\n  coll.s.topology.remove(coll.s.namespace, [op], finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors) {\n      return handleCallback(callback, toError(result.result.writeErrors[0]));\n    }\n\n    // Return the results\n    handleCallback(callback, null, result);\n  });\n}\n\nfunction updateDocuments(coll, selector, document, options, callback) {\n  if ('function' === typeof options) (callback = options), (options = null);\n  if (options == null) options = {};\n  if (!('function' === typeof callback)) callback = null;\n\n  // If we are not providing a selector or document throw\n  if (selector == null || typeof selector !== 'object')\n    return callback(toError('selector must be a valid JavaScript object'));\n  if (document == null || typeof document !== 'object')\n    return callback(toError('document must be a valid JavaScript object'));\n\n  // Final options for retryable writes and write concern\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);\n\n  // Do we return the actual result document\n  // Either use override on the function, or go back to default on either the collection\n  // level or db\n  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;\n\n  // Execute the operation\n  const op = { q: selector, u: document };\n  op.upsert = options.upsert !== void 0 ? !!options.upsert : false;\n  op.multi = options.multi !== void 0 ? !!options.multi : false;\n\n  if (options.hint) {\n    op.hint = options.hint;\n  }\n\n  if (finalOptions.arrayFilters) {\n    op.arrayFilters = finalOptions.arrayFilters;\n    delete finalOptions.arrayFilters;\n  }\n\n  if (finalOptions.retryWrites && op.multi) {\n    finalOptions.retryWrites = false;\n  }\n\n  // Have we specified collation\n  try {\n    decorateWithCollation(finalOptions, coll, options);\n  } catch (err) {\n    return callback(err, null);\n  }\n\n  if (options.explain !== undefined && maxWireVersion(coll.s.topology) < 3) {\n    return callback\n      ? callback(new MongoError(`server does not support explain on update`))\n      : undefined;\n  }\n\n  // Update options\n  coll.s.topology.update(coll.s.namespace, [op], finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors)\n      return handleCallback(callback, toError(result.result.writeErrors[0]));\n    // Return the results\n    handleCallback(callback, null, result);\n  });\n}\n\nmodule.exports = {\n  buildCountCommand,\n  findAndModify,\n  indexInformation,\n  nextObject,\n  prepareDocs,\n  insertDocuments,\n  removeDocuments,\n  updateDocuments\n};\n"]},"metadata":{},"sourceType":"script"}