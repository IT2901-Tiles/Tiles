{"ast":null,"code":"'use strict';\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst Code = require('../core').BSON.Code;\n\nconst createIndexDb = require('./db_ops').createIndex;\n\nconst decorateWithCollation = require('../utils').decorateWithCollation;\n\nconst decorateWithReadConcern = require('../utils').decorateWithReadConcern;\n\nconst ensureIndexDb = require('./db_ops').ensureIndex;\n\nconst evaluate = require('./db_ops').evaluate;\n\nconst executeCommand = require('./db_ops').executeCommand;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst indexInformationDb = require('./db_ops').indexInformation;\n\nconst Long = require('../core').BSON.Long;\n\nconst MongoError = require('../core').MongoError;\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst insertDocuments = require('./common_functions').insertDocuments;\n\nconst updateDocuments = require('./common_functions').updateDocuments;\n/**\n * Group function helper\n * @ignore\n */\n// var groupFunction = function () {\n//   var c = db[ns].find(condition);\n//   var map = new Map();\n//   var reduce_function = reduce;\n//\n//   while (c.hasNext()) {\n//     var obj = c.next();\n//     var key = {};\n//\n//     for (var i = 0, len = keys.length; i < len; ++i) {\n//       var k = keys[i];\n//       key[k] = obj[k];\n//     }\n//\n//     var aggObj = map.get(key);\n//\n//     if (aggObj == null) {\n//       var newObj = Object.extend({}, key);\n//       aggObj = Object.extend(newObj, initial);\n//       map.put(key, aggObj);\n//     }\n//\n//     reduce_function(obj, aggObj);\n//   }\n//\n//   return { \"result\": map.values() };\n// }.toString();\n\n\nconst groupFunction = 'function () {\\nvar c = db[ns].find(condition);\\nvar map = new Map();\\nvar reduce_function = reduce;\\n\\nwhile (c.hasNext()) {\\nvar obj = c.next();\\nvar key = {};\\n\\nfor (var i = 0, len = keys.length; i < len; ++i) {\\nvar k = keys[i];\\nkey[k] = obj[k];\\n}\\n\\nvar aggObj = map.get(key);\\n\\nif (aggObj == null) {\\nvar newObj = Object.extend({}, key);\\naggObj = Object.extend(newObj, initial);\\nmap.put(key, aggObj);\\n}\\n\\nreduce_function(obj, aggObj);\\n}\\n\\nreturn { \"result\": map.values() };\\n}';\n/**\n * Create an index on the db and collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings. See Collection.prototype.createIndex for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\nfunction createIndex(coll, fieldOrSpec, options, callback) {\n  createIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options, callback);\n}\n/**\n * Create multiple indexes in the collection. This method is only supported for\n * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\n * error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {array} indexSpecs An array of index specifications to be created\n * @param {Object} [options] Optional settings. See Collection.prototype.createIndexes for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction createIndexes(coll, indexSpecs, options, callback) {\n  const capabilities = coll.s.topology.capabilities(); // Ensure we generate the correct name if the parameter is not set\n\n  for (let i = 0; i < indexSpecs.length; i++) {\n    if (indexSpecs[i].name == null) {\n      const keys = []; // Did the user pass in a collation, check if our write server supports it\n\n      if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {\n        return callback(new MongoError('server/primary/mongos does not support collation'));\n      }\n\n      for (let name in indexSpecs[i].key) {\n        keys.push(`${name}_${indexSpecs[i].key[name]}`);\n      } // Set the name\n\n\n      indexSpecs[i].name = keys.join('_');\n    }\n  }\n\n  options = Object.assign({}, options, {\n    readPreference: ReadPreference.PRIMARY\n  }); // Execute the index\n\n  executeCommand(coll.s.db, {\n    createIndexes: coll.collectionName,\n    indexes: indexSpecs\n  }, options, callback);\n}\n/**\n * Ensure that an index exists. If the index does not exist, this function creates it.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings. See Collection.prototype.ensureIndex for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction ensureIndex(coll, fieldOrSpec, options, callback) {\n  ensureIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options, callback);\n}\n/**\n * Run a group command across a collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {(object|array|function|code)} keys An object, array or function expressing the keys to group by.\n * @param {object} condition An optional condition that must be true for a row to be considered.\n * @param {object} initial Initial value of the aggregation counter object.\n * @param {(function|Code)} reduce The reduce function aggregates (reduces) the objects iterated\n * @param {(function|Code)} finalize An optional function to be run on each item in the result set just before the item is returned.\n * @param {boolean} command Specify if you wish to run using the internal group command or using eval, default is true.\n * @param {object} [options] Optional settings. See Collection.prototype.group for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @deprecated MongoDB 3.6 or higher will no longer support the group command. We recommend rewriting using the aggregation framework.\n */\n\n\nfunction group(coll, keys, condition, initial, reduce, finalize, command, options, callback) {\n  // Execute using the command\n  if (command) {\n    const reduceFunction = reduce && reduce._bsontype === 'Code' ? reduce : new Code(reduce);\n    const selector = {\n      group: {\n        ns: coll.collectionName,\n        $reduce: reduceFunction,\n        cond: condition,\n        initial: initial,\n        out: 'inline'\n      }\n    }; // if finalize is defined\n\n    if (finalize != null) selector.group['finalize'] = finalize; // Set up group selector\n\n    if ('function' === typeof keys || keys && keys._bsontype === 'Code') {\n      selector.group.$keyf = keys && keys._bsontype === 'Code' ? keys : new Code(keys);\n    } else {\n      const hash = {};\n      keys.forEach(key => {\n        hash[key] = 1;\n      });\n      selector.group.key = hash;\n    }\n\n    options = Object.assign({}, options); // Ensure we have the right read preference inheritance\n\n    options.readPreference = ReadPreference.resolve(coll, options); // Do we have a readConcern specified\n\n    decorateWithReadConcern(selector, coll, options); // Have we specified collation\n\n    try {\n      decorateWithCollation(selector, coll, options);\n    } catch (err) {\n      return callback(err, null);\n    } // Execute command\n\n\n    executeCommand(coll.s.db, selector, options, (err, result) => {\n      if (err) return handleCallback(callback, err, null);\n      handleCallback(callback, null, result.retval);\n    });\n  } else {\n    // Create execution scope\n    const scope = reduce != null && reduce._bsontype === 'Code' ? reduce.scope : {};\n    scope.ns = coll.collectionName;\n    scope.keys = keys;\n    scope.condition = condition;\n    scope.initial = initial; // Pass in the function text to execute within mongodb.\n\n    const groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ';');\n    evaluate(coll.s.db, new Code(groupfn, scope), null, options, (err, results) => {\n      if (err) return handleCallback(callback, err, null);\n      handleCallback(callback, null, results.result || results);\n    });\n  }\n}\n/**\n * Retrieve all the indexes on the collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {Object} [options] Optional settings. See Collection.prototype.indexes for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction indexes(coll, options, callback) {\n  options = Object.assign({}, {\n    full: true\n  }, options);\n  indexInformationDb(coll.s.db, coll.collectionName, options, callback);\n}\n/**\n * Check if one or more indexes exist on the collection. This fails on the first index that doesn't exist.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {(string|array)} indexes One or more index names to check.\n * @param {Object} [options] Optional settings. See Collection.prototype.indexExists for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction indexExists(coll, indexes, options, callback) {\n  indexInformation(coll, options, (err, indexInformation) => {\n    // If we have an error return\n    if (err != null) return handleCallback(callback, err, null); // Let's check for the index names\n\n    if (!Array.isArray(indexes)) return handleCallback(callback, null, indexInformation[indexes] != null); // Check in list of indexes\n\n    for (let i = 0; i < indexes.length; i++) {\n      if (indexInformation[indexes[i]] == null) {\n        return handleCallback(callback, null, false);\n      }\n    } // All keys found return true\n\n\n    return handleCallback(callback, null, true);\n  });\n}\n/**\n * Retrieve this collection's index info.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} [options] Optional settings. See Collection.prototype.indexInformation for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction indexInformation(coll, options, callback) {\n  indexInformationDb(coll.s.db, coll.collectionName, options, callback);\n}\n/**\n * Return N parallel cursors for a collection to allow parallel reading of the entire collection. There are\n * no ordering guarantees for returned results.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} [options] Optional settings. See Collection.prototype.parallelCollectionScan for a list of options.\n * @param {Collection~parallelCollectionScanCallback} [callback] The command result callback\n */\n\n\nfunction parallelCollectionScan(coll, options, callback) {\n  // Create command object\n  const commandObject = {\n    parallelCollectionScan: coll.collectionName,\n    numCursors: options.numCursors\n  }; // Do we have a readConcern specified\n\n  decorateWithReadConcern(commandObject, coll, options); // Store the raw value\n\n  const raw = options.raw;\n  delete options['raw']; // Execute the command\n\n  executeCommand(coll.s.db, commandObject, options, (err, result) => {\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, new Error('no result returned for parallelCollectionScan'), null);\n    options = Object.assign({\n      explicitlyIgnoreSession: true\n    }, options);\n    const cursors = []; // Add the raw back to the option\n\n    if (raw) options.raw = raw; // Create command cursors for each item\n\n    for (let i = 0; i < result.cursors.length; i++) {\n      const rawId = result.cursors[i].cursor.id; // Convert cursorId to Long if needed\n\n      const cursorId = typeof rawId === 'number' ? Long.fromNumber(rawId) : rawId; // Add a command cursor\n\n      cursors.push(coll.s.topology.cursor(coll.namespace, cursorId, options));\n    }\n\n    handleCallback(callback, null, cursors);\n  });\n}\n/**\n * Save a document.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} doc Document to save\n * @param {object} [options] Optional settings. See Collection.prototype.save for a list of options.\n * @param {Collection~writeOpCallback} [callback] The command result callback\n * @deprecated use insertOne, insertMany, updateOne or updateMany\n */\n\n\nfunction save(coll, doc, options, callback) {\n  // Get the write concern options\n  const finalOptions = applyWriteConcern(Object.assign({}, options), {\n    db: coll.s.db,\n    collection: coll\n  }, options); // Establish if we need to perform an insert or update\n\n  if (doc._id != null) {\n    finalOptions.upsert = true;\n    return updateDocuments(coll, {\n      _id: doc._id\n    }, doc, finalOptions, callback);\n  } // Insert the document\n\n\n  insertDocuments(coll, [doc], finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (doc == null) return handleCallback(callback, null, null);\n    if (err) return handleCallback(callback, err, null);\n    handleCallback(callback, null, result);\n  });\n}\n\nmodule.exports = {\n  createIndex,\n  createIndexes,\n  ensureIndex,\n  group,\n  indexes,\n  indexExists,\n  indexInformation,\n  parallelCollectionScan,\n  save\n};","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/operations/collection_ops.js"],"names":["applyWriteConcern","require","Code","BSON","createIndexDb","createIndex","decorateWithCollation","decorateWithReadConcern","ensureIndexDb","ensureIndex","evaluate","executeCommand","handleCallback","indexInformationDb","indexInformation","Long","MongoError","ReadPreference","insertDocuments","updateDocuments","groupFunction","coll","fieldOrSpec","options","callback","s","db","collectionName","createIndexes","indexSpecs","capabilities","topology","i","length","name","keys","collation","commandsTakeCollation","key","push","join","Object","assign","readPreference","PRIMARY","indexes","group","condition","initial","reduce","finalize","command","reduceFunction","_bsontype","selector","ns","$reduce","cond","out","$keyf","hash","forEach","resolve","err","result","retval","scope","groupfn","replace","toString","results","full","indexExists","Array","isArray","parallelCollectionScan","commandObject","numCursors","raw","Error","explicitlyIgnoreSession","cursors","rawId","cursor","id","cursorId","fromNumber","namespace","save","doc","finalOptions","collection","_id","upsert","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\nconst Code = require('../core').BSON.Code;\nconst createIndexDb = require('./db_ops').createIndex;\nconst decorateWithCollation = require('../utils').decorateWithCollation;\nconst decorateWithReadConcern = require('../utils').decorateWithReadConcern;\nconst ensureIndexDb = require('./db_ops').ensureIndex;\nconst evaluate = require('./db_ops').evaluate;\nconst executeCommand = require('./db_ops').executeCommand;\nconst handleCallback = require('../utils').handleCallback;\nconst indexInformationDb = require('./db_ops').indexInformation;\nconst Long = require('../core').BSON.Long;\nconst MongoError = require('../core').MongoError;\nconst ReadPreference = require('../core').ReadPreference;\nconst insertDocuments = require('./common_functions').insertDocuments;\nconst updateDocuments = require('./common_functions').updateDocuments;\n\n/**\n * Group function helper\n * @ignore\n */\n// var groupFunction = function () {\n//   var c = db[ns].find(condition);\n//   var map = new Map();\n//   var reduce_function = reduce;\n//\n//   while (c.hasNext()) {\n//     var obj = c.next();\n//     var key = {};\n//\n//     for (var i = 0, len = keys.length; i < len; ++i) {\n//       var k = keys[i];\n//       key[k] = obj[k];\n//     }\n//\n//     var aggObj = map.get(key);\n//\n//     if (aggObj == null) {\n//       var newObj = Object.extend({}, key);\n//       aggObj = Object.extend(newObj, initial);\n//       map.put(key, aggObj);\n//     }\n//\n//     reduce_function(obj, aggObj);\n//   }\n//\n//   return { \"result\": map.values() };\n// }.toString();\nconst groupFunction =\n  'function () {\\nvar c = db[ns].find(condition);\\nvar map = new Map();\\nvar reduce_function = reduce;\\n\\nwhile (c.hasNext()) {\\nvar obj = c.next();\\nvar key = {};\\n\\nfor (var i = 0, len = keys.length; i < len; ++i) {\\nvar k = keys[i];\\nkey[k] = obj[k];\\n}\\n\\nvar aggObj = map.get(key);\\n\\nif (aggObj == null) {\\nvar newObj = Object.extend({}, key);\\naggObj = Object.extend(newObj, initial);\\nmap.put(key, aggObj);\\n}\\n\\nreduce_function(obj, aggObj);\\n}\\n\\nreturn { \"result\": map.values() };\\n}';\n\n/**\n * Create an index on the db and collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings. See Collection.prototype.createIndex for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\nfunction createIndex(coll, fieldOrSpec, options, callback) {\n  createIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options, callback);\n}\n\n/**\n * Create multiple indexes in the collection. This method is only supported for\n * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\n * error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {array} indexSpecs An array of index specifications to be created\n * @param {Object} [options] Optional settings. See Collection.prototype.createIndexes for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\nfunction createIndexes(coll, indexSpecs, options, callback) {\n  const capabilities = coll.s.topology.capabilities();\n\n  // Ensure we generate the correct name if the parameter is not set\n  for (let i = 0; i < indexSpecs.length; i++) {\n    if (indexSpecs[i].name == null) {\n      const keys = [];\n\n      // Did the user pass in a collation, check if our write server supports it\n      if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {\n        return callback(new MongoError('server/primary/mongos does not support collation'));\n      }\n\n      for (let name in indexSpecs[i].key) {\n        keys.push(`${name}_${indexSpecs[i].key[name]}`);\n      }\n\n      // Set the name\n      indexSpecs[i].name = keys.join('_');\n    }\n  }\n\n  options = Object.assign({}, options, { readPreference: ReadPreference.PRIMARY });\n\n  // Execute the index\n  executeCommand(\n    coll.s.db,\n    {\n      createIndexes: coll.collectionName,\n      indexes: indexSpecs\n    },\n    options,\n    callback\n  );\n}\n\n/**\n * Ensure that an index exists. If the index does not exist, this function creates it.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings. See Collection.prototype.ensureIndex for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\nfunction ensureIndex(coll, fieldOrSpec, options, callback) {\n  ensureIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options, callback);\n}\n\n/**\n * Run a group command across a collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {(object|array|function|code)} keys An object, array or function expressing the keys to group by.\n * @param {object} condition An optional condition that must be true for a row to be considered.\n * @param {object} initial Initial value of the aggregation counter object.\n * @param {(function|Code)} reduce The reduce function aggregates (reduces) the objects iterated\n * @param {(function|Code)} finalize An optional function to be run on each item in the result set just before the item is returned.\n * @param {boolean} command Specify if you wish to run using the internal group command or using eval, default is true.\n * @param {object} [options] Optional settings. See Collection.prototype.group for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @deprecated MongoDB 3.6 or higher will no longer support the group command. We recommend rewriting using the aggregation framework.\n */\nfunction group(coll, keys, condition, initial, reduce, finalize, command, options, callback) {\n  // Execute using the command\n  if (command) {\n    const reduceFunction = reduce && reduce._bsontype === 'Code' ? reduce : new Code(reduce);\n\n    const selector = {\n      group: {\n        ns: coll.collectionName,\n        $reduce: reduceFunction,\n        cond: condition,\n        initial: initial,\n        out: 'inline'\n      }\n    };\n\n    // if finalize is defined\n    if (finalize != null) selector.group['finalize'] = finalize;\n    // Set up group selector\n    if ('function' === typeof keys || (keys && keys._bsontype === 'Code')) {\n      selector.group.$keyf = keys && keys._bsontype === 'Code' ? keys : new Code(keys);\n    } else {\n      const hash = {};\n      keys.forEach(key => {\n        hash[key] = 1;\n      });\n      selector.group.key = hash;\n    }\n\n    options = Object.assign({}, options);\n    // Ensure we have the right read preference inheritance\n    options.readPreference = ReadPreference.resolve(coll, options);\n\n    // Do we have a readConcern specified\n    decorateWithReadConcern(selector, coll, options);\n\n    // Have we specified collation\n    try {\n      decorateWithCollation(selector, coll, options);\n    } catch (err) {\n      return callback(err, null);\n    }\n\n    // Execute command\n    executeCommand(coll.s.db, selector, options, (err, result) => {\n      if (err) return handleCallback(callback, err, null);\n      handleCallback(callback, null, result.retval);\n    });\n  } else {\n    // Create execution scope\n    const scope = reduce != null && reduce._bsontype === 'Code' ? reduce.scope : {};\n\n    scope.ns = coll.collectionName;\n    scope.keys = keys;\n    scope.condition = condition;\n    scope.initial = initial;\n\n    // Pass in the function text to execute within mongodb.\n    const groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ';');\n\n    evaluate(coll.s.db, new Code(groupfn, scope), null, options, (err, results) => {\n      if (err) return handleCallback(callback, err, null);\n      handleCallback(callback, null, results.result || results);\n    });\n  }\n}\n\n/**\n * Retrieve all the indexes on the collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {Object} [options] Optional settings. See Collection.prototype.indexes for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\nfunction indexes(coll, options, callback) {\n  options = Object.assign({}, { full: true }, options);\n  indexInformationDb(coll.s.db, coll.collectionName, options, callback);\n}\n\n/**\n * Check if one or more indexes exist on the collection. This fails on the first index that doesn't exist.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {(string|array)} indexes One or more index names to check.\n * @param {Object} [options] Optional settings. See Collection.prototype.indexExists for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\nfunction indexExists(coll, indexes, options, callback) {\n  indexInformation(coll, options, (err, indexInformation) => {\n    // If we have an error return\n    if (err != null) return handleCallback(callback, err, null);\n    // Let's check for the index names\n    if (!Array.isArray(indexes))\n      return handleCallback(callback, null, indexInformation[indexes] != null);\n    // Check in list of indexes\n    for (let i = 0; i < indexes.length; i++) {\n      if (indexInformation[indexes[i]] == null) {\n        return handleCallback(callback, null, false);\n      }\n    }\n\n    // All keys found return true\n    return handleCallback(callback, null, true);\n  });\n}\n\n/**\n * Retrieve this collection's index info.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} [options] Optional settings. See Collection.prototype.indexInformation for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\nfunction indexInformation(coll, options, callback) {\n  indexInformationDb(coll.s.db, coll.collectionName, options, callback);\n}\n\n/**\n * Return N parallel cursors for a collection to allow parallel reading of the entire collection. There are\n * no ordering guarantees for returned results.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} [options] Optional settings. See Collection.prototype.parallelCollectionScan for a list of options.\n * @param {Collection~parallelCollectionScanCallback} [callback] The command result callback\n */\nfunction parallelCollectionScan(coll, options, callback) {\n  // Create command object\n  const commandObject = {\n    parallelCollectionScan: coll.collectionName,\n    numCursors: options.numCursors\n  };\n\n  // Do we have a readConcern specified\n  decorateWithReadConcern(commandObject, coll, options);\n\n  // Store the raw value\n  const raw = options.raw;\n  delete options['raw'];\n\n  // Execute the command\n  executeCommand(coll.s.db, commandObject, options, (err, result) => {\n    if (err) return handleCallback(callback, err, null);\n    if (result == null)\n      return handleCallback(\n        callback,\n        new Error('no result returned for parallelCollectionScan'),\n        null\n      );\n\n    options = Object.assign({ explicitlyIgnoreSession: true }, options);\n\n    const cursors = [];\n    // Add the raw back to the option\n    if (raw) options.raw = raw;\n    // Create command cursors for each item\n    for (let i = 0; i < result.cursors.length; i++) {\n      const rawId = result.cursors[i].cursor.id;\n      // Convert cursorId to Long if needed\n      const cursorId = typeof rawId === 'number' ? Long.fromNumber(rawId) : rawId;\n      // Add a command cursor\n      cursors.push(coll.s.topology.cursor(coll.namespace, cursorId, options));\n    }\n\n    handleCallback(callback, null, cursors);\n  });\n}\n\n/**\n * Save a document.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} doc Document to save\n * @param {object} [options] Optional settings. See Collection.prototype.save for a list of options.\n * @param {Collection~writeOpCallback} [callback] The command result callback\n * @deprecated use insertOne, insertMany, updateOne or updateMany\n */\nfunction save(coll, doc, options, callback) {\n  // Get the write concern options\n  const finalOptions = applyWriteConcern(\n    Object.assign({}, options),\n    { db: coll.s.db, collection: coll },\n    options\n  );\n  // Establish if we need to perform an insert or update\n  if (doc._id != null) {\n    finalOptions.upsert = true;\n    return updateDocuments(coll, { _id: doc._id }, doc, finalOptions, callback);\n  }\n\n  // Insert the document\n  insertDocuments(coll, [doc], finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (doc == null) return handleCallback(callback, null, null);\n    if (err) return handleCallback(callback, err, null);\n    handleCallback(callback, null, result);\n  });\n}\n\nmodule.exports = {\n  createIndex,\n  createIndexes,\n  ensureIndex,\n  group,\n  indexes,\n  indexExists,\n  indexInformation,\n  parallelCollectionScan,\n  save\n};\n"]},"metadata":{},"sourceType":"script"}