{"ast":null,"code":"'use strict';\n\nvar writeIEEE754 = require('../float_parser').writeIEEE754,\n    Long = require('../long').Long,\n    Map = require('../map'),\n    Binary = require('../binary').Binary;\n\nvar normalizedFunctionString = require('./utils').normalizedFunctionString; // try {\n//   var _Buffer = Uint8Array;\n// } catch (e) {\n//   _Buffer = Buffer;\n// }\n\n\nvar regexp = /\\x00/; // eslint-disable-line no-control-regex\n\nvar ignoreKeys = ['$db', '$ref', '$id', '$clusterTime']; // To ensure that 0.4 of node works correctly\n\nvar isDate = function isDate(d) {\n  return typeof d === 'object' && Object.prototype.toString.call(d) === '[object Date]';\n};\n\nvar isRegExp = function isRegExp(d) {\n  return Object.prototype.toString.call(d) === '[object RegExp]';\n};\n\nvar serializeString = function (buffer, key, value, index, isArray) {\n  // Encode String type\n  buffer[index++] = BSON.BSON_DATA_STRING; // Number of written bytes\n\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n  index = index + numberOfWrittenBytes + 1;\n  buffer[index - 1] = 0; // Write the string\n\n  var size = buffer.write(value, index + 4, 'utf8'); // Write the size of the string to buffer\n\n  buffer[index + 3] = size + 1 >> 24 & 0xff;\n  buffer[index + 2] = size + 1 >> 16 & 0xff;\n  buffer[index + 1] = size + 1 >> 8 & 0xff;\n  buffer[index] = size + 1 & 0xff; // Update index\n\n  index = index + 4 + size; // Write zero\n\n  buffer[index++] = 0;\n  return index;\n};\n\nvar serializeNumber = function (buffer, key, value, index, isArray) {\n  // We have an integer value\n  if (Math.floor(value) === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {\n    // If the value fits in 32 bits encode as int, if it fits in a double\n    // encode it as a double, otherwise long\n    if (value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX) {\n      // Set int type 32 bits or less\n      buffer[index++] = BSON.BSON_DATA_INT; // Number of written bytes\n\n      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n      index = index + numberOfWrittenBytes;\n      buffer[index++] = 0; // Write the int value\n\n      buffer[index++] = value & 0xff;\n      buffer[index++] = value >> 8 & 0xff;\n      buffer[index++] = value >> 16 & 0xff;\n      buffer[index++] = value >> 24 & 0xff;\n    } else if (value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {\n      // Encode as double\n      buffer[index++] = BSON.BSON_DATA_NUMBER; // Number of written bytes\n\n      numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n      index = index + numberOfWrittenBytes;\n      buffer[index++] = 0; // Write float\n\n      writeIEEE754(buffer, value, index, 'little', 52, 8); // Ajust index\n\n      index = index + 8;\n    } else {\n      // Set long type\n      buffer[index++] = BSON.BSON_DATA_LONG; // Number of written bytes\n\n      numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n      index = index + numberOfWrittenBytes;\n      buffer[index++] = 0;\n      var longVal = Long.fromNumber(value);\n      var lowBits = longVal.getLowBits();\n      var highBits = longVal.getHighBits(); // Encode low bits\n\n      buffer[index++] = lowBits & 0xff;\n      buffer[index++] = lowBits >> 8 & 0xff;\n      buffer[index++] = lowBits >> 16 & 0xff;\n      buffer[index++] = lowBits >> 24 & 0xff; // Encode high bits\n\n      buffer[index++] = highBits & 0xff;\n      buffer[index++] = highBits >> 8 & 0xff;\n      buffer[index++] = highBits >> 16 & 0xff;\n      buffer[index++] = highBits >> 24 & 0xff;\n    }\n  } else {\n    // Encode as double\n    buffer[index++] = BSON.BSON_DATA_NUMBER; // Number of written bytes\n\n    numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0; // Write float\n\n    writeIEEE754(buffer, value, index, 'little', 52, 8); // Ajust index\n\n    index = index + 8;\n  }\n\n  return index;\n};\n\nvar serializeNull = function (buffer, key, value, index, isArray) {\n  // Set long type\n  buffer[index++] = BSON.BSON_DATA_NULL; // Number of written bytes\n\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  return index;\n};\n\nvar serializeBoolean = function (buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_BOOLEAN; // Number of written bytes\n\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0; // Encode the boolean value\n\n  buffer[index++] = value ? 1 : 0;\n  return index;\n};\n\nvar serializeDate = function (buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_DATE; // Number of written bytes\n\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0; // Write the date\n\n  var dateInMilis = Long.fromNumber(value.getTime());\n  var lowBits = dateInMilis.getLowBits();\n  var highBits = dateInMilis.getHighBits(); // Encode low bits\n\n  buffer[index++] = lowBits & 0xff;\n  buffer[index++] = lowBits >> 8 & 0xff;\n  buffer[index++] = lowBits >> 16 & 0xff;\n  buffer[index++] = lowBits >> 24 & 0xff; // Encode high bits\n\n  buffer[index++] = highBits & 0xff;\n  buffer[index++] = highBits >> 8 & 0xff;\n  buffer[index++] = highBits >> 16 & 0xff;\n  buffer[index++] = highBits >> 24 & 0xff;\n  return index;\n};\n\nvar serializeRegExp = function (buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_REGEXP; // Number of written bytes\n\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n\n  if (value.source && value.source.match(regexp) != null) {\n    throw Error('value ' + value.source + ' must not contain null bytes');\n  } // Adjust the index\n\n\n  index = index + buffer.write(value.source, index, 'utf8'); // Write zero\n\n  buffer[index++] = 0x00; // Write the parameters\n\n  if (value.global) buffer[index++] = 0x73; // s\n\n  if (value.ignoreCase) buffer[index++] = 0x69; // i\n\n  if (value.multiline) buffer[index++] = 0x6d; // m\n  // Add ending zero\n\n  buffer[index++] = 0x00;\n  return index;\n};\n\nvar serializeBSONRegExp = function (buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_REGEXP; // Number of written bytes\n\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0; // Check the pattern for 0 bytes\n\n  if (value.pattern.match(regexp) != null) {\n    // The BSON spec doesn't allow keys with null bytes because keys are\n    // null-terminated.\n    throw Error('pattern ' + value.pattern + ' must not contain null bytes');\n  } // Adjust the index\n\n\n  index = index + buffer.write(value.pattern, index, 'utf8'); // Write zero\n\n  buffer[index++] = 0x00; // Write the options\n\n  index = index + buffer.write(value.options.split('').sort().join(''), index, 'utf8'); // Add ending zero\n\n  buffer[index++] = 0x00;\n  return index;\n};\n\nvar serializeMinMax = function (buffer, key, value, index, isArray) {\n  // Write the type of either min or max key\n  if (value === null) {\n    buffer[index++] = BSON.BSON_DATA_NULL;\n  } else if (value._bsontype === 'MinKey') {\n    buffer[index++] = BSON.BSON_DATA_MIN_KEY;\n  } else {\n    buffer[index++] = BSON.BSON_DATA_MAX_KEY;\n  } // Number of written bytes\n\n\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  return index;\n};\n\nvar serializeObjectId = function (buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_OID; // Number of written bytes\n\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0; // Write the objectId into the shared buffer\n\n  if (typeof value.id === 'string') {\n    buffer.write(value.id, index, 'binary');\n  } else if (value.id && value.id.copy) {\n    value.id.copy(buffer, index, 0, 12);\n  } else {\n    throw new Error('object [' + JSON.stringify(value) + '] is not a valid ObjectId');\n  } // Ajust index\n\n\n  return index + 12;\n};\n\nvar serializeBuffer = function (buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_BINARY; // Number of written bytes\n\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0; // Get size of the buffer (current write point)\n\n  var size = value.length; // Write the size of the string to buffer\n\n  buffer[index++] = size & 0xff;\n  buffer[index++] = size >> 8 & 0xff;\n  buffer[index++] = size >> 16 & 0xff;\n  buffer[index++] = size >> 24 & 0xff; // Write the default subtype\n\n  buffer[index++] = BSON.BSON_BINARY_SUBTYPE_DEFAULT; // Copy the content form the binary field to the buffer\n\n  value.copy(buffer, index, 0, size); // Adjust the index\n\n  index = index + size;\n  return index;\n};\n\nvar serializeObject = function (buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray, path) {\n  for (var i = 0; i < path.length; i++) {\n    if (path[i] === value) throw new Error('cyclic dependency detected');\n  } // Push value to stack\n\n\n  path.push(value); // Write the type\n\n  buffer[index++] = Array.isArray(value) ? BSON.BSON_DATA_ARRAY : BSON.BSON_DATA_OBJECT; // Number of written bytes\n\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  var endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path); // Pop stack\n\n  path.pop(); // Write size\n\n  return endIndex;\n};\n\nvar serializeDecimal128 = function (buffer, key, value, index, isArray) {\n  buffer[index++] = BSON.BSON_DATA_DECIMAL128; // Number of written bytes\n\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0; // Write the data from the value\n\n  value.bytes.copy(buffer, index, 0, 16);\n  return index + 16;\n};\n\nvar serializeLong = function (buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = value._bsontype === 'Long' ? BSON.BSON_DATA_LONG : BSON.BSON_DATA_TIMESTAMP; // Number of written bytes\n\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0; // Write the date\n\n  var lowBits = value.getLowBits();\n  var highBits = value.getHighBits(); // Encode low bits\n\n  buffer[index++] = lowBits & 0xff;\n  buffer[index++] = lowBits >> 8 & 0xff;\n  buffer[index++] = lowBits >> 16 & 0xff;\n  buffer[index++] = lowBits >> 24 & 0xff; // Encode high bits\n\n  buffer[index++] = highBits & 0xff;\n  buffer[index++] = highBits >> 8 & 0xff;\n  buffer[index++] = highBits >> 16 & 0xff;\n  buffer[index++] = highBits >> 24 & 0xff;\n  return index;\n};\n\nvar serializeInt32 = function (buffer, key, value, index, isArray) {\n  // Set int type 32 bits or less\n  buffer[index++] = BSON.BSON_DATA_INT; // Number of written bytes\n\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0; // Write the int value\n\n  buffer[index++] = value & 0xff;\n  buffer[index++] = value >> 8 & 0xff;\n  buffer[index++] = value >> 16 & 0xff;\n  buffer[index++] = value >> 24 & 0xff;\n  return index;\n};\n\nvar serializeDouble = function (buffer, key, value, index, isArray) {\n  // Encode as double\n  buffer[index++] = BSON.BSON_DATA_NUMBER; // Number of written bytes\n\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0; // Write float\n\n  writeIEEE754(buffer, value, index, 'little', 52, 8); // Ajust index\n\n  index = index + 8;\n  return index;\n};\n\nvar serializeFunction = function (buffer, key, value, index, checkKeys, depth, isArray) {\n  buffer[index++] = BSON.BSON_DATA_CODE; // Number of written bytes\n\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0; // Function string\n\n  var functionString = normalizedFunctionString(value); // Write the string\n\n  var size = buffer.write(functionString, index + 4, 'utf8') + 1; // Write the size of the string to buffer\n\n  buffer[index] = size & 0xff;\n  buffer[index + 1] = size >> 8 & 0xff;\n  buffer[index + 2] = size >> 16 & 0xff;\n  buffer[index + 3] = size >> 24 & 0xff; // Update index\n\n  index = index + 4 + size - 1; // Write zero\n\n  buffer[index++] = 0;\n  return index;\n};\n\nvar serializeCode = function (buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray) {\n  if (value.scope && typeof value.scope === 'object') {\n    // Write the type\n    buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE; // Number of written bytes\n\n    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0; // Starting index\n\n    var startIndex = index; // Serialize the function\n    // Get the function string\n\n    var functionString = typeof value.code === 'string' ? value.code : value.code.toString(); // Index adjustment\n\n    index = index + 4; // Write string into buffer\n\n    var codeSize = buffer.write(functionString, index + 4, 'utf8') + 1; // Write the size of the string to buffer\n\n    buffer[index] = codeSize & 0xff;\n    buffer[index + 1] = codeSize >> 8 & 0xff;\n    buffer[index + 2] = codeSize >> 16 & 0xff;\n    buffer[index + 3] = codeSize >> 24 & 0xff; // Write end 0\n\n    buffer[index + 4 + codeSize - 1] = 0; // Write the\n\n    index = index + codeSize + 4; //\n    // Serialize the scope value\n\n    var endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined);\n    index = endIndex - 1; // Writ the total\n\n    var totalSize = endIndex - startIndex; // Write the total size of the object\n\n    buffer[startIndex++] = totalSize & 0xff;\n    buffer[startIndex++] = totalSize >> 8 & 0xff;\n    buffer[startIndex++] = totalSize >> 16 & 0xff;\n    buffer[startIndex++] = totalSize >> 24 & 0xff; // Write trailing zero\n\n    buffer[index++] = 0;\n  } else {\n    buffer[index++] = BSON.BSON_DATA_CODE; // Number of written bytes\n\n    numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0; // Function string\n\n    functionString = value.code.toString(); // Write the string\n\n    var size = buffer.write(functionString, index + 4, 'utf8') + 1; // Write the size of the string to buffer\n\n    buffer[index] = size & 0xff;\n    buffer[index + 1] = size >> 8 & 0xff;\n    buffer[index + 2] = size >> 16 & 0xff;\n    buffer[index + 3] = size >> 24 & 0xff; // Update index\n\n    index = index + 4 + size - 1; // Write zero\n\n    buffer[index++] = 0;\n  }\n\n  return index;\n};\n\nvar serializeBinary = function (buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_BINARY; // Number of written bytes\n\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0; // Extract the buffer\n\n  var data = value.value(true); // Calculate size\n\n  var size = value.position; // Add the deprecated 02 type 4 bytes of size to total\n\n  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) size = size + 4; // Write the size of the string to buffer\n\n  buffer[index++] = size & 0xff;\n  buffer[index++] = size >> 8 & 0xff;\n  buffer[index++] = size >> 16 & 0xff;\n  buffer[index++] = size >> 24 & 0xff; // Write the subtype to the buffer\n\n  buffer[index++] = value.sub_type; // If we have binary type 2 the 4 first bytes are the size\n\n  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n    size = size - 4;\n    buffer[index++] = size & 0xff;\n    buffer[index++] = size >> 8 & 0xff;\n    buffer[index++] = size >> 16 & 0xff;\n    buffer[index++] = size >> 24 & 0xff;\n  } // Write the data to the object\n\n\n  data.copy(buffer, index, 0, value.position); // Adjust the index\n\n  index = index + value.position;\n  return index;\n};\n\nvar serializeSymbol = function (buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_SYMBOL; // Number of written bytes\n\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0; // Write the string\n\n  var size = buffer.write(value.value, index + 4, 'utf8') + 1; // Write the size of the string to buffer\n\n  buffer[index] = size & 0xff;\n  buffer[index + 1] = size >> 8 & 0xff;\n  buffer[index + 2] = size >> 16 & 0xff;\n  buffer[index + 3] = size >> 24 & 0xff; // Update index\n\n  index = index + 4 + size - 1; // Write zero\n\n  buffer[index++] = 0x00;\n  return index;\n};\n\nvar serializeDBRef = function (buffer, key, value, index, depth, serializeFunctions, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_OBJECT; // Number of written bytes\n\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii'); // Encode the name\n\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  var startIndex = index;\n  var endIndex; // Serialize object\n\n  if (null != value.db) {\n    endIndex = serializeInto(buffer, {\n      $ref: value.namespace,\n      $id: value.oid,\n      $db: value.db\n    }, false, index, depth + 1, serializeFunctions);\n  } else {\n    endIndex = serializeInto(buffer, {\n      $ref: value.namespace,\n      $id: value.oid\n    }, false, index, depth + 1, serializeFunctions);\n  } // Calculate object size\n\n\n  var size = endIndex - startIndex; // Write the size\n\n  buffer[startIndex++] = size & 0xff;\n  buffer[startIndex++] = size >> 8 & 0xff;\n  buffer[startIndex++] = size >> 16 & 0xff;\n  buffer[startIndex++] = size >> 24 & 0xff; // Set index\n\n  return endIndex;\n};\n\nvar serializeInto = function serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {\n  startingIndex = startingIndex || 0;\n  path = path || []; // Push the object to the path\n\n  path.push(object); // Start place to serialize into\n\n  var index = startingIndex + 4; // var self = this;\n  // Special case isArray\n\n  if (Array.isArray(object)) {\n    // Get object keys\n    for (var i = 0; i < object.length; i++) {\n      var key = '' + i;\n      var value = object[i]; // Is there an override value\n\n      if (value && value.toBSON) {\n        if (typeof value.toBSON !== 'function') throw new Error('toBSON is not a function');\n        value = value.toBSON();\n      }\n\n      var type = typeof value;\n\n      if (type === 'string') {\n        index = serializeString(buffer, key, value, index, true);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index, true);\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index, true);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer, key, value, index, true);\n      } else if (value === undefined) {\n        index = serializeNull(buffer, key, value, index, true);\n      } else if (value === null) {\n        index = serializeNull(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'ObjectID' || value['_bsontype'] === 'ObjectId') {\n        index = serializeObjectId(buffer, key, value, index, true);\n      } else if (Buffer.isBuffer(value)) {\n        index = serializeBuffer(buffer, key, value, index, true);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer, key, value, index, true);\n      } else if (type === 'object' && value['_bsontype'] == null) {\n        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true, path);\n      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {\n        index = serializeDecimal128(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {\n        index = serializeLong(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Double') {\n        index = serializeDouble(buffer, key, value, index, true);\n      } else if (typeof value === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions, true);\n      } else if (value['_bsontype'] === 'Code') {\n        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true);\n      } else if (value['_bsontype'] === 'Binary') {\n        index = serializeBinary(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Symbol') {\n        index = serializeSymbol(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'DBRef') {\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, true);\n      } else if (value['_bsontype'] === 'BSONRegExp') {\n        index = serializeBSONRegExp(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Int32') {\n        index = serializeInt32(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {\n        index = serializeMinMax(buffer, key, value, index, true);\n      } else if (typeof value['_bsontype'] !== 'undefined') {\n        throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);\n      }\n    }\n  } else if (object instanceof Map) {\n    var iterator = object.entries();\n    var done = false;\n\n    while (!done) {\n      // Unpack the next entry\n      var entry = iterator.next();\n      done = entry.done; // Are we done, then skip and terminate\n\n      if (done) continue; // Get the entry values\n\n      key = entry.value[0];\n      value = entry.value[1]; // Check the type of the value\n\n      type = typeof value; // Check the key and throw error if it's illegal\n\n      if (typeof key === 'string' && ignoreKeys.indexOf(key) === -1) {\n        if (key.match(regexp) != null) {\n          // The BSON spec doesn't allow keys with null bytes because keys are\n          // null-terminated.\n          throw Error('key ' + key + ' must not contain null bytes');\n        }\n\n        if (checkKeys) {\n          if ('$' === key[0]) {\n            throw Error('key ' + key + \" must not start with '$'\");\n          } else if (~key.indexOf('.')) {\n            throw Error('key ' + key + \" must not contain '.'\");\n          }\n        }\n      }\n\n      if (type === 'string') {\n        index = serializeString(buffer, key, value, index);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index);\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer, key, value, index); // } else if (value === undefined && ignoreUndefined === true) {\n      } else if (value === null || value === undefined && ignoreUndefined === false) {\n        index = serializeNull(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'ObjectID' || value['_bsontype'] === 'ObjectId') {\n        index = serializeObjectId(buffer, key, value, index);\n      } else if (Buffer.isBuffer(value)) {\n        index = serializeBuffer(buffer, key, value, index);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer, key, value, index);\n      } else if (type === 'object' && value['_bsontype'] == null) {\n        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);\n      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {\n        index = serializeDecimal128(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {\n        index = serializeLong(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Double') {\n        index = serializeDouble(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Code') {\n        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);\n      } else if (typeof value === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'Binary') {\n        index = serializeBinary(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Symbol') {\n        index = serializeSymbol(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'DBRef') {\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'BSONRegExp') {\n        index = serializeBSONRegExp(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Int32') {\n        index = serializeInt32(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {\n        index = serializeMinMax(buffer, key, value, index);\n      } else if (typeof value['_bsontype'] !== 'undefined') {\n        throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);\n      }\n    }\n  } else {\n    // Did we provide a custom serialization method\n    if (object.toBSON) {\n      if (typeof object.toBSON !== 'function') throw new Error('toBSON is not a function');\n      object = object.toBSON();\n      if (object != null && typeof object !== 'object') throw new Error('toBSON function did not return an object');\n    } // Iterate over all the keys\n\n\n    for (key in object) {\n      value = object[key]; // Is there an override value\n\n      if (value && value.toBSON) {\n        if (typeof value.toBSON !== 'function') throw new Error('toBSON is not a function');\n        value = value.toBSON();\n      } // Check the type of the value\n\n\n      type = typeof value; // Check the key and throw error if it's illegal\n\n      if (typeof key === 'string' && ignoreKeys.indexOf(key) === -1) {\n        if (key.match(regexp) != null) {\n          // The BSON spec doesn't allow keys with null bytes because keys are\n          // null-terminated.\n          throw Error('key ' + key + ' must not contain null bytes');\n        }\n\n        if (checkKeys) {\n          if ('$' === key[0]) {\n            throw Error('key ' + key + \" must not start with '$'\");\n          } else if (~key.indexOf('.')) {\n            throw Error('key ' + key + \" must not contain '.'\");\n          }\n        }\n      }\n\n      if (type === 'string') {\n        index = serializeString(buffer, key, value, index);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index);\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer, key, value, index);\n      } else if (value === undefined) {\n        if (ignoreUndefined === false) index = serializeNull(buffer, key, value, index);\n      } else if (value === null) {\n        index = serializeNull(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'ObjectID' || value['_bsontype'] === 'ObjectId') {\n        index = serializeObjectId(buffer, key, value, index);\n      } else if (Buffer.isBuffer(value)) {\n        index = serializeBuffer(buffer, key, value, index);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer, key, value, index);\n      } else if (type === 'object' && value['_bsontype'] == null) {\n        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);\n      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {\n        index = serializeDecimal128(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {\n        index = serializeLong(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Double') {\n        index = serializeDouble(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Code') {\n        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);\n      } else if (typeof value === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'Binary') {\n        index = serializeBinary(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Symbol') {\n        index = serializeSymbol(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'DBRef') {\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'BSONRegExp') {\n        index = serializeBSONRegExp(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Int32') {\n        index = serializeInt32(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {\n        index = serializeMinMax(buffer, key, value, index);\n      } else if (typeof value['_bsontype'] !== 'undefined') {\n        throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);\n      }\n    }\n  } // Remove the path\n\n\n  path.pop(); // Final padding byte for object\n\n  buffer[index++] = 0x00; // Final size\n\n  var size = index - startingIndex; // Write the size of the object\n\n  buffer[startingIndex++] = size & 0xff;\n  buffer[startingIndex++] = size >> 8 & 0xff;\n  buffer[startingIndex++] = size >> 16 & 0xff;\n  buffer[startingIndex++] = size >> 24 & 0xff;\n  return index;\n};\n\nvar BSON = {};\n/**\n * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5\n *\n * @ignore\n * @api private\n */\n// var functionCache = (BSON.functionCache = {});\n\n/**\n * Number BSON Type\n *\n * @classconstant BSON_DATA_NUMBER\n **/\n\nBSON.BSON_DATA_NUMBER = 1;\n/**\n * String BSON Type\n *\n * @classconstant BSON_DATA_STRING\n **/\n\nBSON.BSON_DATA_STRING = 2;\n/**\n * Object BSON Type\n *\n * @classconstant BSON_DATA_OBJECT\n **/\n\nBSON.BSON_DATA_OBJECT = 3;\n/**\n * Array BSON Type\n *\n * @classconstant BSON_DATA_ARRAY\n **/\n\nBSON.BSON_DATA_ARRAY = 4;\n/**\n * Binary BSON Type\n *\n * @classconstant BSON_DATA_BINARY\n **/\n\nBSON.BSON_DATA_BINARY = 5;\n/**\n * ObjectID BSON Type, deprecated\n *\n * @classconstant BSON_DATA_UNDEFINED\n **/\n\nBSON.BSON_DATA_UNDEFINED = 6;\n/**\n * ObjectID BSON Type\n *\n * @classconstant BSON_DATA_OID\n **/\n\nBSON.BSON_DATA_OID = 7;\n/**\n * Boolean BSON Type\n *\n * @classconstant BSON_DATA_BOOLEAN\n **/\n\nBSON.BSON_DATA_BOOLEAN = 8;\n/**\n * Date BSON Type\n *\n * @classconstant BSON_DATA_DATE\n **/\n\nBSON.BSON_DATA_DATE = 9;\n/**\n * null BSON Type\n *\n * @classconstant BSON_DATA_NULL\n **/\n\nBSON.BSON_DATA_NULL = 10;\n/**\n * RegExp BSON Type\n *\n * @classconstant BSON_DATA_REGEXP\n **/\n\nBSON.BSON_DATA_REGEXP = 11;\n/**\n * Code BSON Type\n *\n * @classconstant BSON_DATA_CODE\n **/\n\nBSON.BSON_DATA_CODE = 13;\n/**\n * Symbol BSON Type\n *\n * @classconstant BSON_DATA_SYMBOL\n **/\n\nBSON.BSON_DATA_SYMBOL = 14;\n/**\n * Code with Scope BSON Type\n *\n * @classconstant BSON_DATA_CODE_W_SCOPE\n **/\n\nBSON.BSON_DATA_CODE_W_SCOPE = 15;\n/**\n * 32 bit Integer BSON Type\n *\n * @classconstant BSON_DATA_INT\n **/\n\nBSON.BSON_DATA_INT = 16;\n/**\n * Timestamp BSON Type\n *\n * @classconstant BSON_DATA_TIMESTAMP\n **/\n\nBSON.BSON_DATA_TIMESTAMP = 17;\n/**\n * Long BSON Type\n *\n * @classconstant BSON_DATA_LONG\n **/\n\nBSON.BSON_DATA_LONG = 18;\n/**\n * Long BSON Type\n *\n * @classconstant BSON_DATA_DECIMAL128\n **/\n\nBSON.BSON_DATA_DECIMAL128 = 19;\n/**\n * MinKey BSON Type\n *\n * @classconstant BSON_DATA_MIN_KEY\n **/\n\nBSON.BSON_DATA_MIN_KEY = 0xff;\n/**\n * MaxKey BSON Type\n *\n * @classconstant BSON_DATA_MAX_KEY\n **/\n\nBSON.BSON_DATA_MAX_KEY = 0x7f;\n/**\n * Binary Default Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_DEFAULT\n **/\n\nBSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;\n/**\n * Binary Function Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_FUNCTION\n **/\n\nBSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;\n/**\n * Binary Byte Array Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY\n **/\n\nBSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;\n/**\n * Binary UUID Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_UUID\n **/\n\nBSON.BSON_BINARY_SUBTYPE_UUID = 3;\n/**\n * Binary MD5 Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_MD5\n **/\n\nBSON.BSON_BINARY_SUBTYPE_MD5 = 4;\n/**\n * Binary User Defined Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED\n **/\n\nBSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128; // BSON MAX VALUES\n\nBSON.BSON_INT32_MAX = 0x7fffffff;\nBSON.BSON_INT32_MIN = -0x80000000;\nBSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;\nBSON.BSON_INT64_MIN = -Math.pow(2, 63); // JS MAX PRECISE VALUES\n\nBSON.JS_INT_MAX = 0x20000000000000; // Any integer up to 2^53 can be precisely represented by a double.\n\nBSON.JS_INT_MIN = -0x20000000000000; // Any integer down to -2^53 can be precisely represented by a double.\n// Internal long versions\n// var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000); // Any integer up to 2^53 can be precisely represented by a double.\n// var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000); // Any integer down to -2^53 can be precisely represented by a double.\n\nmodule.exports = serializeInto;","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/bson/lib/bson/parser/serializer.js"],"names":["writeIEEE754","require","Long","Map","Binary","normalizedFunctionString","regexp","ignoreKeys","isDate","d","Object","prototype","toString","call","isRegExp","serializeString","buffer","key","value","index","isArray","BSON","BSON_DATA_STRING","numberOfWrittenBytes","write","size","serializeNumber","Math","floor","JS_INT_MIN","JS_INT_MAX","BSON_INT32_MIN","BSON_INT32_MAX","BSON_DATA_INT","BSON_DATA_NUMBER","BSON_DATA_LONG","longVal","fromNumber","lowBits","getLowBits","highBits","getHighBits","serializeNull","BSON_DATA_NULL","serializeBoolean","BSON_DATA_BOOLEAN","serializeDate","BSON_DATA_DATE","dateInMilis","getTime","serializeRegExp","BSON_DATA_REGEXP","source","match","Error","global","ignoreCase","multiline","serializeBSONRegExp","pattern","options","split","sort","join","serializeMinMax","_bsontype","BSON_DATA_MIN_KEY","BSON_DATA_MAX_KEY","serializeObjectId","BSON_DATA_OID","id","copy","JSON","stringify","serializeBuffer","BSON_DATA_BINARY","length","BSON_BINARY_SUBTYPE_DEFAULT","serializeObject","checkKeys","depth","serializeFunctions","ignoreUndefined","path","i","push","Array","BSON_DATA_ARRAY","BSON_DATA_OBJECT","endIndex","serializeInto","pop","serializeDecimal128","BSON_DATA_DECIMAL128","bytes","serializeLong","BSON_DATA_TIMESTAMP","serializeInt32","serializeDouble","serializeFunction","BSON_DATA_CODE","functionString","serializeCode","scope","BSON_DATA_CODE_W_SCOPE","startIndex","code","codeSize","totalSize","serializeBinary","data","position","sub_type","SUBTYPE_BYTE_ARRAY","serializeSymbol","BSON_DATA_SYMBOL","serializeDBRef","db","$ref","namespace","$id","oid","$db","object","startingIndex","toBSON","type","Date","undefined","Buffer","isBuffer","RegExp","TypeError","iterator","entries","done","entry","next","indexOf","BSON_DATA_UNDEFINED","BSON_BINARY_SUBTYPE_FUNCTION","BSON_BINARY_SUBTYPE_BYTE_ARRAY","BSON_BINARY_SUBTYPE_UUID","BSON_BINARY_SUBTYPE_MD5","BSON_BINARY_SUBTYPE_USER_DEFINED","BSON_INT64_MAX","pow","BSON_INT64_MIN","module","exports"],"mappings":"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G,IAAI,IAAI,CAAT,GAAc,IAAxC;AACAT,EAAAA,MAAM,CAAC4G,aAAa,EAAd,CAAN,GAA2BnG,IAAI,IAAI,EAAT,GAAe,IAAzC;AACAT,EAAAA,MAAM,CAAC4G,aAAa,EAAd,CAAN,GAA2BnG,IAAI,IAAI,EAAT,GAAe,IAAzC;AACA,SAAON,KAAP;AACD,CA1UD;;AA4UA,IAAIE,IAAI,GAAG,EAAX;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACAA,IAAI,CAACa,gBAAL,GAAwB,CAAxB;AACA;AACA;AACA;AACA;AACA;;AACAb,IAAI,CAACC,gBAAL,GAAwB,CAAxB;AACA;AACA;AACA;AACA;AACA;;AACAD,IAAI,CAACmE,gBAAL,GAAwB,CAAxB;AACA;AACA;AACA;AACA;AACA;;AACAnE,IAAI,CAACkE,eAAL,GAAuB,CAAvB;AACA;AACA;AACA;AACA;AACA;;AACAlE,IAAI,CAACsD,gBAAL,GAAwB,CAAxB;AACA;AACA;AACA;AACA;AACA;;AACAtD,IAAI,CAACsH,mBAAL,GAA2B,CAA3B;AACA;AACA;AACA;AACA;AACA;;AACAtH,IAAI,CAACgD,aAAL,GAAqB,CAArB;AACA;AACA;AACA;AACA;AACA;;AACAhD,IAAI,CAACwB,iBAAL,GAAyB,CAAzB;AACA;AACA;AACA;AACA;AACA;;AACAxB,IAAI,CAAC0B,cAAL,GAAsB,CAAtB;AACA;AACA;AACA;AACA;AACA;;AACA1B,IAAI,CAACsB,cAAL,GAAsB,EAAtB;AACA;AACA;AACA;AACA;AACA;;AACAtB,IAAI,CAAC8B,gBAAL,GAAwB,EAAxB;AACA;AACA;AACA;AACA;AACA;;AACA9B,IAAI,CAAC+E,cAAL,GAAsB,EAAtB;AACA;AACA;AACA;AACA;AACA;;AACA/E,IAAI,CAAC8F,gBAAL,GAAwB,EAAxB;AACA;AACA;AACA;AACA;AACA;;AACA9F,IAAI,CAACmF,sBAAL,GAA8B,EAA9B;AACA;AACA;AACA;AACA;AACA;;AACAnF,IAAI,CAACY,aAAL,GAAqB,EAArB;AACA;AACA;AACA;AACA;AACA;;AACAZ,IAAI,CAAC2E,mBAAL,GAA2B,EAA3B;AACA;AACA;AACA;AACA;AACA;;AACA3E,IAAI,CAACc,cAAL,GAAsB,EAAtB;AACA;AACA;AACA;AACA;AACA;;AACAd,IAAI,CAACwE,oBAAL,GAA4B,EAA5B;AACA;AACA;AACA;AACA;AACA;;AACAxE,IAAI,CAAC6C,iBAAL,GAAyB,IAAzB;AACA;AACA;AACA;AACA;AACA;;AACA7C,IAAI,CAAC8C,iBAAL,GAAyB,IAAzB;AACA;AACA;AACA;AACA;AACA;;AACA9C,IAAI,CAACwD,2BAAL,GAAmC,CAAnC;AACA;AACA;AACA;AACA;AACA;;AACAxD,IAAI,CAACuH,4BAAL,GAAoC,CAApC;AACA;AACA;AACA;AACA;AACA;;AACAvH,IAAI,CAACwH,8BAAL,GAAsC,CAAtC;AACA;AACA;AACA;AACA;AACA;;AACAxH,IAAI,CAACyH,wBAAL,GAAgC,CAAhC;AACA;AACA;AACA;AACA;AACA;;AACAzH,IAAI,CAAC0H,uBAAL,GAA+B,CAA/B;AACA;AACA;AACA;AACA;AACA;;AACA1H,IAAI,CAAC2H,gCAAL,GAAwC,GAAxC,C,CAEA;;AACA3H,IAAI,CAACW,cAAL,GAAsB,UAAtB;AACAX,IAAI,CAACU,cAAL,GAAsB,CAAC,UAAvB;AAEAV,IAAI,CAAC4H,cAAL,GAAsBtH,IAAI,CAACuH,GAAL,CAAS,CAAT,EAAY,EAAZ,IAAkB,CAAxC;AACA7H,IAAI,CAAC8H,cAAL,GAAsB,CAACxH,IAAI,CAACuH,GAAL,CAAS,CAAT,EAAY,EAAZ,CAAvB,C,CAEA;;AACA7H,IAAI,CAACS,UAAL,GAAkB,gBAAlB,C,CAAoC;;AACpCT,IAAI,CAACQ,UAAL,GAAkB,CAAC,gBAAnB,C,CAAqC;AAErC;AACA;AACA;;AAEAuH,MAAM,CAACC,OAAP,GAAiB3D,aAAjB","sourcesContent":["'use strict';\n\nvar writeIEEE754 = require('../float_parser').writeIEEE754,\n  Long = require('../long').Long,\n  Map = require('../map'),\n  Binary = require('../binary').Binary;\n\nvar normalizedFunctionString = require('./utils').normalizedFunctionString;\n\n// try {\n//   var _Buffer = Uint8Array;\n// } catch (e) {\n//   _Buffer = Buffer;\n// }\n\nvar regexp = /\\x00/; // eslint-disable-line no-control-regex\nvar ignoreKeys = ['$db', '$ref', '$id', '$clusterTime'];\n\n// To ensure that 0.4 of node works correctly\nvar isDate = function isDate(d) {\n  return typeof d === 'object' && Object.prototype.toString.call(d) === '[object Date]';\n};\n\nvar isRegExp = function isRegExp(d) {\n  return Object.prototype.toString.call(d) === '[object RegExp]';\n};\n\nvar serializeString = function(buffer, key, value, index, isArray) {\n  // Encode String type\n  buffer[index++] = BSON.BSON_DATA_STRING;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes + 1;\n  buffer[index - 1] = 0;\n  // Write the string\n  var size = buffer.write(value, index + 4, 'utf8');\n  // Write the size of the string to buffer\n  buffer[index + 3] = ((size + 1) >> 24) & 0xff;\n  buffer[index + 2] = ((size + 1) >> 16) & 0xff;\n  buffer[index + 1] = ((size + 1) >> 8) & 0xff;\n  buffer[index] = (size + 1) & 0xff;\n  // Update index\n  index = index + 4 + size;\n  // Write zero\n  buffer[index++] = 0;\n  return index;\n};\n\nvar serializeNumber = function(buffer, key, value, index, isArray) {\n  // We have an integer value\n  if (Math.floor(value) === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {\n    // If the value fits in 32 bits encode as int, if it fits in a double\n    // encode it as a double, otherwise long\n    if (value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX) {\n      // Set int type 32 bits or less\n      buffer[index++] = BSON.BSON_DATA_INT;\n      // Number of written bytes\n      var numberOfWrittenBytes = !isArray\n        ? buffer.write(key, index, 'utf8')\n        : buffer.write(key, index, 'ascii');\n      // Encode the name\n      index = index + numberOfWrittenBytes;\n      buffer[index++] = 0;\n      // Write the int value\n      buffer[index++] = value & 0xff;\n      buffer[index++] = (value >> 8) & 0xff;\n      buffer[index++] = (value >> 16) & 0xff;\n      buffer[index++] = (value >> 24) & 0xff;\n    } else if (value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {\n      // Encode as double\n      buffer[index++] = BSON.BSON_DATA_NUMBER;\n      // Number of written bytes\n      numberOfWrittenBytes = !isArray\n        ? buffer.write(key, index, 'utf8')\n        : buffer.write(key, index, 'ascii');\n      // Encode the name\n      index = index + numberOfWrittenBytes;\n      buffer[index++] = 0;\n      // Write float\n      writeIEEE754(buffer, value, index, 'little', 52, 8);\n      // Ajust index\n      index = index + 8;\n    } else {\n      // Set long type\n      buffer[index++] = BSON.BSON_DATA_LONG;\n      // Number of written bytes\n      numberOfWrittenBytes = !isArray\n        ? buffer.write(key, index, 'utf8')\n        : buffer.write(key, index, 'ascii');\n      // Encode the name\n      index = index + numberOfWrittenBytes;\n      buffer[index++] = 0;\n      var longVal = Long.fromNumber(value);\n      var lowBits = longVal.getLowBits();\n      var highBits = longVal.getHighBits();\n      // Encode low bits\n      buffer[index++] = lowBits & 0xff;\n      buffer[index++] = (lowBits >> 8) & 0xff;\n      buffer[index++] = (lowBits >> 16) & 0xff;\n      buffer[index++] = (lowBits >> 24) & 0xff;\n      // Encode high bits\n      buffer[index++] = highBits & 0xff;\n      buffer[index++] = (highBits >> 8) & 0xff;\n      buffer[index++] = (highBits >> 16) & 0xff;\n      buffer[index++] = (highBits >> 24) & 0xff;\n    }\n  } else {\n    // Encode as double\n    buffer[index++] = BSON.BSON_DATA_NUMBER;\n    // Number of written bytes\n    numberOfWrittenBytes = !isArray\n      ? buffer.write(key, index, 'utf8')\n      : buffer.write(key, index, 'ascii');\n    // Encode the name\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    // Write float\n    writeIEEE754(buffer, value, index, 'little', 52, 8);\n    // Ajust index\n    index = index + 8;\n  }\n\n  return index;\n};\n\nvar serializeNull = function(buffer, key, value, index, isArray) {\n  // Set long type\n  buffer[index++] = BSON.BSON_DATA_NULL;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  return index;\n};\n\nvar serializeBoolean = function(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_BOOLEAN;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Encode the boolean value\n  buffer[index++] = value ? 1 : 0;\n  return index;\n};\n\nvar serializeDate = function(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_DATE;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n\n  // Write the date\n  var dateInMilis = Long.fromNumber(value.getTime());\n  var lowBits = dateInMilis.getLowBits();\n  var highBits = dateInMilis.getHighBits();\n  // Encode low bits\n  buffer[index++] = lowBits & 0xff;\n  buffer[index++] = (lowBits >> 8) & 0xff;\n  buffer[index++] = (lowBits >> 16) & 0xff;\n  buffer[index++] = (lowBits >> 24) & 0xff;\n  // Encode high bits\n  buffer[index++] = highBits & 0xff;\n  buffer[index++] = (highBits >> 8) & 0xff;\n  buffer[index++] = (highBits >> 16) & 0xff;\n  buffer[index++] = (highBits >> 24) & 0xff;\n  return index;\n};\n\nvar serializeRegExp = function(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_REGEXP;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  if (value.source && value.source.match(regexp) != null) {\n    throw Error('value ' + value.source + ' must not contain null bytes');\n  }\n  // Adjust the index\n  index = index + buffer.write(value.source, index, 'utf8');\n  // Write zero\n  buffer[index++] = 0x00;\n  // Write the parameters\n  if (value.global) buffer[index++] = 0x73; // s\n  if (value.ignoreCase) buffer[index++] = 0x69; // i\n  if (value.multiline) buffer[index++] = 0x6d; // m\n  // Add ending zero\n  buffer[index++] = 0x00;\n  return index;\n};\n\nvar serializeBSONRegExp = function(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_REGEXP;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n\n  // Check the pattern for 0 bytes\n  if (value.pattern.match(regexp) != null) {\n    // The BSON spec doesn't allow keys with null bytes because keys are\n    // null-terminated.\n    throw Error('pattern ' + value.pattern + ' must not contain null bytes');\n  }\n\n  // Adjust the index\n  index = index + buffer.write(value.pattern, index, 'utf8');\n  // Write zero\n  buffer[index++] = 0x00;\n  // Write the options\n  index =\n    index +\n    buffer.write(\n      value.options\n        .split('')\n        .sort()\n        .join(''),\n      index,\n      'utf8'\n    );\n  // Add ending zero\n  buffer[index++] = 0x00;\n  return index;\n};\n\nvar serializeMinMax = function(buffer, key, value, index, isArray) {\n  // Write the type of either min or max key\n  if (value === null) {\n    buffer[index++] = BSON.BSON_DATA_NULL;\n  } else if (value._bsontype === 'MinKey') {\n    buffer[index++] = BSON.BSON_DATA_MIN_KEY;\n  } else {\n    buffer[index++] = BSON.BSON_DATA_MAX_KEY;\n  }\n\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  return index;\n};\n\nvar serializeObjectId = function(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_OID;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n\n  // Write the objectId into the shared buffer\n  if (typeof value.id === 'string') {\n    buffer.write(value.id, index, 'binary');\n  } else if (value.id && value.id.copy) {\n    value.id.copy(buffer, index, 0, 12);\n  } else {\n    throw new Error('object [' + JSON.stringify(value) + '] is not a valid ObjectId');\n  }\n\n  // Ajust index\n  return index + 12;\n};\n\nvar serializeBuffer = function(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_BINARY;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Get size of the buffer (current write point)\n  var size = value.length;\n  // Write the size of the string to buffer\n  buffer[index++] = size & 0xff;\n  buffer[index++] = (size >> 8) & 0xff;\n  buffer[index++] = (size >> 16) & 0xff;\n  buffer[index++] = (size >> 24) & 0xff;\n  // Write the default subtype\n  buffer[index++] = BSON.BSON_BINARY_SUBTYPE_DEFAULT;\n  // Copy the content form the binary field to the buffer\n  value.copy(buffer, index, 0, size);\n  // Adjust the index\n  index = index + size;\n  return index;\n};\n\nvar serializeObject = function(\n  buffer,\n  key,\n  value,\n  index,\n  checkKeys,\n  depth,\n  serializeFunctions,\n  ignoreUndefined,\n  isArray,\n  path\n) {\n  for (var i = 0; i < path.length; i++) {\n    if (path[i] === value) throw new Error('cyclic dependency detected');\n  }\n\n  // Push value to stack\n  path.push(value);\n  // Write the type\n  buffer[index++] = Array.isArray(value) ? BSON.BSON_DATA_ARRAY : BSON.BSON_DATA_OBJECT;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  var endIndex = serializeInto(\n    buffer,\n    value,\n    checkKeys,\n    index,\n    depth + 1,\n    serializeFunctions,\n    ignoreUndefined,\n    path\n  );\n  // Pop stack\n  path.pop();\n  // Write size\n  return endIndex;\n};\n\nvar serializeDecimal128 = function(buffer, key, value, index, isArray) {\n  buffer[index++] = BSON.BSON_DATA_DECIMAL128;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the data from the value\n  value.bytes.copy(buffer, index, 0, 16);\n  return index + 16;\n};\n\nvar serializeLong = function(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = value._bsontype === 'Long' ? BSON.BSON_DATA_LONG : BSON.BSON_DATA_TIMESTAMP;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the date\n  var lowBits = value.getLowBits();\n  var highBits = value.getHighBits();\n  // Encode low bits\n  buffer[index++] = lowBits & 0xff;\n  buffer[index++] = (lowBits >> 8) & 0xff;\n  buffer[index++] = (lowBits >> 16) & 0xff;\n  buffer[index++] = (lowBits >> 24) & 0xff;\n  // Encode high bits\n  buffer[index++] = highBits & 0xff;\n  buffer[index++] = (highBits >> 8) & 0xff;\n  buffer[index++] = (highBits >> 16) & 0xff;\n  buffer[index++] = (highBits >> 24) & 0xff;\n  return index;\n};\n\nvar serializeInt32 = function(buffer, key, value, index, isArray) {\n  // Set int type 32 bits or less\n  buffer[index++] = BSON.BSON_DATA_INT;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the int value\n  buffer[index++] = value & 0xff;\n  buffer[index++] = (value >> 8) & 0xff;\n  buffer[index++] = (value >> 16) & 0xff;\n  buffer[index++] = (value >> 24) & 0xff;\n  return index;\n};\n\nvar serializeDouble = function(buffer, key, value, index, isArray) {\n  // Encode as double\n  buffer[index++] = BSON.BSON_DATA_NUMBER;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write float\n  writeIEEE754(buffer, value, index, 'little', 52, 8);\n  // Ajust index\n  index = index + 8;\n  return index;\n};\n\nvar serializeFunction = function(buffer, key, value, index, checkKeys, depth, isArray) {\n  buffer[index++] = BSON.BSON_DATA_CODE;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Function string\n  var functionString = normalizedFunctionString(value);\n\n  // Write the string\n  var size = buffer.write(functionString, index + 4, 'utf8') + 1;\n  // Write the size of the string to buffer\n  buffer[index] = size & 0xff;\n  buffer[index + 1] = (size >> 8) & 0xff;\n  buffer[index + 2] = (size >> 16) & 0xff;\n  buffer[index + 3] = (size >> 24) & 0xff;\n  // Update index\n  index = index + 4 + size - 1;\n  // Write zero\n  buffer[index++] = 0;\n  return index;\n};\n\nvar serializeCode = function(\n  buffer,\n  key,\n  value,\n  index,\n  checkKeys,\n  depth,\n  serializeFunctions,\n  ignoreUndefined,\n  isArray\n) {\n  if (value.scope && typeof value.scope === 'object') {\n    // Write the type\n    buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE;\n    // Number of written bytes\n    var numberOfWrittenBytes = !isArray\n      ? buffer.write(key, index, 'utf8')\n      : buffer.write(key, index, 'ascii');\n    // Encode the name\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n\n    // Starting index\n    var startIndex = index;\n\n    // Serialize the function\n    // Get the function string\n    var functionString = typeof value.code === 'string' ? value.code : value.code.toString();\n    // Index adjustment\n    index = index + 4;\n    // Write string into buffer\n    var codeSize = buffer.write(functionString, index + 4, 'utf8') + 1;\n    // Write the size of the string to buffer\n    buffer[index] = codeSize & 0xff;\n    buffer[index + 1] = (codeSize >> 8) & 0xff;\n    buffer[index + 2] = (codeSize >> 16) & 0xff;\n    buffer[index + 3] = (codeSize >> 24) & 0xff;\n    // Write end 0\n    buffer[index + 4 + codeSize - 1] = 0;\n    // Write the\n    index = index + codeSize + 4;\n\n    //\n    // Serialize the scope value\n    var endIndex = serializeInto(\n      buffer,\n      value.scope,\n      checkKeys,\n      index,\n      depth + 1,\n      serializeFunctions,\n      ignoreUndefined\n    );\n    index = endIndex - 1;\n\n    // Writ the total\n    var totalSize = endIndex - startIndex;\n\n    // Write the total size of the object\n    buffer[startIndex++] = totalSize & 0xff;\n    buffer[startIndex++] = (totalSize >> 8) & 0xff;\n    buffer[startIndex++] = (totalSize >> 16) & 0xff;\n    buffer[startIndex++] = (totalSize >> 24) & 0xff;\n    // Write trailing zero\n    buffer[index++] = 0;\n  } else {\n    buffer[index++] = BSON.BSON_DATA_CODE;\n    // Number of written bytes\n    numberOfWrittenBytes = !isArray\n      ? buffer.write(key, index, 'utf8')\n      : buffer.write(key, index, 'ascii');\n    // Encode the name\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    // Function string\n    functionString = value.code.toString();\n    // Write the string\n    var size = buffer.write(functionString, index + 4, 'utf8') + 1;\n    // Write the size of the string to buffer\n    buffer[index] = size & 0xff;\n    buffer[index + 1] = (size >> 8) & 0xff;\n    buffer[index + 2] = (size >> 16) & 0xff;\n    buffer[index + 3] = (size >> 24) & 0xff;\n    // Update index\n    index = index + 4 + size - 1;\n    // Write zero\n    buffer[index++] = 0;\n  }\n\n  return index;\n};\n\nvar serializeBinary = function(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_BINARY;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Extract the buffer\n  var data = value.value(true);\n  // Calculate size\n  var size = value.position;\n  // Add the deprecated 02 type 4 bytes of size to total\n  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) size = size + 4;\n  // Write the size of the string to buffer\n  buffer[index++] = size & 0xff;\n  buffer[index++] = (size >> 8) & 0xff;\n  buffer[index++] = (size >> 16) & 0xff;\n  buffer[index++] = (size >> 24) & 0xff;\n  // Write the subtype to the buffer\n  buffer[index++] = value.sub_type;\n\n  // If we have binary type 2 the 4 first bytes are the size\n  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n    size = size - 4;\n    buffer[index++] = size & 0xff;\n    buffer[index++] = (size >> 8) & 0xff;\n    buffer[index++] = (size >> 16) & 0xff;\n    buffer[index++] = (size >> 24) & 0xff;\n  }\n\n  // Write the data to the object\n  data.copy(buffer, index, 0, value.position);\n  // Adjust the index\n  index = index + value.position;\n  return index;\n};\n\nvar serializeSymbol = function(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_SYMBOL;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the string\n  var size = buffer.write(value.value, index + 4, 'utf8') + 1;\n  // Write the size of the string to buffer\n  buffer[index] = size & 0xff;\n  buffer[index + 1] = (size >> 8) & 0xff;\n  buffer[index + 2] = (size >> 16) & 0xff;\n  buffer[index + 3] = (size >> 24) & 0xff;\n  // Update index\n  index = index + 4 + size - 1;\n  // Write zero\n  buffer[index++] = 0x00;\n  return index;\n};\n\nvar serializeDBRef = function(buffer, key, value, index, depth, serializeFunctions, isArray) {\n  // Write the type\n  buffer[index++] = BSON.BSON_DATA_OBJECT;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray\n    ? buffer.write(key, index, 'utf8')\n    : buffer.write(key, index, 'ascii');\n\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n\n  var startIndex = index;\n  var endIndex;\n\n  // Serialize object\n  if (null != value.db) {\n    endIndex = serializeInto(\n      buffer,\n      {\n        $ref: value.namespace,\n        $id: value.oid,\n        $db: value.db\n      },\n      false,\n      index,\n      depth + 1,\n      serializeFunctions\n    );\n  } else {\n    endIndex = serializeInto(\n      buffer,\n      {\n        $ref: value.namespace,\n        $id: value.oid\n      },\n      false,\n      index,\n      depth + 1,\n      serializeFunctions\n    );\n  }\n\n  // Calculate object size\n  var size = endIndex - startIndex;\n  // Write the size\n  buffer[startIndex++] = size & 0xff;\n  buffer[startIndex++] = (size >> 8) & 0xff;\n  buffer[startIndex++] = (size >> 16) & 0xff;\n  buffer[startIndex++] = (size >> 24) & 0xff;\n  // Set index\n  return endIndex;\n};\n\nvar serializeInto = function serializeInto(\n  buffer,\n  object,\n  checkKeys,\n  startingIndex,\n  depth,\n  serializeFunctions,\n  ignoreUndefined,\n  path\n) {\n  startingIndex = startingIndex || 0;\n  path = path || [];\n\n  // Push the object to the path\n  path.push(object);\n\n  // Start place to serialize into\n  var index = startingIndex + 4;\n  // var self = this;\n\n  // Special case isArray\n  if (Array.isArray(object)) {\n    // Get object keys\n    for (var i = 0; i < object.length; i++) {\n      var key = '' + i;\n      var value = object[i];\n\n      // Is there an override value\n      if (value && value.toBSON) {\n        if (typeof value.toBSON !== 'function') throw new Error('toBSON is not a function');\n        value = value.toBSON();\n      }\n\n      var type = typeof value;\n      if (type === 'string') {\n        index = serializeString(buffer, key, value, index, true);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index, true);\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index, true);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer, key, value, index, true);\n      } else if (value === undefined) {\n        index = serializeNull(buffer, key, value, index, true);\n      } else if (value === null) {\n        index = serializeNull(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'ObjectID' || value['_bsontype'] === 'ObjectId') {\n        index = serializeObjectId(buffer, key, value, index, true);\n      } else if (Buffer.isBuffer(value)) {\n        index = serializeBuffer(buffer, key, value, index, true);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer, key, value, index, true);\n      } else if (type === 'object' && value['_bsontype'] == null) {\n        index = serializeObject(\n          buffer,\n          key,\n          value,\n          index,\n          checkKeys,\n          depth,\n          serializeFunctions,\n          ignoreUndefined,\n          true,\n          path\n        );\n      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {\n        index = serializeDecimal128(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {\n        index = serializeLong(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Double') {\n        index = serializeDouble(buffer, key, value, index, true);\n      } else if (typeof value === 'function' && serializeFunctions) {\n        index = serializeFunction(\n          buffer,\n          key,\n          value,\n          index,\n          checkKeys,\n          depth,\n          serializeFunctions,\n          true\n        );\n      } else if (value['_bsontype'] === 'Code') {\n        index = serializeCode(\n          buffer,\n          key,\n          value,\n          index,\n          checkKeys,\n          depth,\n          serializeFunctions,\n          ignoreUndefined,\n          true\n        );\n      } else if (value['_bsontype'] === 'Binary') {\n        index = serializeBinary(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Symbol') {\n        index = serializeSymbol(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'DBRef') {\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, true);\n      } else if (value['_bsontype'] === 'BSONRegExp') {\n        index = serializeBSONRegExp(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Int32') {\n        index = serializeInt32(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {\n        index = serializeMinMax(buffer, key, value, index, true);\n      } else if (typeof value['_bsontype'] !== 'undefined') {\n        throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);\n      }\n    }\n  } else if (object instanceof Map) {\n    var iterator = object.entries();\n    var done = false;\n\n    while (!done) {\n      // Unpack the next entry\n      var entry = iterator.next();\n      done = entry.done;\n      // Are we done, then skip and terminate\n      if (done) continue;\n\n      // Get the entry values\n      key = entry.value[0];\n      value = entry.value[1];\n\n      // Check the type of the value\n      type = typeof value;\n\n      // Check the key and throw error if it's illegal\n      if (typeof key === 'string' && ignoreKeys.indexOf(key) === -1) {\n        if (key.match(regexp) != null) {\n          // The BSON spec doesn't allow keys with null bytes because keys are\n          // null-terminated.\n          throw Error('key ' + key + ' must not contain null bytes');\n        }\n\n        if (checkKeys) {\n          if ('$' === key[0]) {\n            throw Error('key ' + key + \" must not start with '$'\");\n          } else if (~key.indexOf('.')) {\n            throw Error('key ' + key + \" must not contain '.'\");\n          }\n        }\n      }\n\n      if (type === 'string') {\n        index = serializeString(buffer, key, value, index);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index);\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer, key, value, index);\n        // } else if (value === undefined && ignoreUndefined === true) {\n      } else if (value === null || (value === undefined && ignoreUndefined === false)) {\n        index = serializeNull(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'ObjectID' || value['_bsontype'] === 'ObjectId') {\n        index = serializeObjectId(buffer, key, value, index);\n      } else if (Buffer.isBuffer(value)) {\n        index = serializeBuffer(buffer, key, value, index);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer, key, value, index);\n      } else if (type === 'object' && value['_bsontype'] == null) {\n        index = serializeObject(\n          buffer,\n          key,\n          value,\n          index,\n          checkKeys,\n          depth,\n          serializeFunctions,\n          ignoreUndefined,\n          false,\n          path\n        );\n      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {\n        index = serializeDecimal128(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {\n        index = serializeLong(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Double') {\n        index = serializeDouble(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Code') {\n        index = serializeCode(\n          buffer,\n          key,\n          value,\n          index,\n          checkKeys,\n          depth,\n          serializeFunctions,\n          ignoreUndefined\n        );\n      } else if (typeof value === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'Binary') {\n        index = serializeBinary(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Symbol') {\n        index = serializeSymbol(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'DBRef') {\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'BSONRegExp') {\n        index = serializeBSONRegExp(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Int32') {\n        index = serializeInt32(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {\n        index = serializeMinMax(buffer, key, value, index);\n      } else if (typeof value['_bsontype'] !== 'undefined') {\n        throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);\n      }\n    }\n  } else {\n    // Did we provide a custom serialization method\n    if (object.toBSON) {\n      if (typeof object.toBSON !== 'function') throw new Error('toBSON is not a function');\n      object = object.toBSON();\n      if (object != null && typeof object !== 'object')\n        throw new Error('toBSON function did not return an object');\n    }\n\n    // Iterate over all the keys\n    for (key in object) {\n      value = object[key];\n      // Is there an override value\n      if (value && value.toBSON) {\n        if (typeof value.toBSON !== 'function') throw new Error('toBSON is not a function');\n        value = value.toBSON();\n      }\n\n      // Check the type of the value\n      type = typeof value;\n\n      // Check the key and throw error if it's illegal\n      if (typeof key === 'string' && ignoreKeys.indexOf(key) === -1) {\n        if (key.match(regexp) != null) {\n          // The BSON spec doesn't allow keys with null bytes because keys are\n          // null-terminated.\n          throw Error('key ' + key + ' must not contain null bytes');\n        }\n\n        if (checkKeys) {\n          if ('$' === key[0]) {\n            throw Error('key ' + key + \" must not start with '$'\");\n          } else if (~key.indexOf('.')) {\n            throw Error('key ' + key + \" must not contain '.'\");\n          }\n        }\n      }\n\n      if (type === 'string') {\n        index = serializeString(buffer, key, value, index);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index);\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer, key, value, index);\n      } else if (value === undefined) {\n        if (ignoreUndefined === false) index = serializeNull(buffer, key, value, index);\n      } else if (value === null) {\n        index = serializeNull(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'ObjectID' || value['_bsontype'] === 'ObjectId') {\n        index = serializeObjectId(buffer, key, value, index);\n      } else if (Buffer.isBuffer(value)) {\n        index = serializeBuffer(buffer, key, value, index);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer, key, value, index);\n      } else if (type === 'object' && value['_bsontype'] == null) {\n        index = serializeObject(\n          buffer,\n          key,\n          value,\n          index,\n          checkKeys,\n          depth,\n          serializeFunctions,\n          ignoreUndefined,\n          false,\n          path\n        );\n      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {\n        index = serializeDecimal128(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {\n        index = serializeLong(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Double') {\n        index = serializeDouble(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Code') {\n        index = serializeCode(\n          buffer,\n          key,\n          value,\n          index,\n          checkKeys,\n          depth,\n          serializeFunctions,\n          ignoreUndefined\n        );\n      } else if (typeof value === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'Binary') {\n        index = serializeBinary(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Symbol') {\n        index = serializeSymbol(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'DBRef') {\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'BSONRegExp') {\n        index = serializeBSONRegExp(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Int32') {\n        index = serializeInt32(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {\n        index = serializeMinMax(buffer, key, value, index);\n      } else if (typeof value['_bsontype'] !== 'undefined') {\n        throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);\n      }\n    }\n  }\n\n  // Remove the path\n  path.pop();\n\n  // Final padding byte for object\n  buffer[index++] = 0x00;\n\n  // Final size\n  var size = index - startingIndex;\n  // Write the size of the object\n  buffer[startingIndex++] = size & 0xff;\n  buffer[startingIndex++] = (size >> 8) & 0xff;\n  buffer[startingIndex++] = (size >> 16) & 0xff;\n  buffer[startingIndex++] = (size >> 24) & 0xff;\n  return index;\n};\n\nvar BSON = {};\n\n/**\n * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5\n *\n * @ignore\n * @api private\n */\n// var functionCache = (BSON.functionCache = {});\n\n/**\n * Number BSON Type\n *\n * @classconstant BSON_DATA_NUMBER\n **/\nBSON.BSON_DATA_NUMBER = 1;\n/**\n * String BSON Type\n *\n * @classconstant BSON_DATA_STRING\n **/\nBSON.BSON_DATA_STRING = 2;\n/**\n * Object BSON Type\n *\n * @classconstant BSON_DATA_OBJECT\n **/\nBSON.BSON_DATA_OBJECT = 3;\n/**\n * Array BSON Type\n *\n * @classconstant BSON_DATA_ARRAY\n **/\nBSON.BSON_DATA_ARRAY = 4;\n/**\n * Binary BSON Type\n *\n * @classconstant BSON_DATA_BINARY\n **/\nBSON.BSON_DATA_BINARY = 5;\n/**\n * ObjectID BSON Type, deprecated\n *\n * @classconstant BSON_DATA_UNDEFINED\n **/\nBSON.BSON_DATA_UNDEFINED = 6;\n/**\n * ObjectID BSON Type\n *\n * @classconstant BSON_DATA_OID\n **/\nBSON.BSON_DATA_OID = 7;\n/**\n * Boolean BSON Type\n *\n * @classconstant BSON_DATA_BOOLEAN\n **/\nBSON.BSON_DATA_BOOLEAN = 8;\n/**\n * Date BSON Type\n *\n * @classconstant BSON_DATA_DATE\n **/\nBSON.BSON_DATA_DATE = 9;\n/**\n * null BSON Type\n *\n * @classconstant BSON_DATA_NULL\n **/\nBSON.BSON_DATA_NULL = 10;\n/**\n * RegExp BSON Type\n *\n * @classconstant BSON_DATA_REGEXP\n **/\nBSON.BSON_DATA_REGEXP = 11;\n/**\n * Code BSON Type\n *\n * @classconstant BSON_DATA_CODE\n **/\nBSON.BSON_DATA_CODE = 13;\n/**\n * Symbol BSON Type\n *\n * @classconstant BSON_DATA_SYMBOL\n **/\nBSON.BSON_DATA_SYMBOL = 14;\n/**\n * Code with Scope BSON Type\n *\n * @classconstant BSON_DATA_CODE_W_SCOPE\n **/\nBSON.BSON_DATA_CODE_W_SCOPE = 15;\n/**\n * 32 bit Integer BSON Type\n *\n * @classconstant BSON_DATA_INT\n **/\nBSON.BSON_DATA_INT = 16;\n/**\n * Timestamp BSON Type\n *\n * @classconstant BSON_DATA_TIMESTAMP\n **/\nBSON.BSON_DATA_TIMESTAMP = 17;\n/**\n * Long BSON Type\n *\n * @classconstant BSON_DATA_LONG\n **/\nBSON.BSON_DATA_LONG = 18;\n/**\n * Long BSON Type\n *\n * @classconstant BSON_DATA_DECIMAL128\n **/\nBSON.BSON_DATA_DECIMAL128 = 19;\n/**\n * MinKey BSON Type\n *\n * @classconstant BSON_DATA_MIN_KEY\n **/\nBSON.BSON_DATA_MIN_KEY = 0xff;\n/**\n * MaxKey BSON Type\n *\n * @classconstant BSON_DATA_MAX_KEY\n **/\nBSON.BSON_DATA_MAX_KEY = 0x7f;\n/**\n * Binary Default Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_DEFAULT\n **/\nBSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;\n/**\n * Binary Function Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_FUNCTION\n **/\nBSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;\n/**\n * Binary Byte Array Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY\n **/\nBSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;\n/**\n * Binary UUID Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_UUID\n **/\nBSON.BSON_BINARY_SUBTYPE_UUID = 3;\n/**\n * Binary MD5 Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_MD5\n **/\nBSON.BSON_BINARY_SUBTYPE_MD5 = 4;\n/**\n * Binary User Defined Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED\n **/\nBSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;\n\n// BSON MAX VALUES\nBSON.BSON_INT32_MAX = 0x7fffffff;\nBSON.BSON_INT32_MIN = -0x80000000;\n\nBSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;\nBSON.BSON_INT64_MIN = -Math.pow(2, 63);\n\n// JS MAX PRECISE VALUES\nBSON.JS_INT_MAX = 0x20000000000000; // Any integer up to 2^53 can be precisely represented by a double.\nBSON.JS_INT_MIN = -0x20000000000000; // Any integer down to -2^53 can be precisely represented by a double.\n\n// Internal long versions\n// var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000); // Any integer up to 2^53 can be precisely represented by a double.\n// var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000); // Any integer down to -2^53 can be precisely represented by a double.\n\nmodule.exports = serializeInto;\n"]},"metadata":{},"sourceType":"script"}