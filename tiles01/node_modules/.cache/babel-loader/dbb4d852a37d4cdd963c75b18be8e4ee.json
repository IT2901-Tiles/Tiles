{"ast":null,"code":"'use strict';\n\nconst ServerType = require('./common').ServerType;\n\nconst TopologyType = require('./common').TopologyType;\n\nconst ReadPreference = require('../topologies/read_preference');\n\nconst MongoError = require('../error').MongoError; // max staleness constants\n\n\nconst IDLE_WRITE_PERIOD = 10000;\nconst SMALLEST_MAX_STALENESS_SECONDS = 90;\n/**\n * Returns a server selector that selects for writable servers\n */\n\nfunction writableServerSelector() {\n  return function (topologyDescription, servers) {\n    return latencyWindowReducer(topologyDescription, servers.filter(s => s.isWritable));\n  };\n}\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\n *\n * @param {ReadPreference} readPreference The read preference providing max staleness guidance\n * @param {topologyDescription} topologyDescription The topology description\n * @param {ServerDescription[]} servers The list of server descriptions to be reduced\n * @return {ServerDescription[]} The list of servers that satisfy the requirements of max staleness\n */\n\n\nfunction maxStalenessReducer(readPreference, topologyDescription, servers) {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n\n  const maxStaleness = readPreference.maxStalenessSeconds;\n  const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n\n  if (maxStaleness < maxStalenessVariance) {\n    throw new MongoError(`maxStalenessSeconds must be at least ${maxStalenessVariance} seconds`);\n  }\n\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new MongoError(`maxStalenessSeconds must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {\n    const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];\n    return servers.reduce((result, server) => {\n      const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;\n      const staleness = stalenessMS / 1000;\n      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);\n      return result;\n    }, []);\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {\n    if (servers.length === 0) {\n      return servers;\n    }\n\n    const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);\n    return servers.reduce((result, server) => {\n      const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n      const staleness = stalenessMS / 1000;\n      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);\n      return result;\n    }, []);\n  }\n\n  return servers;\n}\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param {String[]} tagSet The requested tag set to match\n * @param {String[]} serverTags The server's tags\n */\n\n\nfunction tagSetMatch(tagSet, serverTags) {\n  const keys = Object.keys(tagSet);\n  const serverTagKeys = Object.keys(serverTags);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param {ReadPreference} readPreference The read preference providing the requested tags\n * @param {ServerDescription[]} servers The list of server descriptions to reduce\n * @return {ServerDescription[]} The list of servers matching the requested tags\n */\n\n\nfunction tagSetReducer(readPreference, servers) {\n  if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {\n    return servers;\n  }\n\n  for (let i = 0; i < readPreference.tags.length; ++i) {\n    const tagSet = readPreference.tags[i];\n    const serversMatchingTagset = servers.reduce((matched, server) => {\n      if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n      return matched;\n    }, []);\n\n    if (serversMatchingTagset.length) {\n      return serversMatchingTagset;\n    }\n  }\n\n  return [];\n}\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\n *\n * @param {topologyDescription} topologyDescription The topology description\n * @param {ServerDescription[]} servers The list of servers to reduce\n * @returns {ServerDescription[]} The servers which fall within an acceptable latency window\n */\n\n\nfunction latencyWindowReducer(topologyDescription, servers) {\n  const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);\n  const high = low + topologyDescription.localThresholdMS;\n  return servers.reduce((result, server) => {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n} // filters\n\n\nfunction primaryFilter(server) {\n  return server.type === ServerType.RSPrimary;\n}\n\nfunction secondaryFilter(server) {\n  return server.type === ServerType.RSSecondary;\n}\n\nfunction nearestFilter(server) {\n  return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;\n}\n\nfunction knownFilter(server) {\n  return server.type !== ServerType.Unknown;\n}\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param {ReadPreference} readPreference The read preference to select with\n */\n\n\nfunction readPreferenceServerSelector(readPreference) {\n  if (!readPreference.isValid()) {\n    throw new TypeError('Invalid read preference specified');\n  }\n\n  return function (topologyDescription, servers) {\n    const commonWireVersion = topologyDescription.commonWireVersion;\n\n    if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {\n      throw new MongoError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);\n    }\n\n    if (topologyDescription.type === TopologyType.Unknown) {\n      return [];\n    }\n\n    if (topologyDescription.type === TopologyType.Single || topologyDescription.type === TopologyType.Sharded) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n\n    const mode = readPreference.mode;\n\n    if (mode === ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n\n    if (mode === ReadPreference.PRIMARY_PREFERRED) {\n      const result = servers.filter(primaryFilter);\n\n      if (result.length) {\n        return result;\n      }\n    }\n\n    const filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\n    const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));\n\n    if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\n      return servers.filter(primaryFilter);\n    }\n\n    return selectedServers;\n  };\n}\n\nmodule.exports = {\n  writableServerSelector,\n  readPreferenceServerSelector\n};","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/core/sdam/server_selection.js"],"names":["ServerType","require","TopologyType","ReadPreference","MongoError","IDLE_WRITE_PERIOD","SMALLEST_MAX_STALENESS_SECONDS","writableServerSelector","topologyDescription","servers","latencyWindowReducer","filter","s","isWritable","maxStalenessReducer","readPreference","maxStalenessSeconds","maxStaleness","maxStalenessVariance","heartbeatFrequencyMS","type","ReplicaSetWithPrimary","primary","Array","from","values","primaryFilter","reduce","result","server","stalenessMS","lastUpdateTime","lastWriteDate","staleness","push","ReplicaSetNoPrimary","length","sMax","max","tagSetMatch","tagSet","serverTags","keys","Object","serverTagKeys","i","key","indexOf","tagSetReducer","tags","isArray","serversMatchingTagset","matched","low","min","roundTripTime","Math","high","localThresholdMS","RSPrimary","secondaryFilter","RSSecondary","nearestFilter","knownFilter","Unknown","readPreferenceServerSelector","isValid","TypeError","commonWireVersion","minWireVersion","Single","Sharded","mode","PRIMARY","PRIMARY_PREFERRED","NEAREST","selectedServers","SECONDARY_PREFERRED","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst ServerType = require('./common').ServerType;\nconst TopologyType = require('./common').TopologyType;\nconst ReadPreference = require('../topologies/read_preference');\nconst MongoError = require('../error').MongoError;\n\n// max staleness constants\nconst IDLE_WRITE_PERIOD = 10000;\nconst SMALLEST_MAX_STALENESS_SECONDS = 90;\n\n/**\n * Returns a server selector that selects for writable servers\n */\nfunction writableServerSelector() {\n  return function(topologyDescription, servers) {\n    return latencyWindowReducer(\n      topologyDescription,\n      servers.filter(s => s.isWritable)\n    );\n  };\n}\n\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\n *\n * @param {ReadPreference} readPreference The read preference providing max staleness guidance\n * @param {topologyDescription} topologyDescription The topology description\n * @param {ServerDescription[]} servers The list of server descriptions to be reduced\n * @return {ServerDescription[]} The list of servers that satisfy the requirements of max staleness\n */\nfunction maxStalenessReducer(readPreference, topologyDescription, servers) {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n\n  const maxStaleness = readPreference.maxStalenessSeconds;\n  const maxStalenessVariance =\n    (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n  if (maxStaleness < maxStalenessVariance) {\n    throw new MongoError(`maxStalenessSeconds must be at least ${maxStalenessVariance} seconds`);\n  }\n\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new MongoError(\n      `maxStalenessSeconds must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`\n    );\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {\n    const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];\n    return servers.reduce((result, server) => {\n      const stalenessMS =\n        server.lastUpdateTime -\n        server.lastWriteDate -\n        (primary.lastUpdateTime - primary.lastWriteDate) +\n        topologyDescription.heartbeatFrequencyMS;\n\n      const staleness = stalenessMS / 1000;\n      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);\n      return result;\n    }, []);\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {\n    if (servers.length === 0) {\n      return servers;\n    }\n\n    const sMax = servers.reduce((max, s) => (s.lastWriteDate > max.lastWriteDate ? s : max));\n    return servers.reduce((result, server) => {\n      const stalenessMS =\n        sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n\n      const staleness = stalenessMS / 1000;\n      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);\n      return result;\n    }, []);\n  }\n\n  return servers;\n}\n\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param {String[]} tagSet The requested tag set to match\n * @param {String[]} serverTags The server's tags\n */\nfunction tagSetMatch(tagSet, serverTags) {\n  const keys = Object.keys(tagSet);\n  const serverTagKeys = Object.keys(serverTags);\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param {ReadPreference} readPreference The read preference providing the requested tags\n * @param {ServerDescription[]} servers The list of server descriptions to reduce\n * @return {ServerDescription[]} The list of servers matching the requested tags\n */\nfunction tagSetReducer(readPreference, servers) {\n  if (\n    readPreference.tags == null ||\n    (Array.isArray(readPreference.tags) && readPreference.tags.length === 0)\n  ) {\n    return servers;\n  }\n\n  for (let i = 0; i < readPreference.tags.length; ++i) {\n    const tagSet = readPreference.tags[i];\n    const serversMatchingTagset = servers.reduce((matched, server) => {\n      if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n      return matched;\n    }, []);\n\n    if (serversMatchingTagset.length) {\n      return serversMatchingTagset;\n    }\n  }\n\n  return [];\n}\n\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\n *\n * @param {topologyDescription} topologyDescription The topology description\n * @param {ServerDescription[]} servers The list of servers to reduce\n * @returns {ServerDescription[]} The servers which fall within an acceptable latency window\n */\nfunction latencyWindowReducer(topologyDescription, servers) {\n  const low = servers.reduce(\n    (min, server) => (min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min)),\n    -1\n  );\n\n  const high = low + topologyDescription.localThresholdMS;\n\n  return servers.reduce((result, server) => {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n}\n\n// filters\nfunction primaryFilter(server) {\n  return server.type === ServerType.RSPrimary;\n}\n\nfunction secondaryFilter(server) {\n  return server.type === ServerType.RSSecondary;\n}\n\nfunction nearestFilter(server) {\n  return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;\n}\n\nfunction knownFilter(server) {\n  return server.type !== ServerType.Unknown;\n}\n\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param {ReadPreference} readPreference The read preference to select with\n */\nfunction readPreferenceServerSelector(readPreference) {\n  if (!readPreference.isValid()) {\n    throw new TypeError('Invalid read preference specified');\n  }\n\n  return function(topologyDescription, servers) {\n    const commonWireVersion = topologyDescription.commonWireVersion;\n    if (\n      commonWireVersion &&\n      readPreference.minWireVersion &&\n      readPreference.minWireVersion > commonWireVersion\n    ) {\n      throw new MongoError(\n        `Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`\n      );\n    }\n\n    if (topologyDescription.type === TopologyType.Unknown) {\n      return [];\n    }\n\n    if (\n      topologyDescription.type === TopologyType.Single ||\n      topologyDescription.type === TopologyType.Sharded\n    ) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n\n    const mode = readPreference.mode;\n    if (mode === ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n\n    if (mode === ReadPreference.PRIMARY_PREFERRED) {\n      const result = servers.filter(primaryFilter);\n      if (result.length) {\n        return result;\n      }\n    }\n\n    const filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\n    const selectedServers = latencyWindowReducer(\n      topologyDescription,\n      tagSetReducer(\n        readPreference,\n        maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))\n      )\n    );\n\n    if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\n      return servers.filter(primaryFilter);\n    }\n\n    return selectedServers;\n  };\n}\n\nmodule.exports = {\n  writableServerSelector,\n  readPreferenceServerSelector\n};\n"]},"metadata":{},"sourceType":"script"}