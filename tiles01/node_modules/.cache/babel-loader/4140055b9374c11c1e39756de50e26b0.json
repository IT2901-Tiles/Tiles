{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\n\nclass Instrumentation extends EventEmitter {\n  constructor() {\n    super();\n  }\n\n  instrument(MongoClient, callback) {\n    // store a reference to the original functions\n    this.$MongoClient = MongoClient;\n    const $prototypeConnect = this.$prototypeConnect = MongoClient.prototype.connect;\n    const instrumentation = this;\n\n    MongoClient.prototype.connect = function (callback) {\n      this.s.options.monitorCommands = true;\n      this.on('commandStarted', event => instrumentation.emit('started', event));\n      this.on('commandSucceeded', event => instrumentation.emit('succeeded', event));\n      this.on('commandFailed', event => instrumentation.emit('failed', event));\n      return $prototypeConnect.call(this, callback);\n    };\n\n    if (typeof callback === 'function') callback(null, this);\n  }\n\n  uninstrument() {\n    this.$MongoClient.prototype.connect = this.$prototypeConnect;\n  }\n\n}\n\nmodule.exports = Instrumentation;","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/apm.js"],"names":["EventEmitter","require","Instrumentation","constructor","instrument","MongoClient","callback","$MongoClient","$prototypeConnect","prototype","connect","instrumentation","s","options","monitorCommands","on","event","emit","call","uninstrument","module","exports"],"mappings":"AAAA;;AACA,MAAMA,YAAY,GAAGC,OAAO,CAAC,QAAD,CAAP,CAAkBD,YAAvC;;AAEA,MAAME,eAAN,SAA8BF,YAA9B,CAA2C;AACzCG,EAAAA,WAAW,GAAG;AACZ;AACD;;AAEDC,EAAAA,UAAU,CAACC,WAAD,EAAcC,QAAd,EAAwB;AAChC;AACA,SAAKC,YAAL,GAAoBF,WAApB;AACA,UAAMG,iBAAiB,GAAI,KAAKA,iBAAL,GAAyBH,WAAW,CAACI,SAAZ,CAAsBC,OAA1E;AAEA,UAAMC,eAAe,GAAG,IAAxB;;AACAN,IAAAA,WAAW,CAACI,SAAZ,CAAsBC,OAAtB,GAAgC,UAASJ,QAAT,EAAmB;AACjD,WAAKM,CAAL,CAAOC,OAAP,CAAeC,eAAf,GAAiC,IAAjC;AACA,WAAKC,EAAL,CAAQ,gBAAR,EAA0BC,KAAK,IAAIL,eAAe,CAACM,IAAhB,CAAqB,SAArB,EAAgCD,KAAhC,CAAnC;AACA,WAAKD,EAAL,CAAQ,kBAAR,EAA4BC,KAAK,IAAIL,eAAe,CAACM,IAAhB,CAAqB,WAArB,EAAkCD,KAAlC,CAArC;AACA,WAAKD,EAAL,CAAQ,eAAR,EAAyBC,KAAK,IAAIL,eAAe,CAACM,IAAhB,CAAqB,QAArB,EAA+BD,KAA/B,CAAlC;AACA,aAAOR,iBAAiB,CAACU,IAAlB,CAAuB,IAAvB,EAA6BZ,QAA7B,CAAP;AACD,KAND;;AAQA,QAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoCA,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAR;AACrC;;AAEDa,EAAAA,YAAY,GAAG;AACb,SAAKZ,YAAL,CAAkBE,SAAlB,CAA4BC,OAA5B,GAAsC,KAAKF,iBAA3C;AACD;;AAxBwC;;AA2B3CY,MAAM,CAACC,OAAP,GAAiBnB,eAAjB","sourcesContent":["'use strict';\nconst EventEmitter = require('events').EventEmitter;\n\nclass Instrumentation extends EventEmitter {\n  constructor() {\n    super();\n  }\n\n  instrument(MongoClient, callback) {\n    // store a reference to the original functions\n    this.$MongoClient = MongoClient;\n    const $prototypeConnect = (this.$prototypeConnect = MongoClient.prototype.connect);\n\n    const instrumentation = this;\n    MongoClient.prototype.connect = function(callback) {\n      this.s.options.monitorCommands = true;\n      this.on('commandStarted', event => instrumentation.emit('started', event));\n      this.on('commandSucceeded', event => instrumentation.emit('succeeded', event));\n      this.on('commandFailed', event => instrumentation.emit('failed', event));\n      return $prototypeConnect.call(this, callback);\n    };\n\n    if (typeof callback === 'function') callback(null, this);\n  }\n\n  uninstrument() {\n    this.$MongoClient.prototype.connect = this.$prototypeConnect;\n  }\n}\n\nmodule.exports = Instrumentation;\n"]},"metadata":{},"sourceType":"script"}