{"ast":null,"code":"'use strict';\n\nconst Aspect = require('./operation').Aspect;\n\nconst defineAspects = require('./operation').defineAspects;\n\nconst CommandOperationV2 = require('./command_v2');\n\nconst MongoError = require('../core').MongoError;\n\nconst parseIndexOptions = require('../utils').parseIndexOptions;\n\nconst maxWireVersion = require('../core/utils').maxWireVersion;\n\nconst VALID_INDEX_OPTIONS = new Set(['background', 'unique', 'name', 'partialFilterExpression', 'sparse', 'expireAfterSeconds', 'storageEngine', 'collation', // text indexes\n'weights', 'default_language', 'language_override', 'textIndexVersion', // 2d-sphere indexes\n'2dsphereIndexVersion', // 2d indexes\n'bits', 'min', 'max', // geoHaystack Indexes\n'bucketSize', // wildcard indexes\n'wildcardProjection']);\n\nclass CreateIndexesOperation extends CommandOperationV2 {\n  /**\n   * @ignore\n   */\n  constructor(parent, collection, indexes, options) {\n    super(parent, options);\n    this.collection = collection; // createIndex can be called with a variety of styles:\n    //   coll.createIndex('a');\n    //   coll.createIndex({ a: 1 });\n    //   coll.createIndex([['a', 1]]);\n    // createIndexes is always called with an array of index spec objects\n\n    if (!Array.isArray(indexes) || Array.isArray(indexes[0])) {\n      this.onlyReturnNameOfCreatedIndex = true; // TODO: remove in v4 (breaking change); make createIndex return full response as createIndexes does\n\n      const indexParameters = parseIndexOptions(indexes); // Generate the index name\n\n      const name = typeof options.name === 'string' ? options.name : indexParameters.name; // Set up the index\n\n      const indexSpec = {\n        name,\n        key: indexParameters.fieldHash\n      }; // merge valid index options into the index spec\n\n      for (let optionName in options) {\n        if (VALID_INDEX_OPTIONS.has(optionName)) {\n          indexSpec[optionName] = options[optionName];\n        }\n      }\n\n      this.indexes = [indexSpec];\n      return;\n    }\n\n    this.indexes = indexes;\n  }\n  /**\n   * @ignore\n   */\n\n\n  execute(server, callback) {\n    const options = this.options;\n    const indexes = this.indexes;\n    const serverWireVersion = maxWireVersion(server); // Ensure we generate the correct name if the parameter is not set\n\n    for (let i = 0; i < indexes.length; i++) {\n      // Did the user pass in a collation, check if our write server supports it\n      if (indexes[i].collation && serverWireVersion < 5) {\n        callback(new MongoError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));\n        return;\n      }\n\n      if (indexes[i].name == null) {\n        const keys = [];\n\n        for (let name in indexes[i].key) {\n          keys.push(`${name}_${indexes[i].key[name]}`);\n        } // Set the name\n\n\n        indexes[i].name = keys.join('_');\n      }\n    }\n\n    const cmd = {\n      createIndexes: this.collection,\n      indexes\n    };\n\n    if (options.commitQuorum != null) {\n      if (serverWireVersion < 9) {\n        callback(new MongoError('`commitQuorum` option for `createIndexes` not supported on servers < 4.4'));\n        return;\n      }\n\n      cmd.commitQuorum = options.commitQuorum;\n    } // collation is set on each index, it should not be defined at the root\n\n\n    this.options.collation = undefined;\n    super.executeCommand(server, cmd, (err, result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      callback(null, this.onlyReturnNameOfCreatedIndex ? indexes[0].name : result);\n    });\n  }\n\n}\n\ndefineAspects(CreateIndexesOperation, [Aspect.WRITE_OPERATION, Aspect.EXECUTE_WITH_SELECTION]);\nmodule.exports = CreateIndexesOperation;","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/operations/create_indexes.js"],"names":["Aspect","require","defineAspects","CommandOperationV2","MongoError","parseIndexOptions","maxWireVersion","VALID_INDEX_OPTIONS","Set","CreateIndexesOperation","constructor","parent","collection","indexes","options","Array","isArray","onlyReturnNameOfCreatedIndex","indexParameters","name","indexSpec","key","fieldHash","optionName","has","execute","server","callback","serverWireVersion","i","length","collation","keys","push","join","cmd","createIndexes","commitQuorum","undefined","executeCommand","err","result","WRITE_OPERATION","EXECUTE_WITH_SELECTION","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Aspect = require('./operation').Aspect;\nconst defineAspects = require('./operation').defineAspects;\nconst CommandOperationV2 = require('./command_v2');\nconst MongoError = require('../core').MongoError;\nconst parseIndexOptions = require('../utils').parseIndexOptions;\nconst maxWireVersion = require('../core/utils').maxWireVersion;\n\nconst VALID_INDEX_OPTIONS = new Set([\n  'background',\n  'unique',\n  'name',\n  'partialFilterExpression',\n  'sparse',\n  'expireAfterSeconds',\n  'storageEngine',\n  'collation',\n\n  // text indexes\n  'weights',\n  'default_language',\n  'language_override',\n  'textIndexVersion',\n\n  // 2d-sphere indexes\n  '2dsphereIndexVersion',\n\n  // 2d indexes\n  'bits',\n  'min',\n  'max',\n\n  // geoHaystack Indexes\n  'bucketSize',\n\n  // wildcard indexes\n  'wildcardProjection'\n]);\n\nclass CreateIndexesOperation extends CommandOperationV2 {\n  /**\n   * @ignore\n   */\n  constructor(parent, collection, indexes, options) {\n    super(parent, options);\n    this.collection = collection;\n\n    // createIndex can be called with a variety of styles:\n    //   coll.createIndex('a');\n    //   coll.createIndex({ a: 1 });\n    //   coll.createIndex([['a', 1]]);\n    // createIndexes is always called with an array of index spec objects\n    if (!Array.isArray(indexes) || Array.isArray(indexes[0])) {\n      this.onlyReturnNameOfCreatedIndex = true;\n      // TODO: remove in v4 (breaking change); make createIndex return full response as createIndexes does\n\n      const indexParameters = parseIndexOptions(indexes);\n      // Generate the index name\n      const name = typeof options.name === 'string' ? options.name : indexParameters.name;\n      // Set up the index\n      const indexSpec = { name, key: indexParameters.fieldHash };\n      // merge valid index options into the index spec\n      for (let optionName in options) {\n        if (VALID_INDEX_OPTIONS.has(optionName)) {\n          indexSpec[optionName] = options[optionName];\n        }\n      }\n      this.indexes = [indexSpec];\n      return;\n    }\n\n    this.indexes = indexes;\n  }\n\n  /**\n   * @ignore\n   */\n  execute(server, callback) {\n    const options = this.options;\n    const indexes = this.indexes;\n\n    const serverWireVersion = maxWireVersion(server);\n\n    // Ensure we generate the correct name if the parameter is not set\n    for (let i = 0; i < indexes.length; i++) {\n      // Did the user pass in a collation, check if our write server supports it\n      if (indexes[i].collation && serverWireVersion < 5) {\n        callback(\n          new MongoError(\n            `Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`\n          )\n        );\n        return;\n      }\n\n      if (indexes[i].name == null) {\n        const keys = [];\n\n        for (let name in indexes[i].key) {\n          keys.push(`${name}_${indexes[i].key[name]}`);\n        }\n\n        // Set the name\n        indexes[i].name = keys.join('_');\n      }\n    }\n\n    const cmd = { createIndexes: this.collection, indexes };\n\n    if (options.commitQuorum != null) {\n      if (serverWireVersion < 9) {\n        callback(\n          new MongoError('`commitQuorum` option for `createIndexes` not supported on servers < 4.4')\n        );\n        return;\n      }\n      cmd.commitQuorum = options.commitQuorum;\n    }\n\n    // collation is set on each index, it should not be defined at the root\n    this.options.collation = undefined;\n\n    super.executeCommand(server, cmd, (err, result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      callback(null, this.onlyReturnNameOfCreatedIndex ? indexes[0].name : result);\n    });\n  }\n}\n\ndefineAspects(CreateIndexesOperation, [Aspect.WRITE_OPERATION, Aspect.EXECUTE_WITH_SELECTION]);\n\nmodule.exports = CreateIndexesOperation;\n"]},"metadata":{},"sourceType":"script"}