{"ast":null,"code":"'use strict';\n\nconst os = require('os');\n\nconst crypto = require('crypto');\n\nconst requireOptional = require('require_optional');\n/**\n * Generate a UUIDv4\n */\n\n\nconst uuidV4 = () => {\n  const result = crypto.randomBytes(16);\n  result[6] = result[6] & 0x0f | 0x40;\n  result[8] = result[8] & 0x3f | 0x80;\n  return result;\n};\n/**\n * Relays events for a given listener and emitter\n *\n * @param {EventEmitter} listener the EventEmitter to listen to the events from\n * @param {EventEmitter} emitter the EventEmitter to relay the events to\n */\n\n\nfunction relayEvents(listener, emitter, events) {\n  events.forEach(eventName => listener.on(eventName, event => emitter.emit(eventName, event)));\n}\n\nfunction retrieveKerberos() {\n  let kerberos;\n\n  try {\n    kerberos = requireOptional('kerberos');\n  } catch (err) {\n    if (err.code === 'MODULE_NOT_FOUND') {\n      throw new Error('The `kerberos` module was not found. Please install it and try again.');\n    }\n\n    throw err;\n  }\n\n  return kerberos;\n} // Throw an error if an attempt to use EJSON is made when it is not installed\n\n\nconst noEJSONError = function () {\n  throw new Error('The `mongodb-extjson` module was not found. Please install it and try again.');\n}; // Facilitate loading EJSON optionally\n\n\nfunction retrieveEJSON() {\n  let EJSON = null;\n\n  try {\n    EJSON = requireOptional('mongodb-extjson');\n  } catch (error) {} // eslint-disable-line\n\n\n  if (!EJSON) {\n    EJSON = {\n      parse: noEJSONError,\n      deserialize: noEJSONError,\n      serialize: noEJSONError,\n      stringify: noEJSONError,\n      setBSONModule: noEJSONError,\n      BSON: noEJSONError\n    };\n  }\n\n  return EJSON;\n}\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology\n * instances\n *\n * @private\n * @param {(Topology|Server)} topologyOrServer\n */\n\n\nfunction maxWireVersion(topologyOrServer) {\n  if (topologyOrServer) {\n    if (topologyOrServer.ismaster) {\n      return topologyOrServer.ismaster.maxWireVersion;\n    }\n\n    if (typeof topologyOrServer.lastIsMaster === 'function') {\n      const lastIsMaster = topologyOrServer.lastIsMaster();\n\n      if (lastIsMaster) {\n        return lastIsMaster.maxWireVersion;\n      }\n    }\n\n    if (topologyOrServer.description) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n\n  return 0;\n}\n/*\n * Checks that collation is supported by server.\n *\n * @param {Server} [server] to check against\n * @param {object} [cmd] object where collation may be specified\n * @param {function} [callback] callback function\n * @return true if server does not support collation\n */\n\n\nfunction collationNotSupported(server, cmd) {\n  return cmd && cmd.collation && maxWireVersion(server) < 5;\n}\n/**\n * Checks if a given value is a Promise\n *\n * @param {*} maybePromise\n * @return true if the provided value is a Promise\n */\n\n\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n *\n * @param {array} arr an array of items to asynchronusly iterate over\n * @param {function} eachFn A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param {function} callback The callback called after every item has been iterated\n */\n\n\nfunction eachAsync(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = 0;\n\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    awaiting--;\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\n\nfunction eachAsyncSeries(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = arr.length;\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    idx++;\n    awaiting--;\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n      return;\n    }\n\n    eachFn(arr[idx], eachCallback);\n  }\n\n  eachFn(arr[idx], eachCallback);\n}\n\nfunction isUnifiedTopology(topology) {\n  return topology.description != null;\n}\n\nfunction arrayStrictEqual(arr, arr2) {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\n\nfunction tagsStrictEqual(tags, tags2) {\n  const tagsKeys = Object.keys(tags);\n  const tags2Keys = Object.keys(tags2);\n  return tagsKeys.length === tags2Keys.length && tagsKeys.every(key => tags2[key] === tags[key]);\n}\n\nfunction errorStrictEqual(lhs, rhs) {\n  if (lhs === rhs) {\n    return true;\n  }\n\n  if (lhs == null && rhs != null || lhs != null && rhs == null) {\n    return false;\n  }\n\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction makeStateMachine(stateTable) {\n  return function stateTransition(target, newState) {\n    const legalStates = stateTable[target.s.state];\n\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new TypeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);\n    }\n\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\n\nfunction makeClientMetadata(options) {\n  options = options || {};\n  const metadata = {\n    driver: {\n      name: 'nodejs',\n      version: require('../../package.json').version\n    },\n    os: {\n      type: os.type(),\n      name: process.platform,\n      architecture: process.arch,\n      version: os.release()\n    },\n    platform: `'Node.js ${process.version}, ${os.endianness} (${options.useUnifiedTopology ? 'unified' : 'legacy'})`\n  }; // support optionally provided wrapping driver info\n\n  if (options.driverInfo) {\n    if (options.driverInfo.name) {\n      metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\n    }\n\n    if (options.driverInfo.version) {\n      metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\n    }\n\n    if (options.driverInfo.platform) {\n      metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\n    }\n  }\n\n  if (options.appname) {\n    // MongoDB requires the appname not exceed a byte length of 128\n    const buffer = Buffer.from(options.appname);\n    metadata.application = {\n      name: buffer.length > 128 ? buffer.slice(0, 128).toString('utf8') : options.appname\n    };\n  }\n\n  return metadata;\n}\n\nconst noop = () => {};\n\nmodule.exports = {\n  uuidV4,\n  relayEvents,\n  collationNotSupported,\n  retrieveEJSON,\n  retrieveKerberos,\n  maxWireVersion,\n  isPromiseLike,\n  eachAsync,\n  eachAsyncSeries,\n  isUnifiedTopology,\n  arrayStrictEqual,\n  tagsStrictEqual,\n  errorStrictEqual,\n  makeStateMachine,\n  makeClientMetadata,\n  noop\n};","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/core/utils.js"],"names":["os","require","crypto","requireOptional","uuidV4","result","randomBytes","relayEvents","listener","emitter","events","forEach","eventName","on","event","emit","retrieveKerberos","kerberos","err","code","Error","noEJSONError","retrieveEJSON","EJSON","error","parse","deserialize","serialize","stringify","setBSONModule","BSON","maxWireVersion","topologyOrServer","ismaster","lastIsMaster","description","collationNotSupported","server","cmd","collation","isPromiseLike","maybePromise","then","eachAsync","arr","eachFn","callback","idx","awaiting","length","eachCallback","eachAsyncSeries","isUnifiedTopology","topology","arrayStrictEqual","arr2","Array","isArray","every","elt","tagsStrictEqual","tags","tags2","tagsKeys","Object","keys","tags2Keys","key","errorStrictEqual","lhs","rhs","constructor","name","message","makeStateMachine","stateTable","stateTransition","target","newState","legalStates","s","state","indexOf","TypeError","makeClientMetadata","options","metadata","driver","version","type","process","platform","architecture","arch","release","endianness","useUnifiedTopology","driverInfo","appname","buffer","Buffer","from","application","slice","toString","noop","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst os = require('os');\nconst crypto = require('crypto');\nconst requireOptional = require('require_optional');\n\n/**\n * Generate a UUIDv4\n */\nconst uuidV4 = () => {\n  const result = crypto.randomBytes(16);\n  result[6] = (result[6] & 0x0f) | 0x40;\n  result[8] = (result[8] & 0x3f) | 0x80;\n  return result;\n};\n\n/**\n * Relays events for a given listener and emitter\n *\n * @param {EventEmitter} listener the EventEmitter to listen to the events from\n * @param {EventEmitter} emitter the EventEmitter to relay the events to\n */\nfunction relayEvents(listener, emitter, events) {\n  events.forEach(eventName => listener.on(eventName, event => emitter.emit(eventName, event)));\n}\n\nfunction retrieveKerberos() {\n  let kerberos;\n\n  try {\n    kerberos = requireOptional('kerberos');\n  } catch (err) {\n    if (err.code === 'MODULE_NOT_FOUND') {\n      throw new Error('The `kerberos` module was not found. Please install it and try again.');\n    }\n\n    throw err;\n  }\n\n  return kerberos;\n}\n\n// Throw an error if an attempt to use EJSON is made when it is not installed\nconst noEJSONError = function() {\n  throw new Error('The `mongodb-extjson` module was not found. Please install it and try again.');\n};\n\n// Facilitate loading EJSON optionally\nfunction retrieveEJSON() {\n  let EJSON = null;\n  try {\n    EJSON = requireOptional('mongodb-extjson');\n  } catch (error) {} // eslint-disable-line\n  if (!EJSON) {\n    EJSON = {\n      parse: noEJSONError,\n      deserialize: noEJSONError,\n      serialize: noEJSONError,\n      stringify: noEJSONError,\n      setBSONModule: noEJSONError,\n      BSON: noEJSONError\n    };\n  }\n\n  return EJSON;\n}\n\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology\n * instances\n *\n * @private\n * @param {(Topology|Server)} topologyOrServer\n */\nfunction maxWireVersion(topologyOrServer) {\n  if (topologyOrServer) {\n    if (topologyOrServer.ismaster) {\n      return topologyOrServer.ismaster.maxWireVersion;\n    }\n\n    if (typeof topologyOrServer.lastIsMaster === 'function') {\n      const lastIsMaster = topologyOrServer.lastIsMaster();\n      if (lastIsMaster) {\n        return lastIsMaster.maxWireVersion;\n      }\n    }\n\n    if (topologyOrServer.description) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n\n  return 0;\n}\n\n/*\n * Checks that collation is supported by server.\n *\n * @param {Server} [server] to check against\n * @param {object} [cmd] object where collation may be specified\n * @param {function} [callback] callback function\n * @return true if server does not support collation\n */\nfunction collationNotSupported(server, cmd) {\n  return cmd && cmd.collation && maxWireVersion(server) < 5;\n}\n\n/**\n * Checks if a given value is a Promise\n *\n * @param {*} maybePromise\n * @return true if the provided value is a Promise\n */\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n *\n * @param {array} arr an array of items to asynchronusly iterate over\n * @param {function} eachFn A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param {function} callback The callback called after every item has been iterated\n */\nfunction eachAsync(arr, eachFn, callback) {\n  arr = arr || [];\n\n  let idx = 0;\n  let awaiting = 0;\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    awaiting--;\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\n\nfunction eachAsyncSeries(arr, eachFn, callback) {\n  arr = arr || [];\n\n  let idx = 0;\n  let awaiting = arr.length;\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    idx++;\n    awaiting--;\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n      return;\n    }\n\n    eachFn(arr[idx], eachCallback);\n  }\n\n  eachFn(arr[idx], eachCallback);\n}\n\nfunction isUnifiedTopology(topology) {\n  return topology.description != null;\n}\n\nfunction arrayStrictEqual(arr, arr2) {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\n\nfunction tagsStrictEqual(tags, tags2) {\n  const tagsKeys = Object.keys(tags);\n  const tags2Keys = Object.keys(tags2);\n  return tagsKeys.length === tags2Keys.length && tagsKeys.every(key => tags2[key] === tags[key]);\n}\n\nfunction errorStrictEqual(lhs, rhs) {\n  if (lhs === rhs) {\n    return true;\n  }\n\n  if ((lhs == null && rhs != null) || (lhs != null && rhs == null)) {\n    return false;\n  }\n\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction makeStateMachine(stateTable) {\n  return function stateTransition(target, newState) {\n    const legalStates = stateTable[target.s.state];\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new TypeError(\n        `illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`\n      );\n    }\n\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\n\nfunction makeClientMetadata(options) {\n  options = options || {};\n\n  const metadata = {\n    driver: {\n      name: 'nodejs',\n      version: require('../../package.json').version\n    },\n    os: {\n      type: os.type(),\n      name: process.platform,\n      architecture: process.arch,\n      version: os.release()\n    },\n    platform: `'Node.js ${process.version}, ${os.endianness} (${\n      options.useUnifiedTopology ? 'unified' : 'legacy'\n    })`\n  };\n\n  // support optionally provided wrapping driver info\n  if (options.driverInfo) {\n    if (options.driverInfo.name) {\n      metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\n    }\n\n    if (options.driverInfo.version) {\n      metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\n    }\n\n    if (options.driverInfo.platform) {\n      metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\n    }\n  }\n\n  if (options.appname) {\n    // MongoDB requires the appname not exceed a byte length of 128\n    const buffer = Buffer.from(options.appname);\n    metadata.application = {\n      name: buffer.length > 128 ? buffer.slice(0, 128).toString('utf8') : options.appname\n    };\n  }\n\n  return metadata;\n}\n\nconst noop = () => {};\n\nmodule.exports = {\n  uuidV4,\n  relayEvents,\n  collationNotSupported,\n  retrieveEJSON,\n  retrieveKerberos,\n  maxWireVersion,\n  isPromiseLike,\n  eachAsync,\n  eachAsyncSeries,\n  isUnifiedTopology,\n  arrayStrictEqual,\n  tagsStrictEqual,\n  errorStrictEqual,\n  makeStateMachine,\n  makeClientMetadata,\n  noop\n};\n"]},"metadata":{},"sourceType":"script"}