{"ast":null,"code":"// Copied from https://github.com/chris-rudmin/Recorderjs\nexport default (() => {\n  let BYTES_PER_SAMPLE = 2;\n  let recorded = [];\n\n  function encode(buffer) {\n    let length = buffer.length;\n    let data = new Uint8Array(length * BYTES_PER_SAMPLE);\n\n    for (let i = 0; i < length; i++) {\n      let index = i * BYTES_PER_SAMPLE;\n      let sample = buffer[i];\n\n      if (sample > 1) {\n        sample = 1;\n      } else if (sample < -1) {\n        sample = -1;\n      }\n\n      sample = sample * 32768;\n      data[index] = sample;\n      data[index + 1] = sample >> 8;\n    }\n\n    recorded.push(data);\n  }\n\n  function dump(sampleRate) {\n    let bufferLength = recorded.length ? recorded[0].length : 0;\n    let length = recorded.length * bufferLength;\n    let wav = new Uint8Array(44 + length);\n    let view = new DataView(wav.buffer); // RIFF identifier 'RIFF'\n\n    view.setUint32(0, 1380533830, false); // file length minus RIFF identifier length and file description length\n\n    view.setUint32(4, 36 + length, true); // RIFF type 'WAVE'\n\n    view.setUint32(8, 1463899717, false); // format chunk identifier 'fmt '\n\n    view.setUint32(12, 1718449184, false); // format chunk length\n\n    view.setUint32(16, 16, true); // sample format (raw)\n\n    view.setUint16(20, 1, true); // channel count\n\n    view.setUint16(22, 1, true); // sample rate\n\n    view.setUint32(24, sampleRate, true); // byte rate (sample rate * block align)\n\n    view.setUint32(28, sampleRate * BYTES_PER_SAMPLE, true); // block align (channel count * bytes per sample)\n\n    view.setUint16(32, BYTES_PER_SAMPLE, true); // bits per sample\n\n    view.setUint16(34, 8 * BYTES_PER_SAMPLE, true); // data chunk identifier 'data'\n\n    view.setUint32(36, 1684108385, false); // data chunk length\n\n    view.setUint32(40, length, true); // eslint-disable-next-line unicorn/no-for-loop\n\n    for (let i = 0; i < recorded.length; i++) {\n      wav.set(recorded[i], i * bufferLength + 44);\n    }\n\n    recorded = [];\n    postMessage(wav.buffer, [wav.buffer]);\n  }\n\n  onmessage = e => {\n    if (e.data[0] === 'encode') {\n      encode(e.data[1]);\n    } else if (e.data[0] === 'dump') {\n      dump(e.data[1]);\n    }\n  };\n});","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/audio-recorder-polyfill/wave-encoder/index.js"],"names":["BYTES_PER_SAMPLE","recorded","encode","buffer","length","data","Uint8Array","i","index","sample","push","dump","sampleRate","bufferLength","wav","view","DataView","setUint32","setUint16","set","postMessage","onmessage","e"],"mappings":"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","sourcesContent":["// Copied from https://github.com/chris-rudmin/Recorderjs\n\nexport default () => {\n  let BYTES_PER_SAMPLE = 2\n\n  let recorded = []\n\n  function encode (buffer) {\n    let length = buffer.length\n    let data = new Uint8Array(length * BYTES_PER_SAMPLE)\n    for (let i = 0; i < length; i++) {\n      let index = i * BYTES_PER_SAMPLE\n      let sample = buffer[i]\n      if (sample > 1) {\n        sample = 1\n      } else if (sample < -1) {\n        sample = -1\n      }\n      sample = sample * 32768\n      data[index] = sample\n      data[index + 1] = sample >> 8\n    }\n    recorded.push(data)\n  }\n\n  function dump (sampleRate) {\n    let bufferLength = recorded.length ? recorded[0].length : 0\n    let length = recorded.length * bufferLength\n    let wav = new Uint8Array(44 + length)\n    let view = new DataView(wav.buffer)\n\n    // RIFF identifier 'RIFF'\n    view.setUint32(0, 1380533830, false)\n    // file length minus RIFF identifier length and file description length\n    view.setUint32(4, 36 + length, true)\n    // RIFF type 'WAVE'\n    view.setUint32(8, 1463899717, false)\n    // format chunk identifier 'fmt '\n    view.setUint32(12, 1718449184, false)\n    // format chunk length\n    view.setUint32(16, 16, true)\n    // sample format (raw)\n    view.setUint16(20, 1, true)\n    // channel count\n    view.setUint16(22, 1, true)\n    // sample rate\n    view.setUint32(24, sampleRate, true)\n    // byte rate (sample rate * block align)\n    view.setUint32(28, sampleRate * BYTES_PER_SAMPLE, true)\n    // block align (channel count * bytes per sample)\n    view.setUint16(32, BYTES_PER_SAMPLE, true)\n    // bits per sample\n    view.setUint16(34, 8 * BYTES_PER_SAMPLE, true)\n    // data chunk identifier 'data'\n    view.setUint32(36, 1684108385, false)\n    // data chunk length\n    view.setUint32(40, length, true)\n\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let i = 0; i < recorded.length; i++) {\n      wav.set(recorded[i], i * bufferLength + 44)\n    }\n\n    recorded = []\n    postMessage(wav.buffer, [wav.buffer])\n  }\n\n  onmessage = e => {\n    if (e.data[0] === 'encode') {\n      encode(e.data[1])\n    } else if (e.data[0] === 'dump') {\n      dump(e.data[1])\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}