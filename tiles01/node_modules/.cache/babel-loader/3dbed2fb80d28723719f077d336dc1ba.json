{"ast":null,"code":"var path = require('path'),\n    fs = require('fs'),\n    f = require('util').format,\n    resolveFrom = require('resolve-from'),\n    semver = require('semver');\n\nvar exists = fs.existsSync || path.existsSync; // Find the location of a package.json file near or above the given location\n\nvar find_package_json = function (location) {\n  var found = false;\n\n  while (!found) {\n    if (exists(location + '/package.json')) {\n      found = location;\n    } else if (location !== '/') {\n      location = path.dirname(location);\n    } else {\n      return false;\n    }\n  }\n\n  return location;\n}; // Find the package.json object of the module closest up the module call tree that contains name in that module's peerOptionalDependencies\n\n\nvar find_package_json_with_name = function (name) {\n  // Walk up the module call tree until we find a module containing name in its peerOptionalDependencies\n  var currentModule = module;\n  var found = false;\n\n  while (currentModule) {\n    // Check currentModule has a package.json\n    location = currentModule.filename;\n    var location = find_package_json(location);\n\n    if (!location) {\n      currentModule = currentModule.parent;\n      continue;\n    } // Read the package.json file\n\n\n    var object = JSON.parse(fs.readFileSync(f('%s/package.json', location))); // Is the name defined by interal file references\n\n    var parts = name.split(/\\//); // Check whether this package.json contains peerOptionalDependencies containing the name we're searching for\n\n    if (!object.peerOptionalDependencies || object.peerOptionalDependencies && !object.peerOptionalDependencies[parts[0]]) {\n      currentModule = currentModule.parent;\n      continue;\n    }\n\n    found = true;\n    break;\n  } // Check whether name has been found in currentModule's peerOptionalDependencies\n\n\n  if (!found) {\n    throw new Error(f('no optional dependency [%s] defined in peerOptionalDependencies in any package.json', parts[0]));\n  }\n\n  return {\n    object: object,\n    parts: parts\n  };\n};\n\nvar require_optional = function (name, options) {\n  options = options || {};\n  options.strict = typeof options.strict == 'boolean' ? options.strict : true;\n  var res = find_package_json_with_name(name);\n  var object = res.object;\n  var parts = res.parts; // Unpack the expected version\n\n  var expectedVersions = object.peerOptionalDependencies[parts[0]]; // The resolved package\n\n  var moduleEntry = undefined; // Module file\n\n  var moduleEntryFile = name;\n\n  try {\n    // Validate if it's possible to read the module\n    moduleEntry = require(moduleEntryFile);\n  } catch (err) {\n    // Attempt to resolve in top level package\n    try {\n      // Get the module entry file\n      moduleEntryFile = resolveFrom(process.cwd(), name);\n      if (moduleEntryFile == null) return undefined; // Attempt to resolve the module\n\n      moduleEntry = require(moduleEntryFile);\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') return undefined;\n    }\n  } // Resolve the location of the module's package.json file\n\n\n  var location = find_package_json(require.resolve(moduleEntryFile));\n\n  if (!location) {\n    throw new Error('package.json can not be located');\n  } // Read the module file\n\n\n  var dependentOnModule = JSON.parse(fs.readFileSync(f('%s/package.json', location))); // Get the version\n\n  var version = dependentOnModule.version; // Validate if the found module satisfies the version id\n\n  if (semver.satisfies(version, expectedVersions) == false && options.strict) {\n    var error = new Error(f('optional dependency [%s] found but version [%s] did not satisfy constraint [%s]', parts[0], version, expectedVersions));\n    error.code = 'OPTIONAL_MODULE_NOT_FOUND';\n    throw error;\n  } // Satifies the module requirement\n\n\n  return moduleEntry;\n};\n\nrequire_optional.exists = function (name) {\n  try {\n    var m = require_optional(name);\n    if (m === undefined) return false;\n    return true;\n  } catch (err) {\n    return false;\n  }\n};\n\nmodule.exports = require_optional;","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/require_optional/index.js"],"names":["path","require","fs","f","format","resolveFrom","semver","exists","existsSync","find_package_json","location","found","dirname","find_package_json_with_name","name","currentModule","module","filename","parent","object","JSON","parse","readFileSync","parts","split","peerOptionalDependencies","Error","require_optional","options","strict","res","expectedVersions","moduleEntry","undefined","moduleEntryFile","err","process","cwd","code","resolve","dependentOnModule","version","satisfies","error","m","exports"],"mappings":"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","sourcesContent":["var path = require('path'),\n  fs = require('fs'),\n  f = require('util').format,\n  resolveFrom = require('resolve-from'),\n  semver = require('semver');\n\nvar exists = fs.existsSync || path.existsSync;\n\n// Find the location of a package.json file near or above the given location\nvar find_package_json = function(location) {\n  var found = false;\n\n  while(!found) {\n    if (exists(location + '/package.json')) {\n      found = location;\n    } else if (location !== '/') {\n      location = path.dirname(location);\n    } else {\n      return false;\n    }\n  }\n\n  return location;\n}\n\n// Find the package.json object of the module closest up the module call tree that contains name in that module's peerOptionalDependencies\nvar find_package_json_with_name = function(name) {\n  // Walk up the module call tree until we find a module containing name in its peerOptionalDependencies\n  var currentModule = module;\n  var found = false;\n  while (currentModule) {\n    // Check currentModule has a package.json\n    location = currentModule.filename;\n    var location = find_package_json(location)\n    if (!location) {\n      currentModule = currentModule.parent;\n      continue;\n    }\n\n    // Read the package.json file\n    var object = JSON.parse(fs.readFileSync(f('%s/package.json', location)));\n    // Is the name defined by interal file references\n    var parts = name.split(/\\//);\n\n    // Check whether this package.json contains peerOptionalDependencies containing the name we're searching for\n    if (!object.peerOptionalDependencies || (object.peerOptionalDependencies && !object.peerOptionalDependencies[parts[0]])) {\n      currentModule = currentModule.parent;\n      continue;\n    }\n    found = true;\n    break;\n  }\n\n  // Check whether name has been found in currentModule's peerOptionalDependencies\n  if (!found) {\n    throw new Error(f('no optional dependency [%s] defined in peerOptionalDependencies in any package.json', parts[0]));\n  }\n\n  return {\n    object: object,\n    parts: parts\n  }\n}\n\nvar require_optional = function(name, options) {\n  options = options || {};\n  options.strict = typeof options.strict == 'boolean' ? options.strict : true;\n\n  var res = find_package_json_with_name(name)\n  var object = res.object;\n  var parts = res.parts;\n\n  // Unpack the expected version\n  var expectedVersions = object.peerOptionalDependencies[parts[0]];\n  // The resolved package\n  var moduleEntry = undefined;\n  // Module file\n  var moduleEntryFile = name;\n\n  try {\n    // Validate if it's possible to read the module\n    moduleEntry = require(moduleEntryFile);\n  } catch(err) {\n    // Attempt to resolve in top level package\n    try {\n      // Get the module entry file\n      moduleEntryFile = resolveFrom(process.cwd(), name);\n      if(moduleEntryFile == null) return undefined;\n      // Attempt to resolve the module\n      moduleEntry = require(moduleEntryFile);\n    } catch(err) {\n      if(err.code === 'MODULE_NOT_FOUND') return undefined;\n    }\n  }\n\n  // Resolve the location of the module's package.json file\n  var location = find_package_json(require.resolve(moduleEntryFile));\n  if(!location) {\n    throw new Error('package.json can not be located');\n  }\n\n  // Read the module file\n  var dependentOnModule = JSON.parse(fs.readFileSync(f('%s/package.json', location)));\n  // Get the version\n  var version = dependentOnModule.version;\n  // Validate if the found module satisfies the version id\n  if(semver.satisfies(version, expectedVersions) == false\n    && options.strict) {\n      var error = new Error(f('optional dependency [%s] found but version [%s] did not satisfy constraint [%s]', parts[0], version, expectedVersions));\n      error.code = 'OPTIONAL_MODULE_NOT_FOUND';\n      throw error;\n  }\n\n  // Satifies the module requirement\n  return moduleEntry;\n}\n\nrequire_optional.exists = function(name) {\n  try {\n    var m = require_optional(name);\n    if(m === undefined) return false;\n    return true;\n  } catch(err) {\n    return false;\n  }\n}\n\nmodule.exports = require_optional;\n"]},"metadata":{},"sourceType":"script"}