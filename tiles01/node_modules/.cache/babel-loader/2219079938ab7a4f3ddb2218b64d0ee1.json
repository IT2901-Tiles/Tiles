{"ast":null,"code":"'use strict';\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst Code = require('../core').BSON.Code;\n\nconst decorateWithCollation = require('../utils').decorateWithCollation;\n\nconst decorateWithReadConcern = require('../utils').decorateWithReadConcern;\n\nconst executeCommand = require('./db_ops').executeCommand;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst isObject = require('../utils').isObject;\n\nconst loadDb = require('../dynamic_loaders').loadDb;\n\nconst OperationBase = require('./operation').OperationBase;\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst toError = require('../utils').toError;\n\nconst Aspect = require('./operation').Aspect;\n\nconst defineAspects = require('./operation').defineAspects;\n\nconst decorateWithExplain = require('../utils').decorateWithExplain;\n\nconst maxWireVersion = require('../core/utils').maxWireVersion;\n\nconst MongoError = require('../error').MongoError;\n\nconst exclusionList = ['explain', 'readPreference', 'session', 'bypassDocumentValidation', 'w', 'wtimeout', 'j', 'writeConcern'];\n/**\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n *\n * @class\n * @property {Collection} a Collection instance.\n * @property {(function|string)} map The mapping function.\n * @property {(function|string)} reduce The reduce function.\n * @property {object} [options] Optional settings. See Collection.prototype.mapReduce for a list of options.\n */\n\nclass MapReduceOperation extends OperationBase {\n  /**\n   * Constructs a MapReduce operation.\n   *\n   * @param {Collection} a Collection instance.\n   * @param {(function|string)} map The mapping function.\n   * @param {(function|string)} reduce The reduce function.\n   * @param {object} [options] Optional settings. See Collection.prototype.mapReduce for a list of options.\n   */\n  constructor(collection, map, reduce, options) {\n    super(options);\n    this.collection = collection;\n    this.map = map;\n    this.reduce = reduce;\n  }\n  /**\n   * Execute the operation.\n   *\n   * @param {Collection~resultCallback} [callback] The command result callback\n   */\n\n\n  execute(callback) {\n    const coll = this.collection;\n    const map = this.map;\n    const reduce = this.reduce;\n    let options = this.options;\n    let mapCommandHash = {\n      mapReduce: coll.collectionName,\n      map: map,\n      reduce: reduce\n    }; // Add any other options passed in\n\n    for (let n in options) {\n      if ('scope' === n) {\n        mapCommandHash[n] = processScope(options[n]);\n      } else {\n        // Only include if not in exclusion list\n        if (exclusionList.indexOf(n) === -1) {\n          mapCommandHash[n] = options[n];\n        }\n      }\n    }\n\n    options = Object.assign({}, options); // Ensure we have the right read preference inheritance\n\n    options.readPreference = ReadPreference.resolve(coll, options); // If we have a read preference and inline is not set as output fail hard\n\n    if (options.readPreference !== false && options.readPreference !== 'primary' && options['out'] && options['out'].inline !== 1 && options['out'] !== 'inline') {\n      // Force readPreference to primary\n      options.readPreference = 'primary'; // Decorate command with writeConcern if supported\n\n      applyWriteConcern(mapCommandHash, {\n        db: coll.s.db,\n        collection: coll\n      }, options);\n    } else {\n      decorateWithReadConcern(mapCommandHash, coll, options);\n    } // Is bypassDocumentValidation specified\n\n\n    if (options.bypassDocumentValidation === true) {\n      mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;\n    } // Have we specified collation\n\n\n    try {\n      decorateWithCollation(mapCommandHash, coll, options);\n    } catch (err) {\n      return callback(err, null);\n    }\n\n    if (this.explain) {\n      if (maxWireVersion(coll.s.topology) < 9) {\n        callback(new MongoError(`server does not support explain on mapReduce`));\n        return;\n      }\n\n      mapCommandHash = decorateWithExplain(mapCommandHash, this.explain);\n    } // Execute command\n\n\n    executeCommand(coll.s.db, mapCommandHash, options, (err, result) => {\n      if (err) return handleCallback(callback, err); // Check if we have an error\n\n      if (1 !== result.ok || result.err || result.errmsg) {\n        return handleCallback(callback, toError(result));\n      } // If an explain operation was executed, don't process the server results\n\n\n      if (this.explain) return callback(undefined, result); // Create statistics value\n\n      const stats = {};\n      if (result.timeMillis) stats['processtime'] = result.timeMillis;\n      if (result.counts) stats['counts'] = result.counts;\n      if (result.timing) stats['timing'] = result.timing; // invoked with inline?\n\n      if (result.results) {\n        // If we wish for no verbosity\n        if (options['verbose'] == null || !options['verbose']) {\n          return handleCallback(callback, null, result.results);\n        }\n\n        return handleCallback(callback, null, {\n          results: result.results,\n          stats: stats\n        });\n      } // The returned collection\n\n\n      let collection = null; // If we have an object it's a different db\n\n      if (result.result != null && typeof result.result === 'object') {\n        const doc = result.result; // Return a collection from another db\n\n        let Db = loadDb();\n        collection = new Db(doc.db, coll.s.db.s.topology, coll.s.db.s.options).collection(doc.collection);\n      } else {\n        // Create a collection object that wraps the result collection\n        collection = coll.s.db.collection(result.result);\n      } // If we wish for no verbosity\n\n\n      if (options['verbose'] == null || !options['verbose']) {\n        return handleCallback(callback, err, collection);\n      } // Return stats as third set of values\n\n\n      handleCallback(callback, err, {\n        collection: collection,\n        stats: stats\n      });\n    });\n  }\n\n}\n/**\n * Functions that are passed as scope args must\n * be converted to Code instances.\n * @ignore\n */\n\n\nfunction processScope(scope) {\n  if (!isObject(scope) || scope._bsontype === 'ObjectID') {\n    return scope;\n  }\n\n  const keys = Object.keys(scope);\n  let key;\n  const new_scope = {};\n\n  for (let i = keys.length - 1; i >= 0; i--) {\n    key = keys[i];\n\n    if ('function' === typeof scope[key]) {\n      new_scope[key] = new Code(String(scope[key]));\n    } else {\n      new_scope[key] = processScope(scope[key]);\n    }\n  }\n\n  return new_scope;\n}\n\ndefineAspects(MapReduceOperation, [Aspect.EXPLAINABLE]);\nmodule.exports = MapReduceOperation;","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/operations/map_reduce.js"],"names":["applyWriteConcern","require","Code","BSON","decorateWithCollation","decorateWithReadConcern","executeCommand","handleCallback","isObject","loadDb","OperationBase","ReadPreference","toError","Aspect","defineAspects","decorateWithExplain","maxWireVersion","MongoError","exclusionList","MapReduceOperation","constructor","collection","map","reduce","options","execute","callback","coll","mapCommandHash","mapReduce","collectionName","n","processScope","indexOf","Object","assign","readPreference","resolve","inline","db","s","bypassDocumentValidation","err","explain","topology","result","ok","errmsg","undefined","stats","timeMillis","counts","timing","results","doc","Db","scope","_bsontype","keys","key","new_scope","i","length","String","EXPLAINABLE","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\nconst Code = require('../core').BSON.Code;\nconst decorateWithCollation = require('../utils').decorateWithCollation;\nconst decorateWithReadConcern = require('../utils').decorateWithReadConcern;\nconst executeCommand = require('./db_ops').executeCommand;\nconst handleCallback = require('../utils').handleCallback;\nconst isObject = require('../utils').isObject;\nconst loadDb = require('../dynamic_loaders').loadDb;\nconst OperationBase = require('./operation').OperationBase;\nconst ReadPreference = require('../core').ReadPreference;\nconst toError = require('../utils').toError;\nconst Aspect = require('./operation').Aspect;\nconst defineAspects = require('./operation').defineAspects;\nconst decorateWithExplain = require('../utils').decorateWithExplain;\nconst maxWireVersion = require('../core/utils').maxWireVersion;\nconst MongoError = require('../error').MongoError;\n\nconst exclusionList = [\n  'explain',\n  'readPreference',\n  'session',\n  'bypassDocumentValidation',\n  'w',\n  'wtimeout',\n  'j',\n  'writeConcern'\n];\n\n/**\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n *\n * @class\n * @property {Collection} a Collection instance.\n * @property {(function|string)} map The mapping function.\n * @property {(function|string)} reduce The reduce function.\n * @property {object} [options] Optional settings. See Collection.prototype.mapReduce for a list of options.\n */\nclass MapReduceOperation extends OperationBase {\n  /**\n   * Constructs a MapReduce operation.\n   *\n   * @param {Collection} a Collection instance.\n   * @param {(function|string)} map The mapping function.\n   * @param {(function|string)} reduce The reduce function.\n   * @param {object} [options] Optional settings. See Collection.prototype.mapReduce for a list of options.\n   */\n  constructor(collection, map, reduce, options) {\n    super(options);\n\n    this.collection = collection;\n    this.map = map;\n    this.reduce = reduce;\n  }\n\n  /**\n   * Execute the operation.\n   *\n   * @param {Collection~resultCallback} [callback] The command result callback\n   */\n  execute(callback) {\n    const coll = this.collection;\n    const map = this.map;\n    const reduce = this.reduce;\n    let options = this.options;\n\n    let mapCommandHash = {\n      mapReduce: coll.collectionName,\n      map: map,\n      reduce: reduce\n    };\n\n    // Add any other options passed in\n    for (let n in options) {\n      if ('scope' === n) {\n        mapCommandHash[n] = processScope(options[n]);\n      } else {\n        // Only include if not in exclusion list\n        if (exclusionList.indexOf(n) === -1) {\n          mapCommandHash[n] = options[n];\n        }\n      }\n    }\n\n    options = Object.assign({}, options);\n\n    // Ensure we have the right read preference inheritance\n    options.readPreference = ReadPreference.resolve(coll, options);\n\n    // If we have a read preference and inline is not set as output fail hard\n    if (\n      options.readPreference !== false &&\n      options.readPreference !== 'primary' &&\n      options['out'] &&\n      options['out'].inline !== 1 &&\n      options['out'] !== 'inline'\n    ) {\n      // Force readPreference to primary\n      options.readPreference = 'primary';\n      // Decorate command with writeConcern if supported\n      applyWriteConcern(mapCommandHash, { db: coll.s.db, collection: coll }, options);\n    } else {\n      decorateWithReadConcern(mapCommandHash, coll, options);\n    }\n\n    // Is bypassDocumentValidation specified\n    if (options.bypassDocumentValidation === true) {\n      mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    // Have we specified collation\n    try {\n      decorateWithCollation(mapCommandHash, coll, options);\n    } catch (err) {\n      return callback(err, null);\n    }\n\n    if (this.explain) {\n      if (maxWireVersion(coll.s.topology) < 9) {\n        callback(new MongoError(`server does not support explain on mapReduce`));\n        return;\n      }\n      mapCommandHash = decorateWithExplain(mapCommandHash, this.explain);\n    }\n\n    // Execute command\n    executeCommand(coll.s.db, mapCommandHash, options, (err, result) => {\n      if (err) return handleCallback(callback, err);\n      // Check if we have an error\n      if (1 !== result.ok || result.err || result.errmsg) {\n        return handleCallback(callback, toError(result));\n      }\n\n      // If an explain operation was executed, don't process the server results\n      if (this.explain) return callback(undefined, result);\n\n      // Create statistics value\n      const stats = {};\n      if (result.timeMillis) stats['processtime'] = result.timeMillis;\n      if (result.counts) stats['counts'] = result.counts;\n      if (result.timing) stats['timing'] = result.timing;\n\n      // invoked with inline?\n      if (result.results) {\n        // If we wish for no verbosity\n        if (options['verbose'] == null || !options['verbose']) {\n          return handleCallback(callback, null, result.results);\n        }\n\n        return handleCallback(callback, null, { results: result.results, stats: stats });\n      }\n\n      // The returned collection\n      let collection = null;\n\n      // If we have an object it's a different db\n      if (result.result != null && typeof result.result === 'object') {\n        const doc = result.result;\n        // Return a collection from another db\n        let Db = loadDb();\n        collection = new Db(doc.db, coll.s.db.s.topology, coll.s.db.s.options).collection(\n          doc.collection\n        );\n      } else {\n        // Create a collection object that wraps the result collection\n        collection = coll.s.db.collection(result.result);\n      }\n\n      // If we wish for no verbosity\n      if (options['verbose'] == null || !options['verbose']) {\n        return handleCallback(callback, err, collection);\n      }\n\n      // Return stats as third set of values\n      handleCallback(callback, err, { collection: collection, stats: stats });\n    });\n  }\n}\n\n/**\n * Functions that are passed as scope args must\n * be converted to Code instances.\n * @ignore\n */\nfunction processScope(scope) {\n  if (!isObject(scope) || scope._bsontype === 'ObjectID') {\n    return scope;\n  }\n\n  const keys = Object.keys(scope);\n  let key;\n  const new_scope = {};\n\n  for (let i = keys.length - 1; i >= 0; i--) {\n    key = keys[i];\n    if ('function' === typeof scope[key]) {\n      new_scope[key] = new Code(String(scope[key]));\n    } else {\n      new_scope[key] = processScope(scope[key]);\n    }\n  }\n\n  return new_scope;\n}\n\ndefineAspects(MapReduceOperation, [Aspect.EXPLAINABLE]);\n\nmodule.exports = MapReduceOperation;\n"]},"metadata":{},"sourceType":"script"}