{"ast":null,"code":"'use strict';\n\nvar inherits = require('util').inherits,\n    f = require('util').format,\n    EventEmitter = require('events').EventEmitter,\n    ReadPreference = require('./read_preference'),\n    Logger = require('../connection/logger'),\n    debugOptions = require('../connection/utils').debugOptions,\n    retrieveBSON = require('../connection/utils').retrieveBSON,\n    Pool = require('../connection/pool'),\n    MongoError = require('../error').MongoError,\n    MongoNetworkError = require('../error').MongoNetworkError,\n    wireProtocol = require('../wireprotocol'),\n    CoreCursor = require('../cursor').CoreCursor,\n    sdam = require('./shared'),\n    createCompressionInfo = require('./shared').createCompressionInfo,\n    resolveClusterTime = require('./shared').resolveClusterTime,\n    SessionMixins = require('./shared').SessionMixins,\n    relayEvents = require('../utils').relayEvents;\n\nconst collationNotSupported = require('../utils').collationNotSupported;\n\nconst makeClientMetadata = require('../utils').makeClientMetadata; // Used for filtering out fields for loggin\n\n\nvar debugFields = ['reconnect', 'reconnectTries', 'reconnectInterval', 'emitError', 'cursorFactory', 'host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'checkServerIdentity', 'socketTimeout', 'ssl', 'ca', 'crl', 'cert', 'key', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'servername']; // Server instance id\n\nvar id = 0;\nvar serverAccounting = false;\nvar servers = {};\nvar BSON = retrieveBSON();\n\nfunction topologyId(server) {\n  return server.s.parent == null ? server.id : server.s.parent.id;\n}\n/**\n * Creates a new Server instance\n * @class\n * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\n * @param {number} [options.monitoring=true] Enable the server state monitoring (calling ismaster at monitoringInterval)\n * @param {number} [options.monitoringInterval=5000] The interval of calling ismaster when monitoring is enabled.\n * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.size=5] Server connection pool size\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {string} [options.appname=null] Application name, passed in on ismaster call and logged in mongod server logs. Maximum size 128 bytes.\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\n * @return {Server} A cursor instance\n * @fires Server#connect\n * @fires Server#close\n * @fires Server#error\n * @fires Server#timeout\n * @fires Server#parseError\n * @fires Server#reconnect\n * @fires Server#reconnectFailed\n * @fires Server#serverHeartbeatStarted\n * @fires Server#serverHeartbeatSucceeded\n * @fires Server#serverHeartbeatFailed\n * @fires Server#topologyOpening\n * @fires Server#topologyClosed\n * @fires Server#topologyDescriptionChanged\n * @property {string} type the topology type.\n * @property {string} parserType the parser type used (c++ or js).\n */\n\n\nvar Server = function (options) {\n  options = options || {}; // Add event listener\n\n  EventEmitter.call(this); // Server instance id\n\n  this.id = id++; // Internal state\n\n  this.s = {\n    // Options\n    options: Object.assign({\n      metadata: makeClientMetadata(options)\n    }, options),\n    // Logger\n    logger: Logger('Server', options),\n    // Factory overrides\n    Cursor: options.cursorFactory || CoreCursor,\n    // BSON instance\n    bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),\n    // Pool\n    pool: null,\n    // Disconnect handler\n    disconnectHandler: options.disconnectHandler,\n    // Monitor thread (keeps the connection alive)\n    monitoring: typeof options.monitoring === 'boolean' ? options.monitoring : true,\n    // Is the server in a topology\n    inTopology: !!options.parent,\n    // Monitoring timeout\n    monitoringInterval: typeof options.monitoringInterval === 'number' ? options.monitoringInterval : 5000,\n    compression: {\n      compressors: createCompressionInfo(options)\n    },\n    // Optional parent topology\n    parent: options.parent\n  }; // If this is a single deployment we need to track the clusterTime here\n\n  if (!this.s.parent) {\n    this.s.clusterTime = null;\n  } // Curent ismaster\n\n\n  this.ismaster = null; // Current ping time\n\n  this.lastIsMasterMS = -1; // The monitoringProcessId\n\n  this.monitoringProcessId = null; // Initial connection\n\n  this.initialConnect = true; // Default type\n\n  this._type = 'server'; // Max Stalleness values\n  // last time we updated the ismaster state\n\n  this.lastUpdateTime = 0; // Last write time\n\n  this.lastWriteDate = 0; // Stalleness\n\n  this.staleness = 0;\n};\n\ninherits(Server, EventEmitter);\nObject.assign(Server.prototype, SessionMixins);\nObject.defineProperty(Server.prototype, 'type', {\n  enumerable: true,\n  get: function () {\n    return this._type;\n  }\n});\nObject.defineProperty(Server.prototype, 'parserType', {\n  enumerable: true,\n  get: function () {\n    return BSON.native ? 'c++' : 'js';\n  }\n});\nObject.defineProperty(Server.prototype, 'logicalSessionTimeoutMinutes', {\n  enumerable: true,\n  get: function () {\n    if (!this.ismaster) return null;\n    return this.ismaster.logicalSessionTimeoutMinutes || null;\n  }\n});\nObject.defineProperty(Server.prototype, 'clientMetadata', {\n  enumerable: true,\n  get: function () {\n    return this.s.options.metadata;\n  }\n}); // In single server deployments we track the clusterTime directly on the topology, however\n// in Mongos and ReplSet deployments we instead need to delegate the clusterTime up to the\n// tracking objects so we can ensure we are gossiping the maximum time received from the\n// server.\n\nObject.defineProperty(Server.prototype, 'clusterTime', {\n  enumerable: true,\n  set: function (clusterTime) {\n    const settings = this.s.parent ? this.s.parent : this.s;\n    resolveClusterTime(settings, clusterTime);\n  },\n  get: function () {\n    const settings = this.s.parent ? this.s.parent : this.s;\n    return settings.clusterTime || null;\n  }\n});\n\nServer.enableServerAccounting = function () {\n  serverAccounting = true;\n  servers = {};\n};\n\nServer.disableServerAccounting = function () {\n  serverAccounting = false;\n};\n\nServer.servers = function () {\n  return servers;\n};\n\nObject.defineProperty(Server.prototype, 'name', {\n  enumerable: true,\n  get: function () {\n    return this.s.options.host + ':' + this.s.options.port;\n  }\n});\n\nfunction disconnectHandler(self, type, ns, cmd, options, callback) {\n  // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n  if (!self.s.pool.isConnected() && self.s.options.reconnect && self.s.disconnectHandler != null && !options.monitoring) {\n    self.s.disconnectHandler.add(type, ns, cmd, options, callback);\n    return true;\n  } // If we have no connection error\n\n\n  if (!self.s.pool.isConnected()) {\n    callback(new MongoError(f('no connection available to server %s', self.name)));\n    return true;\n  }\n}\n\nfunction monitoringProcess(self) {\n  return function () {\n    // Pool was destroyed do not continue process\n    if (self.s.pool.isDestroyed()) return; // Emit monitoring Process event\n\n    self.emit('monitoring', self); // Perform ismaster call\n    // Get start time\n\n    var start = new Date().getTime(); // Execute the ismaster query\n\n    self.command('admin.$cmd', {\n      ismaster: true\n    }, {\n      socketTimeout: typeof self.s.options.connectionTimeout !== 'number' ? 2000 : self.s.options.connectionTimeout,\n      monitoring: true\n    }, (err, result) => {\n      // Set initial lastIsMasterMS\n      self.lastIsMasterMS = new Date().getTime() - start;\n      if (self.s.pool.isDestroyed()) return; // Update the ismaster view if we have a result\n\n      if (result) {\n        self.ismaster = result.result;\n      } // Re-schedule the monitoring process\n\n\n      self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);\n    });\n  };\n}\n\nvar eventHandler = function (self, event) {\n  return function (err, conn) {\n    // Log information of received information if in info mode\n    if (self.s.logger.isInfo()) {\n      var object = err instanceof MongoError ? JSON.stringify(err) : {};\n      self.s.logger.info(f('server %s fired event %s out with message %s', self.name, event, object));\n    } // Handle connect event\n\n\n    if (event === 'connect') {\n      self.initialConnect = false;\n      self.ismaster = conn.ismaster;\n      self.lastIsMasterMS = conn.lastIsMasterMS;\n\n      if (conn.agreedCompressor) {\n        self.s.pool.options.agreedCompressor = conn.agreedCompressor;\n      }\n\n      if (conn.zlibCompressionLevel) {\n        self.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;\n      }\n\n      if (conn.ismaster.$clusterTime) {\n        const $clusterTime = conn.ismaster.$clusterTime;\n        self.clusterTime = $clusterTime;\n      } // It's a proxy change the type so\n      // the wireprotocol will send $readPreference\n\n\n      if (self.ismaster.msg === 'isdbgrid') {\n        self._type = 'mongos';\n      } // Have we defined self monitoring\n\n\n      if (self.s.monitoring) {\n        self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);\n      } // Emit server description changed if something listening\n\n\n      sdam.emitServerDescriptionChanged(self, {\n        address: self.name,\n        arbiters: [],\n        hosts: [],\n        passives: [],\n        type: sdam.getTopologyType(self)\n      });\n\n      if (!self.s.inTopology) {\n        // Emit topology description changed if something listening\n        sdam.emitTopologyDescriptionChanged(self, {\n          topologyType: 'Single',\n          servers: [{\n            address: self.name,\n            arbiters: [],\n            hosts: [],\n            passives: [],\n            type: sdam.getTopologyType(self)\n          }]\n        });\n      } // Log the ismaster if available\n\n\n      if (self.s.logger.isInfo()) {\n        self.s.logger.info(f('server %s connected with ismaster [%s]', self.name, JSON.stringify(self.ismaster)));\n      } // Emit connect\n\n\n      self.emit('connect', self);\n    } else if (event === 'error' || event === 'parseError' || event === 'close' || event === 'timeout' || event === 'reconnect' || event === 'attemptReconnect' || event === 'reconnectFailed') {\n      // Remove server instance from accounting\n      if (serverAccounting && ['close', 'timeout', 'error', 'parseError', 'reconnectFailed'].indexOf(event) !== -1) {\n        // Emit toplogy opening event if not in topology\n        if (!self.s.inTopology) {\n          self.emit('topologyOpening', {\n            topologyId: self.id\n          });\n        }\n\n        delete servers[self.id];\n      }\n\n      if (event === 'close') {\n        // Closing emits a server description changed event going to unknown.\n        sdam.emitServerDescriptionChanged(self, {\n          address: self.name,\n          arbiters: [],\n          hosts: [],\n          passives: [],\n          type: 'Unknown'\n        });\n      } // Reconnect failed return error\n\n\n      if (event === 'reconnectFailed') {\n        self.emit('reconnectFailed', err); // Emit error if any listeners\n\n        if (self.listeners('error').length > 0) {\n          self.emit('error', err);\n        } // Terminate\n\n\n        return;\n      } // On first connect fail\n\n\n      if (['disconnected', 'connecting'].indexOf(self.s.pool.state) !== -1 && self.initialConnect && ['close', 'timeout', 'error', 'parseError'].indexOf(event) !== -1) {\n        self.initialConnect = false;\n        return self.emit('error', new MongoNetworkError(f('failed to connect to server [%s] on first connect [%s]', self.name, err)));\n      } // Reconnect event, emit the server\n\n\n      if (event === 'reconnect') {\n        // Reconnecting emits a server description changed event going from unknown to the\n        // current server type.\n        sdam.emitServerDescriptionChanged(self, {\n          address: self.name,\n          arbiters: [],\n          hosts: [],\n          passives: [],\n          type: sdam.getTopologyType(self)\n        });\n        return self.emit(event, self);\n      } // Emit the event\n\n\n      self.emit(event, err);\n    }\n  };\n};\n/**\n * Initiate server connect\n */\n\n\nServer.prototype.connect = function (options) {\n  var self = this;\n  options = options || {}; // Set the connections\n\n  if (serverAccounting) servers[this.id] = this; // Do not allow connect to be called on anything that's not disconnected\n\n  if (self.s.pool && !self.s.pool.isDisconnected() && !self.s.pool.isDestroyed()) {\n    throw new MongoError(f('server instance in invalid state %s', self.s.pool.state));\n  } // Create a pool\n\n\n  self.s.pool = new Pool(this, Object.assign(self.s.options, options, {\n    bson: this.s.bson\n  })); // Set up listeners\n\n  self.s.pool.on('close', eventHandler(self, 'close'));\n  self.s.pool.on('error', eventHandler(self, 'error'));\n  self.s.pool.on('timeout', eventHandler(self, 'timeout'));\n  self.s.pool.on('parseError', eventHandler(self, 'parseError'));\n  self.s.pool.on('connect', eventHandler(self, 'connect'));\n  self.s.pool.on('reconnect', eventHandler(self, 'reconnect'));\n  self.s.pool.on('reconnectFailed', eventHandler(self, 'reconnectFailed')); // Set up listeners for command monitoring\n\n  relayEvents(self.s.pool, self, ['commandStarted', 'commandSucceeded', 'commandFailed']); // Emit toplogy opening event if not in topology\n\n  if (!self.s.inTopology) {\n    this.emit('topologyOpening', {\n      topologyId: topologyId(self)\n    });\n  } // Emit opening server event\n\n\n  self.emit('serverOpening', {\n    topologyId: topologyId(self),\n    address: self.name\n  });\n  self.s.pool.connect();\n};\n/**\n * Authenticate the topology.\n * @method\n * @param {MongoCredentials} credentials The credentials for authentication we are using\n * @param {authResultCallback} callback A callback function\n */\n\n\nServer.prototype.auth = function (credentials, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n/**\n * Get the server description\n * @method\n * @return {object}\n */\n\n\nServer.prototype.getDescription = function () {\n  var ismaster = this.ismaster || {};\n  var description = {\n    type: sdam.getTopologyType(this),\n    address: this.name\n  }; // Add fields if available\n\n  if (ismaster.hosts) description.hosts = ismaster.hosts;\n  if (ismaster.arbiters) description.arbiters = ismaster.arbiters;\n  if (ismaster.passives) description.passives = ismaster.passives;\n  if (ismaster.setName) description.setName = ismaster.setName;\n  return description;\n};\n/**\n * Returns the last known ismaster document for this server\n * @method\n * @return {object}\n */\n\n\nServer.prototype.lastIsMaster = function () {\n  return this.ismaster;\n};\n/**\n * Unref all connections belong to this server\n * @method\n */\n\n\nServer.prototype.unref = function () {\n  this.s.pool.unref();\n};\n/**\n * Figure out if the server is connected\n * @method\n * @return {boolean}\n */\n\n\nServer.prototype.isConnected = function () {\n  if (!this.s.pool) return false;\n  return this.s.pool.isConnected();\n};\n/**\n * Figure out if the server instance was destroyed by calling destroy\n * @method\n * @return {boolean}\n */\n\n\nServer.prototype.isDestroyed = function () {\n  if (!this.s.pool) return false;\n  return this.s.pool.isDestroyed();\n};\n\nfunction basicWriteValidations(self) {\n  if (!self.s.pool) return new MongoError('server instance is not connected');\n  if (self.s.pool.isDestroyed()) return new MongoError('server instance pool was destroyed');\n}\n\nfunction basicReadValidations(self, options) {\n  basicWriteValidations(self, options);\n\n  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {\n    throw new Error('readPreference must be an instance of ReadPreference');\n  }\n}\n/**\n * Execute a command\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cmd The command hash\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\n\n\nServer.prototype.command = function (ns, cmd, options, callback) {\n  var self = this;\n\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n\n  var result = basicReadValidations(self, options);\n  if (result) return callback(result); // Clone the options\n\n  options = Object.assign({}, options, {\n    wireProtocolCommand: false\n  }); // Debug log\n\n  if (self.s.logger.isDebug()) self.s.logger.debug(f('executing command [%s] against %s', JSON.stringify({\n    ns: ns,\n    cmd: cmd,\n    options: debugOptions(debugFields, options)\n  }), self.name)); // If we are not connected or have a disconnectHandler specified\n\n  if (disconnectHandler(self, 'command', ns, cmd, options, callback)) return; // error if collation not supported\n\n  if (collationNotSupported(this, cmd)) {\n    return callback(new MongoError(`server ${this.name} does not support collation`));\n  }\n\n  wireProtocol.command(self, ns, cmd, options, callback);\n};\n/**\n * Execute a query against the server\n *\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cmd The command document for the query\n * @param {object} options Optional settings\n * @param {function} callback\n */\n\n\nServer.prototype.query = function (ns, cmd, cursorState, options, callback) {\n  wireProtocol.query(this, ns, cmd, cursorState, options, callback);\n};\n/**\n * Execute a `getMore` against the server\n *\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cursorState State data associated with the cursor calling this method\n * @param {object} options Optional settings\n * @param {function} callback\n */\n\n\nServer.prototype.getMore = function (ns, cursorState, batchSize, options, callback) {\n  wireProtocol.getMore(this, ns, cursorState, batchSize, options, callback);\n};\n/**\n * Execute a `killCursors` command against the server\n *\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cursorState State data associated with the cursor calling this method\n * @param {function} callback\n */\n\n\nServer.prototype.killCursors = function (ns, cursorState, callback) {\n  wireProtocol.killCursors(this, ns, cursorState, callback);\n};\n/**\n * Insert one or more documents\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of documents to insert\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\n\n\nServer.prototype.insert = function (ns, ops, options, callback) {\n  var self = this;\n\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n\n  var result = basicWriteValidations(self, options);\n  if (result) return callback(result); // If we are not connected or have a disconnectHandler specified\n\n  if (disconnectHandler(self, 'insert', ns, ops, options, callback)) return; // Setup the docs as an array\n\n  ops = Array.isArray(ops) ? ops : [ops]; // Execute write\n\n  return wireProtocol.insert(self, ns, ops, options, callback);\n};\n/**\n * Perform one or more update operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of updates\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\n\n\nServer.prototype.update = function (ns, ops, options, callback) {\n  var self = this;\n\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n\n  var result = basicWriteValidations(self, options);\n  if (result) return callback(result); // If we are not connected or have a disconnectHandler specified\n\n  if (disconnectHandler(self, 'update', ns, ops, options, callback)) return; // error if collation not supported\n\n  if (collationNotSupported(this, options)) {\n    return callback(new MongoError(`server ${this.name} does not support collation`));\n  } // Setup the docs as an array\n\n\n  ops = Array.isArray(ops) ? ops : [ops]; // Execute write\n\n  return wireProtocol.update(self, ns, ops, options, callback);\n};\n/**\n * Perform one or more remove operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of removes\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\n\n\nServer.prototype.remove = function (ns, ops, options, callback) {\n  var self = this;\n\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n\n  var result = basicWriteValidations(self, options);\n  if (result) return callback(result); // If we are not connected or have a disconnectHandler specified\n\n  if (disconnectHandler(self, 'remove', ns, ops, options, callback)) return; // error if collation not supported\n\n  if (collationNotSupported(this, options)) {\n    return callback(new MongoError(`server ${this.name} does not support collation`));\n  } // Setup the docs as an array\n\n\n  ops = Array.isArray(ops) ? ops : [ops]; // Execute write\n\n  return wireProtocol.remove(self, ns, ops, options, callback);\n};\n/**\n * Get a new cursor\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId\n * @param {object} [options] Options for the cursor\n * @param {object} [options.batchSize=0] Batchsize for the operation\n * @param {array} [options.documents=[]] Initial documents list for cursor\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {object} [options.topology] The internal topology of the created cursor\n * @returns {Cursor}\n */\n\n\nServer.prototype.cursor = function (ns, cmd, options) {\n  options = options || {};\n  const topology = options.topology || this; // Set up final cursor type\n\n  var FinalCursor = options.cursorFactory || this.s.Cursor; // Return the cursor\n\n  return new FinalCursor(topology, ns, cmd, options);\n};\n/**\n * Compare two server instances\n * @method\n * @param {Server} server Server to compare equality against\n * @return {boolean}\n */\n\n\nServer.prototype.equals = function (server) {\n  if (typeof server === 'string') return this.name.toLowerCase() === server.toLowerCase();\n  if (server.name) return this.name.toLowerCase() === server.name.toLowerCase();\n  return false;\n};\n/**\n * All raw connections\n * @method\n * @return {Connection[]}\n */\n\n\nServer.prototype.connections = function () {\n  return this.s.pool.allConnections();\n};\n/**\n * Selects a server\n * @method\n * @param {function} selector Unused\n * @param {ReadPreference} [options.readPreference] Unused\n * @param {ClientSession} [options.session] Unused\n * @return {Server}\n */\n\n\nServer.prototype.selectServer = function (selector, options, callback) {\n  if (typeof selector === 'function' && typeof callback === 'undefined') callback = selector, selector = undefined, options = {};\n  if (typeof options === 'function') callback = options, options = selector, selector = undefined;\n  callback(null, this);\n};\n\nvar listeners = ['close', 'error', 'timeout', 'parseError', 'connect'];\n/**\n * Destroy the server connection\n * @method\n * @param {boolean} [options.emitClose=false] Emit close event on destroy\n * @param {boolean} [options.emitDestroy=false] Emit destroy event on destroy\n * @param {boolean} [options.force=false] Force destroy the pool\n */\n\nServer.prototype.destroy = function (options, callback) {\n  if (this._destroyed) {\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  }\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  var self = this; // Set the connections\n\n  if (serverAccounting) delete servers[this.id]; // Destroy the monitoring process if any\n\n  if (this.monitoringProcessId) {\n    clearTimeout(this.monitoringProcessId);\n  } // No pool, return\n\n\n  if (!self.s.pool || this._destroyed) {\n    this._destroyed = true;\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  }\n\n  this._destroyed = true; // Emit close event\n\n  if (options.emitClose) {\n    self.emit('close', self);\n  } // Emit destroy event\n\n\n  if (options.emitDestroy) {\n    self.emit('destroy', self);\n  } // Remove all listeners\n\n\n  listeners.forEach(function (event) {\n    self.s.pool.removeAllListeners(event);\n  }); // Emit opening server event\n\n  if (self.listeners('serverClosed').length > 0) self.emit('serverClosed', {\n    topologyId: topologyId(self),\n    address: self.name\n  }); // Emit toplogy opening event if not in topology\n\n  if (self.listeners('topologyClosed').length > 0 && !self.s.inTopology) {\n    self.emit('topologyClosed', {\n      topologyId: topologyId(self)\n    });\n  }\n\n  if (self.s.logger.isDebug()) {\n    self.s.logger.debug(f('destroy called on server %s', self.name));\n  } // Destroy the pool\n\n\n  this.s.pool.destroy(options.force, callback);\n};\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Server#connect\n * @type {Server}\n */\n\n/**\n * A server reconnect event, used to verify that the server topology has reconnected\n *\n * @event Server#reconnect\n * @type {Server}\n */\n\n/**\n * A server opening SDAM monitoring event\n *\n * @event Server#serverOpening\n * @type {object}\n */\n\n/**\n * A server closed SDAM monitoring event\n *\n * @event Server#serverClosed\n * @type {object}\n */\n\n/**\n * A server description SDAM change monitoring event\n *\n * @event Server#serverDescriptionChanged\n * @type {object}\n */\n\n/**\n * A topology open SDAM event\n *\n * @event Server#topologyOpening\n * @type {object}\n */\n\n/**\n * A topology closed SDAM event\n *\n * @event Server#topologyClosed\n * @type {object}\n */\n\n/**\n * A topology structure SDAM change event\n *\n * @event Server#topologyDescriptionChanged\n * @type {object}\n */\n\n/**\n * Server reconnect failed\n *\n * @event Server#reconnectFailed\n * @type {Error}\n */\n\n/**\n * Server connection pool closed\n *\n * @event Server#close\n * @type {object}\n */\n\n/**\n * Server connection pool caused an error\n *\n * @event Server#error\n * @type {Error}\n */\n\n/**\n * Server destroyed was called\n *\n * @event Server#destroy\n * @type {Server}\n */\n\n\nmodule.exports = Server;","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/core/topologies/server.js"],"names":["inherits","require","f","format","EventEmitter","ReadPreference","Logger","debugOptions","retrieveBSON","Pool","MongoError","MongoNetworkError","wireProtocol","CoreCursor","sdam","createCompressionInfo","resolveClusterTime","SessionMixins","relayEvents","collationNotSupported","makeClientMetadata","debugFields","id","serverAccounting","servers","BSON","topologyId","server","s","parent","Server","options","call","Object","assign","metadata","logger","Cursor","cursorFactory","bson","Binary","Code","DBRef","Decimal128","Double","Int32","Long","Map","MaxKey","MinKey","ObjectId","BSONRegExp","Symbol","Timestamp","pool","disconnectHandler","monitoring","inTopology","monitoringInterval","compression","compressors","clusterTime","ismaster","lastIsMasterMS","monitoringProcessId","initialConnect","_type","lastUpdateTime","lastWriteDate","staleness","prototype","defineProperty","enumerable","get","native","logicalSessionTimeoutMinutes","set","settings","enableServerAccounting","disableServerAccounting","host","port","self","type","ns","cmd","callback","isConnected","reconnect","add","name","monitoringProcess","isDestroyed","emit","start","Date","getTime","command","socketTimeout","connectionTimeout","err","result","setTimeout","eventHandler","event","conn","isInfo","object","JSON","stringify","info","agreedCompressor","zlibCompressionLevel","$clusterTime","msg","emitServerDescriptionChanged","address","arbiters","hosts","passives","getTopologyType","emitTopologyDescriptionChanged","topologyType","indexOf","listeners","length","state","connect","isDisconnected","on","auth","credentials","getDescription","description","setName","lastIsMaster","unref","basicWriteValidations","basicReadValidations","readPreference","Error","wireProtocolCommand","isDebug","debug","query","cursorState","getMore","batchSize","killCursors","insert","ops","Array","isArray","update","remove","cursor","topology","FinalCursor","equals","toLowerCase","connections","allConnections","selectServer","selector","undefined","destroy","_destroyed","clearTimeout","emitClose","emitDestroy","forEach","removeAllListeners","force","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,MAAD,CAAP,CAAgBD,QAA/B;AAAA,IACEE,CAAC,GAAGD,OAAO,CAAC,MAAD,CAAP,CAAgBE,MADtB;AAAA,IAEEC,YAAY,GAAGH,OAAO,CAAC,QAAD,CAAP,CAAkBG,YAFnC;AAAA,IAGEC,cAAc,GAAGJ,OAAO,CAAC,mBAAD,CAH1B;AAAA,IAIEK,MAAM,GAAGL,OAAO,CAAC,sBAAD,CAJlB;AAAA,IAKEM,YAAY,GAAGN,OAAO,CAAC,qBAAD,CAAP,CAA+BM,YALhD;AAAA,IAMEC,YAAY,GAAGP,OAAO,CAAC,qBAAD,CAAP,CAA+BO,YANhD;AAAA,IAOEC,IAAI,GAAGR,OAAO,CAAC,oBAAD,CAPhB;AAAA,IAQES,UAAU,GAAGT,OAAO,CAAC,UAAD,CAAP,CAAoBS,UARnC;AAAA,IASEC,iBAAiB,GAAGV,OAAO,CAAC,UAAD,CAAP,CAAoBU,iBAT1C;AAAA,IAUEC,YAAY,GAAGX,OAAO,CAAC,iBAAD,CAVxB;AAAA,IAWEY,UAAU,GAAGZ,OAAO,CAAC,WAAD,CAAP,CAAqBY,UAXpC;AAAA,IAYEC,IAAI,GAAGb,OAAO,CAAC,UAAD,CAZhB;AAAA,IAaEc,qBAAqB,GAAGd,OAAO,CAAC,UAAD,CAAP,CAAoBc,qBAb9C;AAAA,IAcEC,kBAAkB,GAAGf,OAAO,CAAC,UAAD,CAAP,CAAoBe,kBAd3C;AAAA,IAeEC,aAAa,GAAGhB,OAAO,CAAC,UAAD,CAAP,CAAoBgB,aAftC;AAAA,IAgBEC,WAAW,GAAGjB,OAAO,CAAC,UAAD,CAAP,CAAoBiB,WAhBpC;;AAkBA,MAAMC,qBAAqB,GAAGlB,OAAO,CAAC,UAAD,CAAP,CAAoBkB,qBAAlD;;AACA,MAAMC,kBAAkB,GAAGnB,OAAO,CAAC,UAAD,CAAP,CAAoBmB,kBAA/C,C,CAEA;;;AACA,IAAIC,WAAW,GAAG,CAChB,WADgB,EAEhB,gBAFgB,EAGhB,mBAHgB,EAIhB,WAJgB,EAKhB,eALgB,EAMhB,MANgB,EAOhB,MAPgB,EAQhB,MARgB,EAShB,WATgB,EAUhB,uBAVgB,EAWhB,SAXgB,EAYhB,mBAZgB,EAahB,qBAbgB,EAchB,eAdgB,EAehB,KAfgB,EAgBhB,IAhBgB,EAiBhB,KAjBgB,EAkBhB,MAlBgB,EAmBhB,KAnBgB,EAoBhB,oBApBgB,EAqBhB,cArBgB,EAsBhB,eAtBgB,EAuBhB,gBAvBgB,EAwBhB,YAxBgB,CAAlB,C,CA2BA;;AACA,IAAIC,EAAE,GAAG,CAAT;AACA,IAAIC,gBAAgB,GAAG,KAAvB;AACA,IAAIC,OAAO,GAAG,EAAd;AACA,IAAIC,IAAI,GAAGjB,YAAY,EAAvB;;AAEA,SAASkB,UAAT,CAAoBC,MAApB,EAA4B;AAC1B,SAAOA,MAAM,CAACC,CAAP,CAASC,MAAT,IAAmB,IAAnB,GAA0BF,MAAM,CAACL,EAAjC,GAAsCK,MAAM,CAACC,CAAP,CAASC,MAAT,CAAgBP,EAA7D;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIQ,MAAM,GAAG,UAASC,OAAT,EAAkB;AAC7BA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB,CAD6B,CAG7B;;AACA3B,EAAAA,YAAY,CAAC4B,IAAb,CAAkB,IAAlB,EAJ6B,CAM7B;;AACA,OAAKV,EAAL,GAAUA,EAAE,EAAZ,CAP6B,CAS7B;;AACA,OAAKM,CAAL,GAAS;AACP;AACAG,IAAAA,OAAO,EAAEE,MAAM,CAACC,MAAP,CAAc;AAAEC,MAAAA,QAAQ,EAAEf,kBAAkB,CAACW,OAAD;AAA9B,KAAd,EAAyDA,OAAzD,CAFF;AAGP;AACAK,IAAAA,MAAM,EAAE9B,MAAM,CAAC,QAAD,EAAWyB,OAAX,CAJP;AAKP;AACAM,IAAAA,MAAM,EAAEN,OAAO,CAACO,aAAR,IAAyBzB,UAN1B;AAOP;AACA0B,IAAAA,IAAI,EACFR,OAAO,CAACQ,IAAR,IACA,IAAId,IAAJ,CAAS,CACPA,IAAI,CAACe,MADE,EAEPf,IAAI,CAACgB,IAFE,EAGPhB,IAAI,CAACiB,KAHE,EAIPjB,IAAI,CAACkB,UAJE,EAKPlB,IAAI,CAACmB,MALE,EAMPnB,IAAI,CAACoB,KANE,EAOPpB,IAAI,CAACqB,IAPE,EAQPrB,IAAI,CAACsB,GARE,EASPtB,IAAI,CAACuB,MATE,EAUPvB,IAAI,CAACwB,MAVE,EAWPxB,IAAI,CAACyB,QAXE,EAYPzB,IAAI,CAAC0B,UAZE,EAaP1B,IAAI,CAAC2B,MAbE,EAcP3B,IAAI,CAAC4B,SAdE,CAAT,CAVK;AA0BP;AACAC,IAAAA,IAAI,EAAE,IA3BC;AA4BP;AACAC,IAAAA,iBAAiB,EAAExB,OAAO,CAACwB,iBA7BpB;AA8BP;AACAC,IAAAA,UAAU,EAAE,OAAOzB,OAAO,CAACyB,UAAf,KAA8B,SAA9B,GAA0CzB,OAAO,CAACyB,UAAlD,GAA+D,IA/BpE;AAgCP;AACAC,IAAAA,UAAU,EAAE,CAAC,CAAC1B,OAAO,CAACF,MAjCf;AAkCP;AACA6B,IAAAA,kBAAkB,EAChB,OAAO3B,OAAO,CAAC2B,kBAAf,KAAsC,QAAtC,GAAiD3B,OAAO,CAAC2B,kBAAzD,GAA8E,IApCzE;AAqCPC,IAAAA,WAAW,EAAE;AAAEC,MAAAA,WAAW,EAAE7C,qBAAqB,CAACgB,OAAD;AAApC,KArCN;AAsCP;AACAF,IAAAA,MAAM,EAAEE,OAAO,CAACF;AAvCT,GAAT,CAV6B,CAoD7B;;AACA,MAAI,CAAC,KAAKD,CAAL,CAAOC,MAAZ,EAAoB;AAClB,SAAKD,CAAL,CAAOiC,WAAP,GAAqB,IAArB;AACD,GAvD4B,CAyD7B;;;AACA,OAAKC,QAAL,GAAgB,IAAhB,CA1D6B,CA2D7B;;AACA,OAAKC,cAAL,GAAsB,CAAC,CAAvB,CA5D6B,CA6D7B;;AACA,OAAKC,mBAAL,GAA2B,IAA3B,CA9D6B,CA+D7B;;AACA,OAAKC,cAAL,GAAsB,IAAtB,CAhE6B,CAiE7B;;AACA,OAAKC,KAAL,GAAa,QAAb,CAlE6B,CAoE7B;AACA;;AACA,OAAKC,cAAL,GAAsB,CAAtB,CAtE6B,CAuE7B;;AACA,OAAKC,aAAL,GAAqB,CAArB,CAxE6B,CAyE7B;;AACA,OAAKC,SAAL,GAAiB,CAAjB;AACD,CA3ED;;AA6EArE,QAAQ,CAAC8B,MAAD,EAAS1B,YAAT,CAAR;AACA6B,MAAM,CAACC,MAAP,CAAcJ,MAAM,CAACwC,SAArB,EAAgCrD,aAAhC;AAEAgB,MAAM,CAACsC,cAAP,CAAsBzC,MAAM,CAACwC,SAA7B,EAAwC,MAAxC,EAAgD;AAC9CE,EAAAA,UAAU,EAAE,IADkC;AAE9CC,EAAAA,GAAG,EAAE,YAAW;AACd,WAAO,KAAKP,KAAZ;AACD;AAJ6C,CAAhD;AAOAjC,MAAM,CAACsC,cAAP,CAAsBzC,MAAM,CAACwC,SAA7B,EAAwC,YAAxC,EAAsD;AACpDE,EAAAA,UAAU,EAAE,IADwC;AAEpDC,EAAAA,GAAG,EAAE,YAAW;AACd,WAAOhD,IAAI,CAACiD,MAAL,GAAc,KAAd,GAAsB,IAA7B;AACD;AAJmD,CAAtD;AAOAzC,MAAM,CAACsC,cAAP,CAAsBzC,MAAM,CAACwC,SAA7B,EAAwC,8BAAxC,EAAwE;AACtEE,EAAAA,UAAU,EAAE,IAD0D;AAEtEC,EAAAA,GAAG,EAAE,YAAW;AACd,QAAI,CAAC,KAAKX,QAAV,EAAoB,OAAO,IAAP;AACpB,WAAO,KAAKA,QAAL,CAAca,4BAAd,IAA8C,IAArD;AACD;AALqE,CAAxE;AAQA1C,MAAM,CAACsC,cAAP,CAAsBzC,MAAM,CAACwC,SAA7B,EAAwC,gBAAxC,EAA0D;AACxDE,EAAAA,UAAU,EAAE,IAD4C;AAExDC,EAAAA,GAAG,EAAE,YAAW;AACd,WAAO,KAAK7C,CAAL,CAAOG,OAAP,CAAeI,QAAtB;AACD;AAJuD,CAA1D,E,CAOA;AACA;AACA;AACA;;AACAF,MAAM,CAACsC,cAAP,CAAsBzC,MAAM,CAACwC,SAA7B,EAAwC,aAAxC,EAAuD;AACrDE,EAAAA,UAAU,EAAE,IADyC;AAErDI,EAAAA,GAAG,EAAE,UAASf,WAAT,EAAsB;AACzB,UAAMgB,QAAQ,GAAG,KAAKjD,CAAL,CAAOC,MAAP,GAAgB,KAAKD,CAAL,CAAOC,MAAvB,GAAgC,KAAKD,CAAtD;AACAZ,IAAAA,kBAAkB,CAAC6D,QAAD,EAAWhB,WAAX,CAAlB;AACD,GALoD;AAMrDY,EAAAA,GAAG,EAAE,YAAW;AACd,UAAMI,QAAQ,GAAG,KAAKjD,CAAL,CAAOC,MAAP,GAAgB,KAAKD,CAAL,CAAOC,MAAvB,GAAgC,KAAKD,CAAtD;AACA,WAAOiD,QAAQ,CAAChB,WAAT,IAAwB,IAA/B;AACD;AAToD,CAAvD;;AAYA/B,MAAM,CAACgD,sBAAP,GAAgC,YAAW;AACzCvD,EAAAA,gBAAgB,GAAG,IAAnB;AACAC,EAAAA,OAAO,GAAG,EAAV;AACD,CAHD;;AAKAM,MAAM,CAACiD,uBAAP,GAAiC,YAAW;AAC1CxD,EAAAA,gBAAgB,GAAG,KAAnB;AACD,CAFD;;AAIAO,MAAM,CAACN,OAAP,GAAiB,YAAW;AAC1B,SAAOA,OAAP;AACD,CAFD;;AAIAS,MAAM,CAACsC,cAAP,CAAsBzC,MAAM,CAACwC,SAA7B,EAAwC,MAAxC,EAAgD;AAC9CE,EAAAA,UAAU,EAAE,IADkC;AAE9CC,EAAAA,GAAG,EAAE,YAAW;AACd,WAAO,KAAK7C,CAAL,CAAOG,OAAP,CAAeiD,IAAf,GAAsB,GAAtB,GAA4B,KAAKpD,CAAL,CAAOG,OAAP,CAAekD,IAAlD;AACD;AAJ6C,CAAhD;;AAOA,SAAS1B,iBAAT,CAA2B2B,IAA3B,EAAiCC,IAAjC,EAAuCC,EAAvC,EAA2CC,GAA3C,EAAgDtD,OAAhD,EAAyDuD,QAAzD,EAAmE;AACjE;AACA;AACA,MACE,CAACJ,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAYiC,WAAZ,EAAD,IACAL,IAAI,CAACtD,CAAL,CAAOG,OAAP,CAAeyD,SADf,IAEAN,IAAI,CAACtD,CAAL,CAAO2B,iBAAP,IAA4B,IAF5B,IAGA,CAACxB,OAAO,CAACyB,UAJX,EAKE;AACA0B,IAAAA,IAAI,CAACtD,CAAL,CAAO2B,iBAAP,CAAyBkC,GAAzB,CAA6BN,IAA7B,EAAmCC,EAAnC,EAAuCC,GAAvC,EAA4CtD,OAA5C,EAAqDuD,QAArD;AACA,WAAO,IAAP;AACD,GAXgE,CAajE;;;AACA,MAAI,CAACJ,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAYiC,WAAZ,EAAL,EAAgC;AAC9BD,IAAAA,QAAQ,CAAC,IAAI5E,UAAJ,CAAeR,CAAC,CAAC,sCAAD,EAAyCgF,IAAI,CAACQ,IAA9C,CAAhB,CAAD,CAAR;AACA,WAAO,IAAP;AACD;AACF;;AAED,SAASC,iBAAT,CAA2BT,IAA3B,EAAiC;AAC/B,SAAO,YAAW;AAChB;AACA,QAAIA,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAYsC,WAAZ,EAAJ,EAA+B,OAFf,CAGhB;;AACAV,IAAAA,IAAI,CAACW,IAAL,CAAU,YAAV,EAAwBX,IAAxB,EAJgB,CAKhB;AACA;;AACA,QAAIY,KAAK,GAAG,IAAIC,IAAJ,GAAWC,OAAX,EAAZ,CAPgB,CAShB;;AACAd,IAAAA,IAAI,CAACe,OAAL,CACE,YADF,EAEE;AAAEnC,MAAAA,QAAQ,EAAE;AAAZ,KAFF,EAGE;AACEoC,MAAAA,aAAa,EACX,OAAOhB,IAAI,CAACtD,CAAL,CAAOG,OAAP,CAAeoE,iBAAtB,KAA4C,QAA5C,GACI,IADJ,GAEIjB,IAAI,CAACtD,CAAL,CAAOG,OAAP,CAAeoE,iBAJvB;AAKE3C,MAAAA,UAAU,EAAE;AALd,KAHF,EAUE,CAAC4C,GAAD,EAAMC,MAAN,KAAiB;AACf;AACAnB,MAAAA,IAAI,CAACnB,cAAL,GAAsB,IAAIgC,IAAJ,GAAWC,OAAX,KAAuBF,KAA7C;AACA,UAAIZ,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAYsC,WAAZ,EAAJ,EAA+B,OAHhB,CAIf;;AACA,UAAIS,MAAJ,EAAY;AACVnB,QAAAA,IAAI,CAACpB,QAAL,GAAgBuC,MAAM,CAACA,MAAvB;AACD,OAPc,CAQf;;;AACAnB,MAAAA,IAAI,CAAClB,mBAAL,GAA2BsC,UAAU,CAACX,iBAAiB,CAACT,IAAD,CAAlB,EAA0BA,IAAI,CAACtD,CAAL,CAAO8B,kBAAjC,CAArC;AACD,KApBH;AAsBD,GAhCD;AAiCD;;AAED,IAAI6C,YAAY,GAAG,UAASrB,IAAT,EAAesB,KAAf,EAAsB;AACvC,SAAO,UAASJ,GAAT,EAAcK,IAAd,EAAoB;AACzB;AACA,QAAIvB,IAAI,CAACtD,CAAL,CAAOQ,MAAP,CAAcsE,MAAd,EAAJ,EAA4B;AAC1B,UAAIC,MAAM,GAAGP,GAAG,YAAY1F,UAAf,GAA4BkG,IAAI,CAACC,SAAL,CAAeT,GAAf,CAA5B,GAAkD,EAA/D;AACAlB,MAAAA,IAAI,CAACtD,CAAL,CAAOQ,MAAP,CAAc0E,IAAd,CACE5G,CAAC,CAAC,8CAAD,EAAiDgF,IAAI,CAACQ,IAAtD,EAA4Dc,KAA5D,EAAmEG,MAAnE,CADH;AAGD,KAPwB,CASzB;;;AACA,QAAIH,KAAK,KAAK,SAAd,EAAyB;AACvBtB,MAAAA,IAAI,CAACjB,cAAL,GAAsB,KAAtB;AACAiB,MAAAA,IAAI,CAACpB,QAAL,GAAgB2C,IAAI,CAAC3C,QAArB;AACAoB,MAAAA,IAAI,CAACnB,cAAL,GAAsB0C,IAAI,CAAC1C,cAA3B;;AACA,UAAI0C,IAAI,CAACM,gBAAT,EAA2B;AACzB7B,QAAAA,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAYvB,OAAZ,CAAoBgF,gBAApB,GAAuCN,IAAI,CAACM,gBAA5C;AACD;;AAED,UAAIN,IAAI,CAACO,oBAAT,EAA+B;AAC7B9B,QAAAA,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAYvB,OAAZ,CAAoBiF,oBAApB,GAA2CP,IAAI,CAACO,oBAAhD;AACD;;AAED,UAAIP,IAAI,CAAC3C,QAAL,CAAcmD,YAAlB,EAAgC;AAC9B,cAAMA,YAAY,GAAGR,IAAI,CAAC3C,QAAL,CAAcmD,YAAnC;AACA/B,QAAAA,IAAI,CAACrB,WAAL,GAAmBoD,YAAnB;AACD,OAfsB,CAiBvB;AACA;;;AACA,UAAI/B,IAAI,CAACpB,QAAL,CAAcoD,GAAd,KAAsB,UAA1B,EAAsC;AACpChC,QAAAA,IAAI,CAAChB,KAAL,GAAa,QAAb;AACD,OArBsB,CAuBvB;;;AACA,UAAIgB,IAAI,CAACtD,CAAL,CAAO4B,UAAX,EAAuB;AACrB0B,QAAAA,IAAI,CAAClB,mBAAL,GAA2BsC,UAAU,CAACX,iBAAiB,CAACT,IAAD,CAAlB,EAA0BA,IAAI,CAACtD,CAAL,CAAO8B,kBAAjC,CAArC;AACD,OA1BsB,CA4BvB;;;AACA5C,MAAAA,IAAI,CAACqG,4BAAL,CAAkCjC,IAAlC,EAAwC;AACtCkC,QAAAA,OAAO,EAAElC,IAAI,CAACQ,IADwB;AAEtC2B,QAAAA,QAAQ,EAAE,EAF4B;AAGtCC,QAAAA,KAAK,EAAE,EAH+B;AAItCC,QAAAA,QAAQ,EAAE,EAJ4B;AAKtCpC,QAAAA,IAAI,EAAErE,IAAI,CAAC0G,eAAL,CAAqBtC,IAArB;AALgC,OAAxC;;AAQA,UAAI,CAACA,IAAI,CAACtD,CAAL,CAAO6B,UAAZ,EAAwB;AACtB;AACA3C,QAAAA,IAAI,CAAC2G,8BAAL,CAAoCvC,IAApC,EAA0C;AACxCwC,UAAAA,YAAY,EAAE,QAD0B;AAExClG,UAAAA,OAAO,EAAE,CACP;AACE4F,YAAAA,OAAO,EAAElC,IAAI,CAACQ,IADhB;AAEE2B,YAAAA,QAAQ,EAAE,EAFZ;AAGEC,YAAAA,KAAK,EAAE,EAHT;AAIEC,YAAAA,QAAQ,EAAE,EAJZ;AAKEpC,YAAAA,IAAI,EAAErE,IAAI,CAAC0G,eAAL,CAAqBtC,IAArB;AALR,WADO;AAF+B,SAA1C;AAYD,OAnDsB,CAqDvB;;;AACA,UAAIA,IAAI,CAACtD,CAAL,CAAOQ,MAAP,CAAcsE,MAAd,EAAJ,EAA4B;AAC1BxB,QAAAA,IAAI,CAACtD,CAAL,CAAOQ,MAAP,CAAc0E,IAAd,CACE5G,CAAC,CAAC,wCAAD,EAA2CgF,IAAI,CAACQ,IAAhD,EAAsDkB,IAAI,CAACC,SAAL,CAAe3B,IAAI,CAACpB,QAApB,CAAtD,CADH;AAGD,OA1DsB,CA4DvB;;;AACAoB,MAAAA,IAAI,CAACW,IAAL,CAAU,SAAV,EAAqBX,IAArB;AACD,KA9DD,MA8DO,IACLsB,KAAK,KAAK,OAAV,IACAA,KAAK,KAAK,YADV,IAEAA,KAAK,KAAK,OAFV,IAGAA,KAAK,KAAK,SAHV,IAIAA,KAAK,KAAK,WAJV,IAKAA,KAAK,KAAK,kBALV,IAMAA,KAAK,KAAK,iBAPL,EAQL;AACA;AACA,UACEjF,gBAAgB,IAChB,CAAC,OAAD,EAAU,SAAV,EAAqB,OAArB,EAA8B,YAA9B,EAA4C,iBAA5C,EAA+DoG,OAA/D,CAAuEnB,KAAvE,MAAkF,CAAC,CAFrF,EAGE;AACA;AACA,YAAI,CAACtB,IAAI,CAACtD,CAAL,CAAO6B,UAAZ,EAAwB;AACtByB,UAAAA,IAAI,CAACW,IAAL,CAAU,iBAAV,EAA6B;AAAEnE,YAAAA,UAAU,EAAEwD,IAAI,CAAC5D;AAAnB,WAA7B;AACD;;AAED,eAAOE,OAAO,CAAC0D,IAAI,CAAC5D,EAAN,CAAd;AACD;;AAED,UAAIkF,KAAK,KAAK,OAAd,EAAuB;AACrB;AACA1F,QAAAA,IAAI,CAACqG,4BAAL,CAAkCjC,IAAlC,EAAwC;AACtCkC,UAAAA,OAAO,EAAElC,IAAI,CAACQ,IADwB;AAEtC2B,UAAAA,QAAQ,EAAE,EAF4B;AAGtCC,UAAAA,KAAK,EAAE,EAH+B;AAItCC,UAAAA,QAAQ,EAAE,EAJ4B;AAKtCpC,UAAAA,IAAI,EAAE;AALgC,SAAxC;AAOD,OAvBD,CAyBA;;;AACA,UAAIqB,KAAK,KAAK,iBAAd,EAAiC;AAC/BtB,QAAAA,IAAI,CAACW,IAAL,CAAU,iBAAV,EAA6BO,GAA7B,EAD+B,CAE/B;;AACA,YAAIlB,IAAI,CAAC0C,SAAL,CAAe,OAAf,EAAwBC,MAAxB,GAAiC,CAArC,EAAwC;AACtC3C,UAAAA,IAAI,CAACW,IAAL,CAAU,OAAV,EAAmBO,GAAnB;AACD,SAL8B,CAM/B;;;AACA;AACD,OAlCD,CAoCA;;;AACA,UACE,CAAC,cAAD,EAAiB,YAAjB,EAA+BuB,OAA/B,CAAuCzC,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAYwE,KAAnD,MAA8D,CAAC,CAA/D,IACA5C,IAAI,CAACjB,cADL,IAEA,CAAC,OAAD,EAAU,SAAV,EAAqB,OAArB,EAA8B,YAA9B,EAA4C0D,OAA5C,CAAoDnB,KAApD,MAA+D,CAAC,CAHlE,EAIE;AACAtB,QAAAA,IAAI,CAACjB,cAAL,GAAsB,KAAtB;AACA,eAAOiB,IAAI,CAACW,IAAL,CACL,OADK,EAEL,IAAIlF,iBAAJ,CACET,CAAC,CAAC,wDAAD,EAA2DgF,IAAI,CAACQ,IAAhE,EAAsEU,GAAtE,CADH,CAFK,CAAP;AAMD,OAjDD,CAmDA;;;AACA,UAAII,KAAK,KAAK,WAAd,EAA2B;AACzB;AACA;AACA1F,QAAAA,IAAI,CAACqG,4BAAL,CAAkCjC,IAAlC,EAAwC;AACtCkC,UAAAA,OAAO,EAAElC,IAAI,CAACQ,IADwB;AAEtC2B,UAAAA,QAAQ,EAAE,EAF4B;AAGtCC,UAAAA,KAAK,EAAE,EAH+B;AAItCC,UAAAA,QAAQ,EAAE,EAJ4B;AAKtCpC,UAAAA,IAAI,EAAErE,IAAI,CAAC0G,eAAL,CAAqBtC,IAArB;AALgC,SAAxC;AAOA,eAAOA,IAAI,CAACW,IAAL,CAAUW,KAAV,EAAiBtB,IAAjB,CAAP;AACD,OA/DD,CAiEA;;;AACAA,MAAAA,IAAI,CAACW,IAAL,CAAUW,KAAV,EAAiBJ,GAAjB;AACD;AACF,GApJD;AAqJD,CAtJD;AAwJA;AACA;AACA;;;AACAtE,MAAM,CAACwC,SAAP,CAAiByD,OAAjB,GAA2B,UAAShG,OAAT,EAAkB;AAC3C,MAAImD,IAAI,GAAG,IAAX;AACAnD,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB,CAF2C,CAI3C;;AACA,MAAIR,gBAAJ,EAAsBC,OAAO,CAAC,KAAKF,EAAN,CAAP,GAAmB,IAAnB,CALqB,CAO3C;;AACA,MAAI4D,IAAI,CAACtD,CAAL,CAAO0B,IAAP,IAAe,CAAC4B,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAY0E,cAAZ,EAAhB,IAAgD,CAAC9C,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAYsC,WAAZ,EAArD,EAAgF;AAC9E,UAAM,IAAIlF,UAAJ,CAAeR,CAAC,CAAC,qCAAD,EAAwCgF,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAYwE,KAApD,CAAhB,CAAN;AACD,GAV0C,CAY3C;;;AACA5C,EAAAA,IAAI,CAACtD,CAAL,CAAO0B,IAAP,GAAc,IAAI7C,IAAJ,CAAS,IAAT,EAAewB,MAAM,CAACC,MAAP,CAAcgD,IAAI,CAACtD,CAAL,CAAOG,OAArB,EAA8BA,OAA9B,EAAuC;AAAEQ,IAAAA,IAAI,EAAE,KAAKX,CAAL,CAAOW;AAAf,GAAvC,CAAf,CAAd,CAb2C,CAe3C;;AACA2C,EAAAA,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAY2E,EAAZ,CAAe,OAAf,EAAwB1B,YAAY,CAACrB,IAAD,EAAO,OAAP,CAApC;AACAA,EAAAA,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAY2E,EAAZ,CAAe,OAAf,EAAwB1B,YAAY,CAACrB,IAAD,EAAO,OAAP,CAApC;AACAA,EAAAA,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAY2E,EAAZ,CAAe,SAAf,EAA0B1B,YAAY,CAACrB,IAAD,EAAO,SAAP,CAAtC;AACAA,EAAAA,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAY2E,EAAZ,CAAe,YAAf,EAA6B1B,YAAY,CAACrB,IAAD,EAAO,YAAP,CAAzC;AACAA,EAAAA,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAY2E,EAAZ,CAAe,SAAf,EAA0B1B,YAAY,CAACrB,IAAD,EAAO,SAAP,CAAtC;AACAA,EAAAA,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAY2E,EAAZ,CAAe,WAAf,EAA4B1B,YAAY,CAACrB,IAAD,EAAO,WAAP,CAAxC;AACAA,EAAAA,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAY2E,EAAZ,CAAe,iBAAf,EAAkC1B,YAAY,CAACrB,IAAD,EAAO,iBAAP,CAA9C,EAtB2C,CAwB3C;;AACAhE,EAAAA,WAAW,CAACgE,IAAI,CAACtD,CAAL,CAAO0B,IAAR,EAAc4B,IAAd,EAAoB,CAAC,gBAAD,EAAmB,kBAAnB,EAAuC,eAAvC,CAApB,CAAX,CAzB2C,CA2B3C;;AACA,MAAI,CAACA,IAAI,CAACtD,CAAL,CAAO6B,UAAZ,EAAwB;AACtB,SAAKoC,IAAL,CAAU,iBAAV,EAA6B;AAAEnE,MAAAA,UAAU,EAAEA,UAAU,CAACwD,IAAD;AAAxB,KAA7B;AACD,GA9B0C,CAgC3C;;;AACAA,EAAAA,IAAI,CAACW,IAAL,CAAU,eAAV,EAA2B;AAAEnE,IAAAA,UAAU,EAAEA,UAAU,CAACwD,IAAD,CAAxB;AAAgCkC,IAAAA,OAAO,EAAElC,IAAI,CAACQ;AAA9C,GAA3B;AAEAR,EAAAA,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAYyE,OAAZ;AACD,CApCD;AAsCA;AACA;AACA;AACA;AACA;AACA;;;AACAjG,MAAM,CAACwC,SAAP,CAAiB4D,IAAjB,GAAwB,UAASC,WAAT,EAAsB7C,QAAtB,EAAgC;AACtD,MAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoCA,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAR;AACrC,CAFD;AAIA;AACA;AACA;AACA;AACA;;;AACAxD,MAAM,CAACwC,SAAP,CAAiB8D,cAAjB,GAAkC,YAAW;AAC3C,MAAItE,QAAQ,GAAG,KAAKA,QAAL,IAAiB,EAAhC;AACA,MAAIuE,WAAW,GAAG;AAChBlD,IAAAA,IAAI,EAAErE,IAAI,CAAC0G,eAAL,CAAqB,IAArB,CADU;AAEhBJ,IAAAA,OAAO,EAAE,KAAK1B;AAFE,GAAlB,CAF2C,CAO3C;;AACA,MAAI5B,QAAQ,CAACwD,KAAb,EAAoBe,WAAW,CAACf,KAAZ,GAAoBxD,QAAQ,CAACwD,KAA7B;AACpB,MAAIxD,QAAQ,CAACuD,QAAb,EAAuBgB,WAAW,CAAChB,QAAZ,GAAuBvD,QAAQ,CAACuD,QAAhC;AACvB,MAAIvD,QAAQ,CAACyD,QAAb,EAAuBc,WAAW,CAACd,QAAZ,GAAuBzD,QAAQ,CAACyD,QAAhC;AACvB,MAAIzD,QAAQ,CAACwE,OAAb,EAAsBD,WAAW,CAACC,OAAZ,GAAsBxE,QAAQ,CAACwE,OAA/B;AACtB,SAAOD,WAAP;AACD,CAbD;AAeA;AACA;AACA;AACA;AACA;;;AACAvG,MAAM,CAACwC,SAAP,CAAiBiE,YAAjB,GAAgC,YAAW;AACzC,SAAO,KAAKzE,QAAZ;AACD,CAFD;AAIA;AACA;AACA;AACA;;;AACAhC,MAAM,CAACwC,SAAP,CAAiBkE,KAAjB,GAAyB,YAAW;AAClC,OAAK5G,CAAL,CAAO0B,IAAP,CAAYkF,KAAZ;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;;;AACA1G,MAAM,CAACwC,SAAP,CAAiBiB,WAAjB,GAA+B,YAAW;AACxC,MAAI,CAAC,KAAK3D,CAAL,CAAO0B,IAAZ,EAAkB,OAAO,KAAP;AAClB,SAAO,KAAK1B,CAAL,CAAO0B,IAAP,CAAYiC,WAAZ,EAAP;AACD,CAHD;AAKA;AACA;AACA;AACA;AACA;;;AACAzD,MAAM,CAACwC,SAAP,CAAiBsB,WAAjB,GAA+B,YAAW;AACxC,MAAI,CAAC,KAAKhE,CAAL,CAAO0B,IAAZ,EAAkB,OAAO,KAAP;AAClB,SAAO,KAAK1B,CAAL,CAAO0B,IAAP,CAAYsC,WAAZ,EAAP;AACD,CAHD;;AAKA,SAAS6C,qBAAT,CAA+BvD,IAA/B,EAAqC;AACnC,MAAI,CAACA,IAAI,CAACtD,CAAL,CAAO0B,IAAZ,EAAkB,OAAO,IAAI5C,UAAJ,CAAe,kCAAf,CAAP;AAClB,MAAIwE,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAYsC,WAAZ,EAAJ,EAA+B,OAAO,IAAIlF,UAAJ,CAAe,oCAAf,CAAP;AAChC;;AAED,SAASgI,oBAAT,CAA8BxD,IAA9B,EAAoCnD,OAApC,EAA6C;AAC3C0G,EAAAA,qBAAqB,CAACvD,IAAD,EAAOnD,OAAP,CAArB;;AAEA,MAAIA,OAAO,CAAC4G,cAAR,IAA0B,EAAE5G,OAAO,CAAC4G,cAAR,YAAkCtI,cAApC,CAA9B,EAAmF;AACjF,UAAM,IAAIuI,KAAJ,CAAU,sDAAV,CAAN;AACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA9G,MAAM,CAACwC,SAAP,CAAiB2B,OAAjB,GAA2B,UAASb,EAAT,EAAaC,GAAb,EAAkBtD,OAAlB,EAA2BuD,QAA3B,EAAqC;AAC9D,MAAIJ,IAAI,GAAG,IAAX;;AACA,MAAI,OAAOnD,OAAP,KAAmB,UAAvB,EAAmC;AAChCuD,IAAAA,QAAQ,GAAGvD,OAAZ,EAAuBA,OAAO,GAAG,EAAjC,EAAuCA,OAAO,GAAGA,OAAO,IAAI,EAA5D;AACD;;AAED,MAAIsE,MAAM,GAAGqC,oBAAoB,CAACxD,IAAD,EAAOnD,OAAP,CAAjC;AACA,MAAIsE,MAAJ,EAAY,OAAOf,QAAQ,CAACe,MAAD,CAAf,CAPkD,CAS9D;;AACAtE,EAAAA,OAAO,GAAGE,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,OAAlB,EAA2B;AAAE8G,IAAAA,mBAAmB,EAAE;AAAvB,GAA3B,CAAV,CAV8D,CAY9D;;AACA,MAAI3D,IAAI,CAACtD,CAAL,CAAOQ,MAAP,CAAc0G,OAAd,EAAJ,EACE5D,IAAI,CAACtD,CAAL,CAAOQ,MAAP,CAAc2G,KAAd,CACE7I,CAAC,CACC,mCADD,EAEC0G,IAAI,CAACC,SAAL,CAAe;AACbzB,IAAAA,EAAE,EAAEA,EADS;AAEbC,IAAAA,GAAG,EAAEA,GAFQ;AAGbtD,IAAAA,OAAO,EAAExB,YAAY,CAACc,WAAD,EAAcU,OAAd;AAHR,GAAf,CAFD,EAOCmD,IAAI,CAACQ,IAPN,CADH,EAd4D,CA0B9D;;AACA,MAAInC,iBAAiB,CAAC2B,IAAD,EAAO,SAAP,EAAkBE,EAAlB,EAAsBC,GAAtB,EAA2BtD,OAA3B,EAAoCuD,QAApC,CAArB,EAAoE,OA3BN,CA6B9D;;AACA,MAAInE,qBAAqB,CAAC,IAAD,EAAOkE,GAAP,CAAzB,EAAsC;AACpC,WAAOC,QAAQ,CAAC,IAAI5E,UAAJ,CAAgB,UAAS,KAAKgF,IAAK,6BAAnC,CAAD,CAAf;AACD;;AAED9E,EAAAA,YAAY,CAACqF,OAAb,CAAqBf,IAArB,EAA2BE,EAA3B,EAA+BC,GAA/B,EAAoCtD,OAApC,EAA6CuD,QAA7C;AACD,CAnCD;AAqCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxD,MAAM,CAACwC,SAAP,CAAiB0E,KAAjB,GAAyB,UAAS5D,EAAT,EAAaC,GAAb,EAAkB4D,WAAlB,EAA+BlH,OAA/B,EAAwCuD,QAAxC,EAAkD;AACzE1E,EAAAA,YAAY,CAACoI,KAAb,CAAmB,IAAnB,EAAyB5D,EAAzB,EAA6BC,GAA7B,EAAkC4D,WAAlC,EAA+ClH,OAA/C,EAAwDuD,QAAxD;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxD,MAAM,CAACwC,SAAP,CAAiB4E,OAAjB,GAA2B,UAAS9D,EAAT,EAAa6D,WAAb,EAA0BE,SAA1B,EAAqCpH,OAArC,EAA8CuD,QAA9C,EAAwD;AACjF1E,EAAAA,YAAY,CAACsI,OAAb,CAAqB,IAArB,EAA2B9D,EAA3B,EAA+B6D,WAA/B,EAA4CE,SAA5C,EAAuDpH,OAAvD,EAAgEuD,QAAhE;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxD,MAAM,CAACwC,SAAP,CAAiB8E,WAAjB,GAA+B,UAAShE,EAAT,EAAa6D,WAAb,EAA0B3D,QAA1B,EAAoC;AACjE1E,EAAAA,YAAY,CAACwI,WAAb,CAAyB,IAAzB,EAA+BhE,EAA/B,EAAmC6D,WAAnC,EAAgD3D,QAAhD;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxD,MAAM,CAACwC,SAAP,CAAiB+E,MAAjB,GAA0B,UAASjE,EAAT,EAAakE,GAAb,EAAkBvH,OAAlB,EAA2BuD,QAA3B,EAAqC;AAC7D,MAAIJ,IAAI,GAAG,IAAX;;AACA,MAAI,OAAOnD,OAAP,KAAmB,UAAvB,EAAmC;AAChCuD,IAAAA,QAAQ,GAAGvD,OAAZ,EAAuBA,OAAO,GAAG,EAAjC,EAAuCA,OAAO,GAAGA,OAAO,IAAI,EAA5D;AACD;;AAED,MAAIsE,MAAM,GAAGoC,qBAAqB,CAACvD,IAAD,EAAOnD,OAAP,CAAlC;AACA,MAAIsE,MAAJ,EAAY,OAAOf,QAAQ,CAACe,MAAD,CAAf,CAPiD,CAS7D;;AACA,MAAI9C,iBAAiB,CAAC2B,IAAD,EAAO,QAAP,EAAiBE,EAAjB,EAAqBkE,GAArB,EAA0BvH,OAA1B,EAAmCuD,QAAnC,CAArB,EAAmE,OAVN,CAY7D;;AACAgE,EAAAA,GAAG,GAAGC,KAAK,CAACC,OAAN,CAAcF,GAAd,IAAqBA,GAArB,GAA2B,CAACA,GAAD,CAAjC,CAb6D,CAe7D;;AACA,SAAO1I,YAAY,CAACyI,MAAb,CAAoBnE,IAApB,EAA0BE,EAA1B,EAA8BkE,GAA9B,EAAmCvH,OAAnC,EAA4CuD,QAA5C,CAAP;AACD,CAjBD;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxD,MAAM,CAACwC,SAAP,CAAiBmF,MAAjB,GAA0B,UAASrE,EAAT,EAAakE,GAAb,EAAkBvH,OAAlB,EAA2BuD,QAA3B,EAAqC;AAC7D,MAAIJ,IAAI,GAAG,IAAX;;AACA,MAAI,OAAOnD,OAAP,KAAmB,UAAvB,EAAmC;AAChCuD,IAAAA,QAAQ,GAAGvD,OAAZ,EAAuBA,OAAO,GAAG,EAAjC,EAAuCA,OAAO,GAAGA,OAAO,IAAI,EAA5D;AACD;;AAED,MAAIsE,MAAM,GAAGoC,qBAAqB,CAACvD,IAAD,EAAOnD,OAAP,CAAlC;AACA,MAAIsE,MAAJ,EAAY,OAAOf,QAAQ,CAACe,MAAD,CAAf,CAPiD,CAS7D;;AACA,MAAI9C,iBAAiB,CAAC2B,IAAD,EAAO,QAAP,EAAiBE,EAAjB,EAAqBkE,GAArB,EAA0BvH,OAA1B,EAAmCuD,QAAnC,CAArB,EAAmE,OAVN,CAY7D;;AACA,MAAInE,qBAAqB,CAAC,IAAD,EAAOY,OAAP,CAAzB,EAA0C;AACxC,WAAOuD,QAAQ,CAAC,IAAI5E,UAAJ,CAAgB,UAAS,KAAKgF,IAAK,6BAAnC,CAAD,CAAf;AACD,GAf4D,CAiB7D;;;AACA4D,EAAAA,GAAG,GAAGC,KAAK,CAACC,OAAN,CAAcF,GAAd,IAAqBA,GAArB,GAA2B,CAACA,GAAD,CAAjC,CAlB6D,CAmB7D;;AACA,SAAO1I,YAAY,CAAC6I,MAAb,CAAoBvE,IAApB,EAA0BE,EAA1B,EAA8BkE,GAA9B,EAAmCvH,OAAnC,EAA4CuD,QAA5C,CAAP;AACD,CArBD;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxD,MAAM,CAACwC,SAAP,CAAiBoF,MAAjB,GAA0B,UAAStE,EAAT,EAAakE,GAAb,EAAkBvH,OAAlB,EAA2BuD,QAA3B,EAAqC;AAC7D,MAAIJ,IAAI,GAAG,IAAX;;AACA,MAAI,OAAOnD,OAAP,KAAmB,UAAvB,EAAmC;AAChCuD,IAAAA,QAAQ,GAAGvD,OAAZ,EAAuBA,OAAO,GAAG,EAAjC,EAAuCA,OAAO,GAAGA,OAAO,IAAI,EAA5D;AACD;;AAED,MAAIsE,MAAM,GAAGoC,qBAAqB,CAACvD,IAAD,EAAOnD,OAAP,CAAlC;AACA,MAAIsE,MAAJ,EAAY,OAAOf,QAAQ,CAACe,MAAD,CAAf,CAPiD,CAS7D;;AACA,MAAI9C,iBAAiB,CAAC2B,IAAD,EAAO,QAAP,EAAiBE,EAAjB,EAAqBkE,GAArB,EAA0BvH,OAA1B,EAAmCuD,QAAnC,CAArB,EAAmE,OAVN,CAY7D;;AACA,MAAInE,qBAAqB,CAAC,IAAD,EAAOY,OAAP,CAAzB,EAA0C;AACxC,WAAOuD,QAAQ,CAAC,IAAI5E,UAAJ,CAAgB,UAAS,KAAKgF,IAAK,6BAAnC,CAAD,CAAf;AACD,GAf4D,CAiB7D;;;AACA4D,EAAAA,GAAG,GAAGC,KAAK,CAACC,OAAN,CAAcF,GAAd,IAAqBA,GAArB,GAA2B,CAACA,GAAD,CAAjC,CAlB6D,CAmB7D;;AACA,SAAO1I,YAAY,CAAC8I,MAAb,CAAoBxE,IAApB,EAA0BE,EAA1B,EAA8BkE,GAA9B,EAAmCvH,OAAnC,EAA4CuD,QAA5C,CAAP;AACD,CArBD;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxD,MAAM,CAACwC,SAAP,CAAiBqF,MAAjB,GAA0B,UAASvE,EAAT,EAAaC,GAAb,EAAkBtD,OAAlB,EAA2B;AACnDA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,QAAM6H,QAAQ,GAAG7H,OAAO,CAAC6H,QAAR,IAAoB,IAArC,CAFmD,CAInD;;AACA,MAAIC,WAAW,GAAG9H,OAAO,CAACO,aAAR,IAAyB,KAAKV,CAAL,CAAOS,MAAlD,CALmD,CAOnD;;AACA,SAAO,IAAIwH,WAAJ,CAAgBD,QAAhB,EAA0BxE,EAA1B,EAA8BC,GAA9B,EAAmCtD,OAAnC,CAAP;AACD,CATD;AAWA;AACA;AACA;AACA;AACA;AACA;;;AACAD,MAAM,CAACwC,SAAP,CAAiBwF,MAAjB,GAA0B,UAASnI,MAAT,EAAiB;AACzC,MAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC,OAAO,KAAK+D,IAAL,CAAUqE,WAAV,OAA4BpI,MAAM,CAACoI,WAAP,EAAnC;AAChC,MAAIpI,MAAM,CAAC+D,IAAX,EAAiB,OAAO,KAAKA,IAAL,CAAUqE,WAAV,OAA4BpI,MAAM,CAAC+D,IAAP,CAAYqE,WAAZ,EAAnC;AACjB,SAAO,KAAP;AACD,CAJD;AAMA;AACA;AACA;AACA;AACA;;;AACAjI,MAAM,CAACwC,SAAP,CAAiB0F,WAAjB,GAA+B,YAAW;AACxC,SAAO,KAAKpI,CAAL,CAAO0B,IAAP,CAAY2G,cAAZ,EAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAnI,MAAM,CAACwC,SAAP,CAAiB4F,YAAjB,GAAgC,UAASC,QAAT,EAAmBpI,OAAnB,EAA4BuD,QAA5B,EAAsC;AACpE,MAAI,OAAO6E,QAAP,KAAoB,UAApB,IAAkC,OAAO7E,QAAP,KAAoB,WAA1D,EACGA,QAAQ,GAAG6E,QAAZ,EAAwBA,QAAQ,GAAGC,SAAnC,EAAgDrI,OAAO,GAAG,EAA1D;AACF,MAAI,OAAOA,OAAP,KAAmB,UAAvB,EACGuD,QAAQ,GAAGvD,OAAZ,EAAuBA,OAAO,GAAGoI,QAAjC,EAA6CA,QAAQ,GAAGC,SAAxD;AAEF9E,EAAAA,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAR;AACD,CAPD;;AASA,IAAIsC,SAAS,GAAG,CAAC,OAAD,EAAU,OAAV,EAAmB,SAAnB,EAA8B,YAA9B,EAA4C,SAA5C,CAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA9F,MAAM,CAACwC,SAAP,CAAiB+F,OAAjB,GAA2B,UAAStI,OAAT,EAAkBuD,QAAlB,EAA4B;AACrD,MAAI,KAAKgF,UAAT,EAAqB;AACnB,QAAI,OAAOhF,QAAP,KAAoB,UAAxB,EAAoCA,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAR;AACpC;AACD;;AAED,MAAI,OAAOvD,OAAP,KAAmB,UAAvB,EAAmC;AACjCuD,IAAAA,QAAQ,GAAGvD,OAAX;AACAA,IAAAA,OAAO,GAAG,EAAV;AACD;;AAEDA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,MAAImD,IAAI,GAAG,IAAX,CAZqD,CAcrD;;AACA,MAAI3D,gBAAJ,EAAsB,OAAOC,OAAO,CAAC,KAAKF,EAAN,CAAd,CAf+B,CAiBrD;;AACA,MAAI,KAAK0C,mBAAT,EAA8B;AAC5BuG,IAAAA,YAAY,CAAC,KAAKvG,mBAAN,CAAZ;AACD,GApBoD,CAsBrD;;;AACA,MAAI,CAACkB,IAAI,CAACtD,CAAL,CAAO0B,IAAR,IAAgB,KAAKgH,UAAzB,EAAqC;AACnC,SAAKA,UAAL,GAAkB,IAAlB;AACA,QAAI,OAAOhF,QAAP,KAAoB,UAAxB,EAAoCA,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAR;AACpC;AACD;;AAED,OAAKgF,UAAL,GAAkB,IAAlB,CA7BqD,CA+BrD;;AACA,MAAIvI,OAAO,CAACyI,SAAZ,EAAuB;AACrBtF,IAAAA,IAAI,CAACW,IAAL,CAAU,OAAV,EAAmBX,IAAnB;AACD,GAlCoD,CAoCrD;;;AACA,MAAInD,OAAO,CAAC0I,WAAZ,EAAyB;AACvBvF,IAAAA,IAAI,CAACW,IAAL,CAAU,SAAV,EAAqBX,IAArB;AACD,GAvCoD,CAyCrD;;;AACA0C,EAAAA,SAAS,CAAC8C,OAAV,CAAkB,UAASlE,KAAT,EAAgB;AAChCtB,IAAAA,IAAI,CAACtD,CAAL,CAAO0B,IAAP,CAAYqH,kBAAZ,CAA+BnE,KAA/B;AACD,GAFD,EA1CqD,CA8CrD;;AACA,MAAItB,IAAI,CAAC0C,SAAL,CAAe,cAAf,EAA+BC,MAA/B,GAAwC,CAA5C,EACE3C,IAAI,CAACW,IAAL,CAAU,cAAV,EAA0B;AAAEnE,IAAAA,UAAU,EAAEA,UAAU,CAACwD,IAAD,CAAxB;AAAgCkC,IAAAA,OAAO,EAAElC,IAAI,CAACQ;AAA9C,GAA1B,EAhDmD,CAkDrD;;AACA,MAAIR,IAAI,CAAC0C,SAAL,CAAe,gBAAf,EAAiCC,MAAjC,GAA0C,CAA1C,IAA+C,CAAC3C,IAAI,CAACtD,CAAL,CAAO6B,UAA3D,EAAuE;AACrEyB,IAAAA,IAAI,CAACW,IAAL,CAAU,gBAAV,EAA4B;AAAEnE,MAAAA,UAAU,EAAEA,UAAU,CAACwD,IAAD;AAAxB,KAA5B;AACD;;AAED,MAAIA,IAAI,CAACtD,CAAL,CAAOQ,MAAP,CAAc0G,OAAd,EAAJ,EAA6B;AAC3B5D,IAAAA,IAAI,CAACtD,CAAL,CAAOQ,MAAP,CAAc2G,KAAd,CAAoB7I,CAAC,CAAC,6BAAD,EAAgCgF,IAAI,CAACQ,IAArC,CAArB;AACD,GAzDoD,CA2DrD;;;AACA,OAAK9D,CAAL,CAAO0B,IAAP,CAAY+G,OAAZ,CAAoBtI,OAAO,CAAC6I,KAA5B,EAAmCtF,QAAnC;AACD,CA7DD;AA+DA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEAuF,MAAM,CAACC,OAAP,GAAiBhJ,MAAjB","sourcesContent":["'use strict';\n\nvar inherits = require('util').inherits,\n  f = require('util').format,\n  EventEmitter = require('events').EventEmitter,\n  ReadPreference = require('./read_preference'),\n  Logger = require('../connection/logger'),\n  debugOptions = require('../connection/utils').debugOptions,\n  retrieveBSON = require('../connection/utils').retrieveBSON,\n  Pool = require('../connection/pool'),\n  MongoError = require('../error').MongoError,\n  MongoNetworkError = require('../error').MongoNetworkError,\n  wireProtocol = require('../wireprotocol'),\n  CoreCursor = require('../cursor').CoreCursor,\n  sdam = require('./shared'),\n  createCompressionInfo = require('./shared').createCompressionInfo,\n  resolveClusterTime = require('./shared').resolveClusterTime,\n  SessionMixins = require('./shared').SessionMixins,\n  relayEvents = require('../utils').relayEvents;\n\nconst collationNotSupported = require('../utils').collationNotSupported;\nconst makeClientMetadata = require('../utils').makeClientMetadata;\n\n// Used for filtering out fields for loggin\nvar debugFields = [\n  'reconnect',\n  'reconnectTries',\n  'reconnectInterval',\n  'emitError',\n  'cursorFactory',\n  'host',\n  'port',\n  'size',\n  'keepAlive',\n  'keepAliveInitialDelay',\n  'noDelay',\n  'connectionTimeout',\n  'checkServerIdentity',\n  'socketTimeout',\n  'ssl',\n  'ca',\n  'crl',\n  'cert',\n  'key',\n  'rejectUnauthorized',\n  'promoteLongs',\n  'promoteValues',\n  'promoteBuffers',\n  'servername'\n];\n\n// Server instance id\nvar id = 0;\nvar serverAccounting = false;\nvar servers = {};\nvar BSON = retrieveBSON();\n\nfunction topologyId(server) {\n  return server.s.parent == null ? server.id : server.s.parent.id;\n}\n\n/**\n * Creates a new Server instance\n * @class\n * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\n * @param {number} [options.monitoring=true] Enable the server state monitoring (calling ismaster at monitoringInterval)\n * @param {number} [options.monitoringInterval=5000] The interval of calling ismaster when monitoring is enabled.\n * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.size=5] Server connection pool size\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {string} [options.appname=null] Application name, passed in on ismaster call and logged in mongod server logs. Maximum size 128 bytes.\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\n * @return {Server} A cursor instance\n * @fires Server#connect\n * @fires Server#close\n * @fires Server#error\n * @fires Server#timeout\n * @fires Server#parseError\n * @fires Server#reconnect\n * @fires Server#reconnectFailed\n * @fires Server#serverHeartbeatStarted\n * @fires Server#serverHeartbeatSucceeded\n * @fires Server#serverHeartbeatFailed\n * @fires Server#topologyOpening\n * @fires Server#topologyClosed\n * @fires Server#topologyDescriptionChanged\n * @property {string} type the topology type.\n * @property {string} parserType the parser type used (c++ or js).\n */\nvar Server = function(options) {\n  options = options || {};\n\n  // Add event listener\n  EventEmitter.call(this);\n\n  // Server instance id\n  this.id = id++;\n\n  // Internal state\n  this.s = {\n    // Options\n    options: Object.assign({ metadata: makeClientMetadata(options) }, options),\n    // Logger\n    logger: Logger('Server', options),\n    // Factory overrides\n    Cursor: options.cursorFactory || CoreCursor,\n    // BSON instance\n    bson:\n      options.bson ||\n      new BSON([\n        BSON.Binary,\n        BSON.Code,\n        BSON.DBRef,\n        BSON.Decimal128,\n        BSON.Double,\n        BSON.Int32,\n        BSON.Long,\n        BSON.Map,\n        BSON.MaxKey,\n        BSON.MinKey,\n        BSON.ObjectId,\n        BSON.BSONRegExp,\n        BSON.Symbol,\n        BSON.Timestamp\n      ]),\n    // Pool\n    pool: null,\n    // Disconnect handler\n    disconnectHandler: options.disconnectHandler,\n    // Monitor thread (keeps the connection alive)\n    monitoring: typeof options.monitoring === 'boolean' ? options.monitoring : true,\n    // Is the server in a topology\n    inTopology: !!options.parent,\n    // Monitoring timeout\n    monitoringInterval:\n      typeof options.monitoringInterval === 'number' ? options.monitoringInterval : 5000,\n    compression: { compressors: createCompressionInfo(options) },\n    // Optional parent topology\n    parent: options.parent\n  };\n\n  // If this is a single deployment we need to track the clusterTime here\n  if (!this.s.parent) {\n    this.s.clusterTime = null;\n  }\n\n  // Curent ismaster\n  this.ismaster = null;\n  // Current ping time\n  this.lastIsMasterMS = -1;\n  // The monitoringProcessId\n  this.monitoringProcessId = null;\n  // Initial connection\n  this.initialConnect = true;\n  // Default type\n  this._type = 'server';\n\n  // Max Stalleness values\n  // last time we updated the ismaster state\n  this.lastUpdateTime = 0;\n  // Last write time\n  this.lastWriteDate = 0;\n  // Stalleness\n  this.staleness = 0;\n};\n\ninherits(Server, EventEmitter);\nObject.assign(Server.prototype, SessionMixins);\n\nObject.defineProperty(Server.prototype, 'type', {\n  enumerable: true,\n  get: function() {\n    return this._type;\n  }\n});\n\nObject.defineProperty(Server.prototype, 'parserType', {\n  enumerable: true,\n  get: function() {\n    return BSON.native ? 'c++' : 'js';\n  }\n});\n\nObject.defineProperty(Server.prototype, 'logicalSessionTimeoutMinutes', {\n  enumerable: true,\n  get: function() {\n    if (!this.ismaster) return null;\n    return this.ismaster.logicalSessionTimeoutMinutes || null;\n  }\n});\n\nObject.defineProperty(Server.prototype, 'clientMetadata', {\n  enumerable: true,\n  get: function() {\n    return this.s.options.metadata;\n  }\n});\n\n// In single server deployments we track the clusterTime directly on the topology, however\n// in Mongos and ReplSet deployments we instead need to delegate the clusterTime up to the\n// tracking objects so we can ensure we are gossiping the maximum time received from the\n// server.\nObject.defineProperty(Server.prototype, 'clusterTime', {\n  enumerable: true,\n  set: function(clusterTime) {\n    const settings = this.s.parent ? this.s.parent : this.s;\n    resolveClusterTime(settings, clusterTime);\n  },\n  get: function() {\n    const settings = this.s.parent ? this.s.parent : this.s;\n    return settings.clusterTime || null;\n  }\n});\n\nServer.enableServerAccounting = function() {\n  serverAccounting = true;\n  servers = {};\n};\n\nServer.disableServerAccounting = function() {\n  serverAccounting = false;\n};\n\nServer.servers = function() {\n  return servers;\n};\n\nObject.defineProperty(Server.prototype, 'name', {\n  enumerable: true,\n  get: function() {\n    return this.s.options.host + ':' + this.s.options.port;\n  }\n});\n\nfunction disconnectHandler(self, type, ns, cmd, options, callback) {\n  // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n  if (\n    !self.s.pool.isConnected() &&\n    self.s.options.reconnect &&\n    self.s.disconnectHandler != null &&\n    !options.monitoring\n  ) {\n    self.s.disconnectHandler.add(type, ns, cmd, options, callback);\n    return true;\n  }\n\n  // If we have no connection error\n  if (!self.s.pool.isConnected()) {\n    callback(new MongoError(f('no connection available to server %s', self.name)));\n    return true;\n  }\n}\n\nfunction monitoringProcess(self) {\n  return function() {\n    // Pool was destroyed do not continue process\n    if (self.s.pool.isDestroyed()) return;\n    // Emit monitoring Process event\n    self.emit('monitoring', self);\n    // Perform ismaster call\n    // Get start time\n    var start = new Date().getTime();\n\n    // Execute the ismaster query\n    self.command(\n      'admin.$cmd',\n      { ismaster: true },\n      {\n        socketTimeout:\n          typeof self.s.options.connectionTimeout !== 'number'\n            ? 2000\n            : self.s.options.connectionTimeout,\n        monitoring: true\n      },\n      (err, result) => {\n        // Set initial lastIsMasterMS\n        self.lastIsMasterMS = new Date().getTime() - start;\n        if (self.s.pool.isDestroyed()) return;\n        // Update the ismaster view if we have a result\n        if (result) {\n          self.ismaster = result.result;\n        }\n        // Re-schedule the monitoring process\n        self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);\n      }\n    );\n  };\n}\n\nvar eventHandler = function(self, event) {\n  return function(err, conn) {\n    // Log information of received information if in info mode\n    if (self.s.logger.isInfo()) {\n      var object = err instanceof MongoError ? JSON.stringify(err) : {};\n      self.s.logger.info(\n        f('server %s fired event %s out with message %s', self.name, event, object)\n      );\n    }\n\n    // Handle connect event\n    if (event === 'connect') {\n      self.initialConnect = false;\n      self.ismaster = conn.ismaster;\n      self.lastIsMasterMS = conn.lastIsMasterMS;\n      if (conn.agreedCompressor) {\n        self.s.pool.options.agreedCompressor = conn.agreedCompressor;\n      }\n\n      if (conn.zlibCompressionLevel) {\n        self.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;\n      }\n\n      if (conn.ismaster.$clusterTime) {\n        const $clusterTime = conn.ismaster.$clusterTime;\n        self.clusterTime = $clusterTime;\n      }\n\n      // It's a proxy change the type so\n      // the wireprotocol will send $readPreference\n      if (self.ismaster.msg === 'isdbgrid') {\n        self._type = 'mongos';\n      }\n\n      // Have we defined self monitoring\n      if (self.s.monitoring) {\n        self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);\n      }\n\n      // Emit server description changed if something listening\n      sdam.emitServerDescriptionChanged(self, {\n        address: self.name,\n        arbiters: [],\n        hosts: [],\n        passives: [],\n        type: sdam.getTopologyType(self)\n      });\n\n      if (!self.s.inTopology) {\n        // Emit topology description changed if something listening\n        sdam.emitTopologyDescriptionChanged(self, {\n          topologyType: 'Single',\n          servers: [\n            {\n              address: self.name,\n              arbiters: [],\n              hosts: [],\n              passives: [],\n              type: sdam.getTopologyType(self)\n            }\n          ]\n        });\n      }\n\n      // Log the ismaster if available\n      if (self.s.logger.isInfo()) {\n        self.s.logger.info(\n          f('server %s connected with ismaster [%s]', self.name, JSON.stringify(self.ismaster))\n        );\n      }\n\n      // Emit connect\n      self.emit('connect', self);\n    } else if (\n      event === 'error' ||\n      event === 'parseError' ||\n      event === 'close' ||\n      event === 'timeout' ||\n      event === 'reconnect' ||\n      event === 'attemptReconnect' ||\n      event === 'reconnectFailed'\n    ) {\n      // Remove server instance from accounting\n      if (\n        serverAccounting &&\n        ['close', 'timeout', 'error', 'parseError', 'reconnectFailed'].indexOf(event) !== -1\n      ) {\n        // Emit toplogy opening event if not in topology\n        if (!self.s.inTopology) {\n          self.emit('topologyOpening', { topologyId: self.id });\n        }\n\n        delete servers[self.id];\n      }\n\n      if (event === 'close') {\n        // Closing emits a server description changed event going to unknown.\n        sdam.emitServerDescriptionChanged(self, {\n          address: self.name,\n          arbiters: [],\n          hosts: [],\n          passives: [],\n          type: 'Unknown'\n        });\n      }\n\n      // Reconnect failed return error\n      if (event === 'reconnectFailed') {\n        self.emit('reconnectFailed', err);\n        // Emit error if any listeners\n        if (self.listeners('error').length > 0) {\n          self.emit('error', err);\n        }\n        // Terminate\n        return;\n      }\n\n      // On first connect fail\n      if (\n        ['disconnected', 'connecting'].indexOf(self.s.pool.state) !== -1 &&\n        self.initialConnect &&\n        ['close', 'timeout', 'error', 'parseError'].indexOf(event) !== -1\n      ) {\n        self.initialConnect = false;\n        return self.emit(\n          'error',\n          new MongoNetworkError(\n            f('failed to connect to server [%s] on first connect [%s]', self.name, err)\n          )\n        );\n      }\n\n      // Reconnect event, emit the server\n      if (event === 'reconnect') {\n        // Reconnecting emits a server description changed event going from unknown to the\n        // current server type.\n        sdam.emitServerDescriptionChanged(self, {\n          address: self.name,\n          arbiters: [],\n          hosts: [],\n          passives: [],\n          type: sdam.getTopologyType(self)\n        });\n        return self.emit(event, self);\n      }\n\n      // Emit the event\n      self.emit(event, err);\n    }\n  };\n};\n\n/**\n * Initiate server connect\n */\nServer.prototype.connect = function(options) {\n  var self = this;\n  options = options || {};\n\n  // Set the connections\n  if (serverAccounting) servers[this.id] = this;\n\n  // Do not allow connect to be called on anything that's not disconnected\n  if (self.s.pool && !self.s.pool.isDisconnected() && !self.s.pool.isDestroyed()) {\n    throw new MongoError(f('server instance in invalid state %s', self.s.pool.state));\n  }\n\n  // Create a pool\n  self.s.pool = new Pool(this, Object.assign(self.s.options, options, { bson: this.s.bson }));\n\n  // Set up listeners\n  self.s.pool.on('close', eventHandler(self, 'close'));\n  self.s.pool.on('error', eventHandler(self, 'error'));\n  self.s.pool.on('timeout', eventHandler(self, 'timeout'));\n  self.s.pool.on('parseError', eventHandler(self, 'parseError'));\n  self.s.pool.on('connect', eventHandler(self, 'connect'));\n  self.s.pool.on('reconnect', eventHandler(self, 'reconnect'));\n  self.s.pool.on('reconnectFailed', eventHandler(self, 'reconnectFailed'));\n\n  // Set up listeners for command monitoring\n  relayEvents(self.s.pool, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);\n\n  // Emit toplogy opening event if not in topology\n  if (!self.s.inTopology) {\n    this.emit('topologyOpening', { topologyId: topologyId(self) });\n  }\n\n  // Emit opening server event\n  self.emit('serverOpening', { topologyId: topologyId(self), address: self.name });\n\n  self.s.pool.connect();\n};\n\n/**\n * Authenticate the topology.\n * @method\n * @param {MongoCredentials} credentials The credentials for authentication we are using\n * @param {authResultCallback} callback A callback function\n */\nServer.prototype.auth = function(credentials, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n\n/**\n * Get the server description\n * @method\n * @return {object}\n */\nServer.prototype.getDescription = function() {\n  var ismaster = this.ismaster || {};\n  var description = {\n    type: sdam.getTopologyType(this),\n    address: this.name\n  };\n\n  // Add fields if available\n  if (ismaster.hosts) description.hosts = ismaster.hosts;\n  if (ismaster.arbiters) description.arbiters = ismaster.arbiters;\n  if (ismaster.passives) description.passives = ismaster.passives;\n  if (ismaster.setName) description.setName = ismaster.setName;\n  return description;\n};\n\n/**\n * Returns the last known ismaster document for this server\n * @method\n * @return {object}\n */\nServer.prototype.lastIsMaster = function() {\n  return this.ismaster;\n};\n\n/**\n * Unref all connections belong to this server\n * @method\n */\nServer.prototype.unref = function() {\n  this.s.pool.unref();\n};\n\n/**\n * Figure out if the server is connected\n * @method\n * @return {boolean}\n */\nServer.prototype.isConnected = function() {\n  if (!this.s.pool) return false;\n  return this.s.pool.isConnected();\n};\n\n/**\n * Figure out if the server instance was destroyed by calling destroy\n * @method\n * @return {boolean}\n */\nServer.prototype.isDestroyed = function() {\n  if (!this.s.pool) return false;\n  return this.s.pool.isDestroyed();\n};\n\nfunction basicWriteValidations(self) {\n  if (!self.s.pool) return new MongoError('server instance is not connected');\n  if (self.s.pool.isDestroyed()) return new MongoError('server instance pool was destroyed');\n}\n\nfunction basicReadValidations(self, options) {\n  basicWriteValidations(self, options);\n\n  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {\n    throw new Error('readPreference must be an instance of ReadPreference');\n  }\n}\n\n/**\n * Execute a command\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cmd The command hash\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\nServer.prototype.command = function(ns, cmd, options, callback) {\n  var self = this;\n  if (typeof options === 'function') {\n    (callback = options), (options = {}), (options = options || {});\n  }\n\n  var result = basicReadValidations(self, options);\n  if (result) return callback(result);\n\n  // Clone the options\n  options = Object.assign({}, options, { wireProtocolCommand: false });\n\n  // Debug log\n  if (self.s.logger.isDebug())\n    self.s.logger.debug(\n      f(\n        'executing command [%s] against %s',\n        JSON.stringify({\n          ns: ns,\n          cmd: cmd,\n          options: debugOptions(debugFields, options)\n        }),\n        self.name\n      )\n    );\n\n  // If we are not connected or have a disconnectHandler specified\n  if (disconnectHandler(self, 'command', ns, cmd, options, callback)) return;\n\n  // error if collation not supported\n  if (collationNotSupported(this, cmd)) {\n    return callback(new MongoError(`server ${this.name} does not support collation`));\n  }\n\n  wireProtocol.command(self, ns, cmd, options, callback);\n};\n\n/**\n * Execute a query against the server\n *\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cmd The command document for the query\n * @param {object} options Optional settings\n * @param {function} callback\n */\nServer.prototype.query = function(ns, cmd, cursorState, options, callback) {\n  wireProtocol.query(this, ns, cmd, cursorState, options, callback);\n};\n\n/**\n * Execute a `getMore` against the server\n *\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cursorState State data associated with the cursor calling this method\n * @param {object} options Optional settings\n * @param {function} callback\n */\nServer.prototype.getMore = function(ns, cursorState, batchSize, options, callback) {\n  wireProtocol.getMore(this, ns, cursorState, batchSize, options, callback);\n};\n\n/**\n * Execute a `killCursors` command against the server\n *\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cursorState State data associated with the cursor calling this method\n * @param {function} callback\n */\nServer.prototype.killCursors = function(ns, cursorState, callback) {\n  wireProtocol.killCursors(this, ns, cursorState, callback);\n};\n\n/**\n * Insert one or more documents\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of documents to insert\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\nServer.prototype.insert = function(ns, ops, options, callback) {\n  var self = this;\n  if (typeof options === 'function') {\n    (callback = options), (options = {}), (options = options || {});\n  }\n\n  var result = basicWriteValidations(self, options);\n  if (result) return callback(result);\n\n  // If we are not connected or have a disconnectHandler specified\n  if (disconnectHandler(self, 'insert', ns, ops, options, callback)) return;\n\n  // Setup the docs as an array\n  ops = Array.isArray(ops) ? ops : [ops];\n\n  // Execute write\n  return wireProtocol.insert(self, ns, ops, options, callback);\n};\n\n/**\n * Perform one or more update operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of updates\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\nServer.prototype.update = function(ns, ops, options, callback) {\n  var self = this;\n  if (typeof options === 'function') {\n    (callback = options), (options = {}), (options = options || {});\n  }\n\n  var result = basicWriteValidations(self, options);\n  if (result) return callback(result);\n\n  // If we are not connected or have a disconnectHandler specified\n  if (disconnectHandler(self, 'update', ns, ops, options, callback)) return;\n\n  // error if collation not supported\n  if (collationNotSupported(this, options)) {\n    return callback(new MongoError(`server ${this.name} does not support collation`));\n  }\n\n  // Setup the docs as an array\n  ops = Array.isArray(ops) ? ops : [ops];\n  // Execute write\n  return wireProtocol.update(self, ns, ops, options, callback);\n};\n\n/**\n * Perform one or more remove operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of removes\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\nServer.prototype.remove = function(ns, ops, options, callback) {\n  var self = this;\n  if (typeof options === 'function') {\n    (callback = options), (options = {}), (options = options || {});\n  }\n\n  var result = basicWriteValidations(self, options);\n  if (result) return callback(result);\n\n  // If we are not connected or have a disconnectHandler specified\n  if (disconnectHandler(self, 'remove', ns, ops, options, callback)) return;\n\n  // error if collation not supported\n  if (collationNotSupported(this, options)) {\n    return callback(new MongoError(`server ${this.name} does not support collation`));\n  }\n\n  // Setup the docs as an array\n  ops = Array.isArray(ops) ? ops : [ops];\n  // Execute write\n  return wireProtocol.remove(self, ns, ops, options, callback);\n};\n\n/**\n * Get a new cursor\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId\n * @param {object} [options] Options for the cursor\n * @param {object} [options.batchSize=0] Batchsize for the operation\n * @param {array} [options.documents=[]] Initial documents list for cursor\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {object} [options.topology] The internal topology of the created cursor\n * @returns {Cursor}\n */\nServer.prototype.cursor = function(ns, cmd, options) {\n  options = options || {};\n  const topology = options.topology || this;\n\n  // Set up final cursor type\n  var FinalCursor = options.cursorFactory || this.s.Cursor;\n\n  // Return the cursor\n  return new FinalCursor(topology, ns, cmd, options);\n};\n\n/**\n * Compare two server instances\n * @method\n * @param {Server} server Server to compare equality against\n * @return {boolean}\n */\nServer.prototype.equals = function(server) {\n  if (typeof server === 'string') return this.name.toLowerCase() === server.toLowerCase();\n  if (server.name) return this.name.toLowerCase() === server.name.toLowerCase();\n  return false;\n};\n\n/**\n * All raw connections\n * @method\n * @return {Connection[]}\n */\nServer.prototype.connections = function() {\n  return this.s.pool.allConnections();\n};\n\n/**\n * Selects a server\n * @method\n * @param {function} selector Unused\n * @param {ReadPreference} [options.readPreference] Unused\n * @param {ClientSession} [options.session] Unused\n * @return {Server}\n */\nServer.prototype.selectServer = function(selector, options, callback) {\n  if (typeof selector === 'function' && typeof callback === 'undefined')\n    (callback = selector), (selector = undefined), (options = {});\n  if (typeof options === 'function')\n    (callback = options), (options = selector), (selector = undefined);\n\n  callback(null, this);\n};\n\nvar listeners = ['close', 'error', 'timeout', 'parseError', 'connect'];\n\n/**\n * Destroy the server connection\n * @method\n * @param {boolean} [options.emitClose=false] Emit close event on destroy\n * @param {boolean} [options.emitDestroy=false] Emit destroy event on destroy\n * @param {boolean} [options.force=false] Force destroy the pool\n */\nServer.prototype.destroy = function(options, callback) {\n  if (this._destroyed) {\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  }\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  var self = this;\n\n  // Set the connections\n  if (serverAccounting) delete servers[this.id];\n\n  // Destroy the monitoring process if any\n  if (this.monitoringProcessId) {\n    clearTimeout(this.monitoringProcessId);\n  }\n\n  // No pool, return\n  if (!self.s.pool || this._destroyed) {\n    this._destroyed = true;\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  }\n\n  this._destroyed = true;\n\n  // Emit close event\n  if (options.emitClose) {\n    self.emit('close', self);\n  }\n\n  // Emit destroy event\n  if (options.emitDestroy) {\n    self.emit('destroy', self);\n  }\n\n  // Remove all listeners\n  listeners.forEach(function(event) {\n    self.s.pool.removeAllListeners(event);\n  });\n\n  // Emit opening server event\n  if (self.listeners('serverClosed').length > 0)\n    self.emit('serverClosed', { topologyId: topologyId(self), address: self.name });\n\n  // Emit toplogy opening event if not in topology\n  if (self.listeners('topologyClosed').length > 0 && !self.s.inTopology) {\n    self.emit('topologyClosed', { topologyId: topologyId(self) });\n  }\n\n  if (self.s.logger.isDebug()) {\n    self.s.logger.debug(f('destroy called on server %s', self.name));\n  }\n\n  // Destroy the pool\n  this.s.pool.destroy(options.force, callback);\n};\n\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Server#connect\n * @type {Server}\n */\n\n/**\n * A server reconnect event, used to verify that the server topology has reconnected\n *\n * @event Server#reconnect\n * @type {Server}\n */\n\n/**\n * A server opening SDAM monitoring event\n *\n * @event Server#serverOpening\n * @type {object}\n */\n\n/**\n * A server closed SDAM monitoring event\n *\n * @event Server#serverClosed\n * @type {object}\n */\n\n/**\n * A server description SDAM change monitoring event\n *\n * @event Server#serverDescriptionChanged\n * @type {object}\n */\n\n/**\n * A topology open SDAM event\n *\n * @event Server#topologyOpening\n * @type {object}\n */\n\n/**\n * A topology closed SDAM event\n *\n * @event Server#topologyClosed\n * @type {object}\n */\n\n/**\n * A topology structure SDAM change event\n *\n * @event Server#topologyDescriptionChanged\n * @type {object}\n */\n\n/**\n * Server reconnect failed\n *\n * @event Server#reconnectFailed\n * @type {Error}\n */\n\n/**\n * Server connection pool closed\n *\n * @event Server#close\n * @type {object}\n */\n\n/**\n * Server connection pool caused an error\n *\n * @event Server#error\n * @type {Error}\n */\n\n/**\n * Server destroyed was called\n *\n * @event Server#destroy\n * @type {Server}\n */\n\nmodule.exports = Server;\n"]},"metadata":{},"sourceType":"script"}