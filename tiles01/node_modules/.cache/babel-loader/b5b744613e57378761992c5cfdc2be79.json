{"ast":null,"code":"'use strict';\n\nconst ServerType = require('./common').ServerType;\n\nconst ServerDescription = require('./server_description').ServerDescription;\n\nconst WIRE_CONSTANTS = require('../wireprotocol/constants');\n\nconst TopologyType = require('./common').TopologyType; // contstants related to compatability checks\n\n\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION; // Representation of a deployment of servers\n\nclass TopologyDescription {\n  /**\n   * Create a TopologyDescription\n   *\n   * @param {string} topologyType\n   * @param {Map<string, ServerDescription>} serverDescriptions the a map of address to ServerDescription\n   * @param {string} setName\n   * @param {number} maxSetVersion\n   * @param {ObjectId} maxElectionId\n   */\n  constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options) {\n    options = options || {}; // TODO: consider assigning all these values to a temporary value `s` which\n    //       we use `Object.freeze` on, ensuring the internal state of this type\n    //       is immutable.\n\n    this.type = topologyType || TopologyType.Unknown;\n    this.setName = setName || null;\n    this.maxSetVersion = maxSetVersion || null;\n    this.maxElectionId = maxElectionId || null;\n    this.servers = serverDescriptions || new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.compatibilityError = null;\n    this.logicalSessionTimeoutMinutes = null;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 0;\n    this.localThresholdMS = options.localThresholdMS || 0;\n    this.commonWireVersion = commonWireVersion || null; // save this locally, but don't display when printing the instance out\n\n    Object.defineProperty(this, 'options', {\n      value: options,\n      enumberable: false\n    }); // determine server compatibility\n\n    for (const serverDescription of this.servers.values()) {\n      if (serverDescription.type === ServerType.Unknown) continue;\n\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    } // Whenever a client updates the TopologyDescription from an ismaster response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n\n\n    const readableServers = Array.from(this.servers.values()).filter(s => s.isReadable);\n    this.logicalSessionTimeoutMinutes = readableServers.reduce((result, server) => {\n      if (server.logicalSessionTimeoutMinutes == null) return null;\n      if (result == null) return server.logicalSessionTimeoutMinutes;\n      return Math.min(result, server.logicalSessionTimeoutMinutes);\n    }, null);\n  }\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @param {SrvPollingEvent} ev The event\n   */\n\n\n  updateFromSrvPollingEvent(ev) {\n    const newAddresses = ev.addresses();\n    const serverDescriptions = new Map(this.servers);\n\n    for (const server of this.servers) {\n      if (newAddresses.has(server[0])) {\n        newAddresses.delete(server[0]);\n      } else {\n        serverDescriptions.delete(server[0]);\n      }\n    }\n\n    if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {\n      return this;\n    }\n\n    for (const address of newAddresses) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n\n    return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, this.options, null);\n  }\n  /**\n   * Returns a copy of this description updated with a given ServerDescription\n   *\n   * @param {ServerDescription} serverDescription\n   */\n\n\n  update(serverDescription) {\n    const address = serverDescription.address; // NOTE: there are a number of prime targets for refactoring here\n    //       once we support destructuring assignments\n    // potentially mutated values\n\n    let topologyType = this.type;\n    let setName = this.setName;\n    let maxSetVersion = this.maxSetVersion;\n    let maxElectionId = this.maxElectionId;\n    let commonWireVersion = this.commonWireVersion;\n\n    if (serverDescription.setName && setName && serverDescription.setName !== setName) {\n      serverDescription = new ServerDescription(address, null);\n    }\n\n    const serverType = serverDescription.type;\n    let serverDescriptions = new Map(this.servers); // update common wire version\n\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    } // update the actual server description\n\n\n    serverDescriptions.set(address, serverDescription);\n\n    if (topologyType === TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);\n    }\n\n    if (topologyType === TopologyType.Unknown) {\n      if (serverType === ServerType.Standalone && this.servers.size !== 1) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n\n    if (topologyType === TopologyType.Sharded) {\n      if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetNoPrimary) {\n      if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n        serverDescriptions.delete(address);\n      }\n\n      if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);\n        topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];\n      } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);\n        topologyType = result[0], setName = result[1];\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetWithPrimary) {\n      if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);\n        topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];\n      } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {\n        topologyType = updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription);\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n\n    return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);\n  }\n\n  get error() {\n    const descriptionsWithError = Array.from(this.servers.values()).filter(sd => sd.error);\n\n    if (descriptionsWithError.length > 0) {\n      return descriptionsWithError[0].error;\n    }\n\n    return undefined;\n  }\n  /**\n   * Determines if the topology description has any known servers\n   */\n\n\n  get hasKnownServers() {\n    return Array.from(this.servers.values()).some(sd => sd.type !== ServerType.Unknown);\n  }\n  /**\n   * Determines if this topology description has a data-bearing server available.\n   */\n\n\n  get hasDataBearingServers() {\n    return Array.from(this.servers.values()).some(sd => sd.isDataBearing);\n  }\n  /**\n   * Determines if the topology has a definition for the provided address\n   *\n   * @param {String} address\n   * @return {Boolean} Whether the topology knows about this server\n   */\n\n\n  hasServer(address) {\n    return this.servers.has(address);\n  }\n\n}\n\nfunction topologyTypeForServerType(serverType) {\n  if (serverType === ServerType.Standalone) {\n    return TopologyType.Single;\n  }\n\n  if (serverType === ServerType.Mongos) {\n    return TopologyType.Sharded;\n  }\n\n  if (serverType === ServerType.RSPrimary) {\n    return TopologyType.ReplicaSetWithPrimary;\n  }\n\n  if (serverType === ServerType.RSGhost || serverType === ServerType.Unknown) {\n    return TopologyType.Unknown;\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nfunction compareObjectId(oid1, oid2) {\n  if (oid1 == null) {\n    return -1;\n  }\n\n  if (oid2 == null) {\n    return 1;\n  }\n\n  if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\n    const oid1Buffer = oid1.id;\n    const oid2Buffer = oid2.id;\n    return oid1Buffer.compare(oid2Buffer);\n  }\n\n  const oid1String = oid1.toString();\n  const oid2String = oid2.toString();\n  return oid1String.localeCompare(oid2String);\n}\n\nfunction updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId) {\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n\n  if (serverDescription.setVersion && electionId) {\n    if (maxSetVersion && maxElectionId) {\n      if (maxSetVersion > serverDescription.setVersion || compareObjectId(maxElectionId, electionId) > 0) {\n        // this primary is stale, we must remove it\n        serverDescriptions.set(serverDescription.address, new ServerDescription(serverDescription.address));\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n      }\n    }\n\n    maxElectionId = serverDescription.electionId;\n  }\n\n  if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {\n    maxSetVersion = serverDescription.setVersion;\n  } // We've heard from the primary. Is it the same primary as before?\n\n\n  for (const address of serverDescriptions.keys()) {\n    const server = serverDescriptions.get(address);\n\n    if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(address, new ServerDescription(server.address)); // There can only be one primary\n\n      break;\n    }\n  } // Discover new hosts from this primary's response.\n\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  }); // Remove hosts not in the response.\n\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses.filter(addr => responseAddresses.indexOf(addr) === -1).forEach(address => {\n    serverDescriptions.delete(address);\n  });\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  if (setName == null) {\n    throw new TypeError('setName is required');\n  }\n\n  if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  let topologyType = TopologyType.ReplicaSetNoPrimary;\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions) {\n  for (const addr of serverDescriptions.keys()) {\n    if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {\n      return TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nmodule.exports = {\n  TopologyDescription\n};","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/core/sdam/topology_description.js"],"names":["ServerType","require","ServerDescription","WIRE_CONSTANTS","TopologyType","MIN_SUPPORTED_SERVER_VERSION","MAX_SUPPORTED_SERVER_VERSION","MIN_SUPPORTED_WIRE_VERSION","MAX_SUPPORTED_WIRE_VERSION","TopologyDescription","constructor","topologyType","serverDescriptions","setName","maxSetVersion","maxElectionId","commonWireVersion","options","type","Unknown","servers","Map","stale","compatible","compatibilityError","logicalSessionTimeoutMinutes","heartbeatFrequencyMS","localThresholdMS","Object","defineProperty","value","enumberable","serverDescription","values","minWireVersion","address","maxWireVersion","readableServers","Array","from","filter","s","isReadable","reduce","result","server","Math","min","updateFromSrvPollingEvent","ev","newAddresses","addresses","has","delete","size","set","update","serverType","Single","Standalone","topologyTypeForServerType","Sharded","Mongos","indexOf","ReplicaSetNoPrimary","RSPrimary","updateRsFromPrimary","RSSecondary","RSArbiter","RSOther","updateRsNoPrimaryFromMember","ReplicaSetWithPrimary","checkHasPrimary","updateRsWithPrimaryFromMember","error","descriptionsWithError","sd","length","undefined","hasKnownServers","some","hasDataBearingServers","isDataBearing","hasServer","RSGhost","compareObjectId","oid1","oid2","id","Buffer","oid1Buffer","oid2Buffer","compare","oid1String","toString","oid2String","localeCompare","electionId","setVersion","keys","get","allHosts","forEach","currentAddresses","responseAddresses","addr","TypeError","me","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst ServerType = require('./common').ServerType;\nconst ServerDescription = require('./server_description').ServerDescription;\nconst WIRE_CONSTANTS = require('../wireprotocol/constants');\nconst TopologyType = require('./common').TopologyType;\n\n// contstants related to compatability checks\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\n\n// Representation of a deployment of servers\nclass TopologyDescription {\n  /**\n   * Create a TopologyDescription\n   *\n   * @param {string} topologyType\n   * @param {Map<string, ServerDescription>} serverDescriptions the a map of address to ServerDescription\n   * @param {string} setName\n   * @param {number} maxSetVersion\n   * @param {ObjectId} maxElectionId\n   */\n  constructor(\n    topologyType,\n    serverDescriptions,\n    setName,\n    maxSetVersion,\n    maxElectionId,\n    commonWireVersion,\n    options\n  ) {\n    options = options || {};\n\n    // TODO: consider assigning all these values to a temporary value `s` which\n    //       we use `Object.freeze` on, ensuring the internal state of this type\n    //       is immutable.\n    this.type = topologyType || TopologyType.Unknown;\n    this.setName = setName || null;\n    this.maxSetVersion = maxSetVersion || null;\n    this.maxElectionId = maxElectionId || null;\n    this.servers = serverDescriptions || new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.compatibilityError = null;\n    this.logicalSessionTimeoutMinutes = null;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 0;\n    this.localThresholdMS = options.localThresholdMS || 0;\n    this.commonWireVersion = commonWireVersion || null;\n\n    // save this locally, but don't display when printing the instance out\n    Object.defineProperty(this, 'options', { value: options, enumberable: false });\n\n    // determine server compatibility\n    for (const serverDescription of this.servers.values()) {\n      if (serverDescription.type === ServerType.Unknown) continue;\n\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    }\n\n    // Whenever a client updates the TopologyDescription from an ismaster response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n    const readableServers = Array.from(this.servers.values()).filter(s => s.isReadable);\n    this.logicalSessionTimeoutMinutes = readableServers.reduce((result, server) => {\n      if (server.logicalSessionTimeoutMinutes == null) return null;\n      if (result == null) return server.logicalSessionTimeoutMinutes;\n      return Math.min(result, server.logicalSessionTimeoutMinutes);\n    }, null);\n  }\n\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @param {SrvPollingEvent} ev The event\n   */\n  updateFromSrvPollingEvent(ev) {\n    const newAddresses = ev.addresses();\n    const serverDescriptions = new Map(this.servers);\n    for (const server of this.servers) {\n      if (newAddresses.has(server[0])) {\n        newAddresses.delete(server[0]);\n      } else {\n        serverDescriptions.delete(server[0]);\n      }\n    }\n\n    if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {\n      return this;\n    }\n\n    for (const address of newAddresses) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n\n    return new TopologyDescription(\n      this.type,\n      serverDescriptions,\n      this.setName,\n      this.maxSetVersion,\n      this.maxElectionId,\n      this.commonWireVersion,\n      this.options,\n      null\n    );\n  }\n\n  /**\n   * Returns a copy of this description updated with a given ServerDescription\n   *\n   * @param {ServerDescription} serverDescription\n   */\n  update(serverDescription) {\n    const address = serverDescription.address;\n    // NOTE: there are a number of prime targets for refactoring here\n    //       once we support destructuring assignments\n\n    // potentially mutated values\n    let topologyType = this.type;\n    let setName = this.setName;\n    let maxSetVersion = this.maxSetVersion;\n    let maxElectionId = this.maxElectionId;\n    let commonWireVersion = this.commonWireVersion;\n\n    if (serverDescription.setName && setName && serverDescription.setName !== setName) {\n      serverDescription = new ServerDescription(address, null);\n    }\n\n    const serverType = serverDescription.type;\n    let serverDescriptions = new Map(this.servers);\n\n    // update common wire version\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    }\n\n    // update the actual server description\n    serverDescriptions.set(address, serverDescription);\n\n    if (topologyType === TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(\n        TopologyType.Single,\n        serverDescriptions,\n        setName,\n        maxSetVersion,\n        maxElectionId,\n        commonWireVersion,\n        this.options\n      );\n    }\n\n    if (topologyType === TopologyType.Unknown) {\n      if (serverType === ServerType.Standalone && this.servers.size !== 1) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n\n    if (topologyType === TopologyType.Sharded) {\n      if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetNoPrimary) {\n      if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n        serverDescriptions.delete(address);\n      }\n\n      if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(\n          serverDescriptions,\n          setName,\n          serverDescription,\n          maxSetVersion,\n          maxElectionId\n        );\n\n        (topologyType = result[0]),\n          (setName = result[1]),\n          (maxSetVersion = result[2]),\n          (maxElectionId = result[3]);\n      } else if (\n        [ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0\n      ) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);\n        (topologyType = result[0]), (setName = result[1]);\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetWithPrimary) {\n      if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(\n          serverDescriptions,\n          setName,\n          serverDescription,\n          maxSetVersion,\n          maxElectionId\n        );\n\n        (topologyType = result[0]),\n          (setName = result[1]),\n          (maxSetVersion = result[2]),\n          (maxElectionId = result[3]);\n      } else if (\n        [ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0\n      ) {\n        topologyType = updateRsWithPrimaryFromMember(\n          serverDescriptions,\n          setName,\n          serverDescription\n        );\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n\n    return new TopologyDescription(\n      topologyType,\n      serverDescriptions,\n      setName,\n      maxSetVersion,\n      maxElectionId,\n      commonWireVersion,\n      this.options\n    );\n  }\n\n  get error() {\n    const descriptionsWithError = Array.from(this.servers.values()).filter(sd => sd.error);\n    if (descriptionsWithError.length > 0) {\n      return descriptionsWithError[0].error;\n    }\n    return undefined;\n  }\n\n  /**\n   * Determines if the topology description has any known servers\n   */\n  get hasKnownServers() {\n    return Array.from(this.servers.values()).some(sd => sd.type !== ServerType.Unknown);\n  }\n\n  /**\n   * Determines if this topology description has a data-bearing server available.\n   */\n  get hasDataBearingServers() {\n    return Array.from(this.servers.values()).some(sd => sd.isDataBearing);\n  }\n\n  /**\n   * Determines if the topology has a definition for the provided address\n   *\n   * @param {String} address\n   * @return {Boolean} Whether the topology knows about this server\n   */\n  hasServer(address) {\n    return this.servers.has(address);\n  }\n}\n\nfunction topologyTypeForServerType(serverType) {\n  if (serverType === ServerType.Standalone) {\n    return TopologyType.Single;\n  }\n\n  if (serverType === ServerType.Mongos) {\n    return TopologyType.Sharded;\n  }\n\n  if (serverType === ServerType.RSPrimary) {\n    return TopologyType.ReplicaSetWithPrimary;\n  }\n\n  if (serverType === ServerType.RSGhost || serverType === ServerType.Unknown) {\n    return TopologyType.Unknown;\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nfunction compareObjectId(oid1, oid2) {\n  if (oid1 == null) {\n    return -1;\n  }\n\n  if (oid2 == null) {\n    return 1;\n  }\n\n  if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\n    const oid1Buffer = oid1.id;\n    const oid2Buffer = oid2.id;\n    return oid1Buffer.compare(oid2Buffer);\n  }\n\n  const oid1String = oid1.toString();\n  const oid2String = oid2.toString();\n  return oid1String.localeCompare(oid2String);\n}\n\nfunction updateRsFromPrimary(\n  serverDescriptions,\n  setName,\n  serverDescription,\n  maxSetVersion,\n  maxElectionId\n) {\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n  if (serverDescription.setVersion && electionId) {\n    if (maxSetVersion && maxElectionId) {\n      if (\n        maxSetVersion > serverDescription.setVersion ||\n        compareObjectId(maxElectionId, electionId) > 0\n      ) {\n        // this primary is stale, we must remove it\n        serverDescriptions.set(\n          serverDescription.address,\n          new ServerDescription(serverDescription.address)\n        );\n\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n      }\n    }\n\n    maxElectionId = serverDescription.electionId;\n  }\n\n  if (\n    serverDescription.setVersion != null &&\n    (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)\n  ) {\n    maxSetVersion = serverDescription.setVersion;\n  }\n\n  // We've heard from the primary. Is it the same primary as before?\n  for (const address of serverDescriptions.keys()) {\n    const server = serverDescriptions.get(address);\n\n    if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(address, new ServerDescription(server.address));\n\n      // There can only be one primary\n      break;\n    }\n  }\n\n  // Discover new hosts from this primary's response.\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  // Remove hosts not in the response.\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses\n    .filter(addr => responseAddresses.indexOf(addr) === -1)\n    .forEach(address => {\n      serverDescriptions.delete(address);\n    });\n\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  if (setName == null) {\n    throw new TypeError('setName is required');\n  }\n\n  if (\n    setName !== serverDescription.setName ||\n    (serverDescription.me && serverDescription.address !== serverDescription.me)\n  ) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  let topologyType = TopologyType.ReplicaSetNoPrimary;\n\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions) {\n  for (const addr of serverDescriptions.keys()) {\n    if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {\n      return TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nmodule.exports = {\n  TopologyDescription\n};\n"]},"metadata":{},"sourceType":"script"}