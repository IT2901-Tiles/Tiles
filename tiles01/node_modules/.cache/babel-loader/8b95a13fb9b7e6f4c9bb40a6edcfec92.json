{"ast":null,"code":"'use strict';\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst Code = require('../core').BSON.Code;\n\nconst debugOptions = require('../utils').debugOptions;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst MongoError = require('../core').MongoError;\n\nconst parseIndexOptions = require('../utils').parseIndexOptions;\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst toError = require('../utils').toError;\n\nconst CONSTANTS = require('../constants');\n\nconst MongoDBNamespace = require('../utils').MongoDBNamespace;\n\nconst debugFields = ['authSource', 'w', 'wtimeout', 'j', 'native_parser', 'forceServerObjectId', 'serializeFunctions', 'raw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bufferMaxEntries', 'numberOfRetries', 'retryMiliSeconds', 'readPreference', 'pkFactory', 'parentDb', 'promiseLibrary', 'noListener'];\n/**\n * Creates an index on the db and collection.\n * @method\n * @param {Db} db The Db instance on which to create an index.\n * @param {string} name Name of the collection to create the index on.\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\n\nfunction createIndex(db, name, fieldOrSpec, options, callback) {\n  // Get the write concern options\n  let finalOptions = Object.assign({}, {\n    readPreference: ReadPreference.PRIMARY\n  }, options);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db\n  }, options); // Ensure we have a callback\n\n  if (finalOptions.writeConcern && typeof callback !== 'function') {\n    throw MongoError.create({\n      message: 'Cannot use a writeConcern without a provided callback',\n      driver: true\n    });\n  } // Did the user destroy the topology\n\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Attempt to run using createIndexes command\n\n  createIndexUsingCreateIndexes(db, name, fieldOrSpec, finalOptions, (err, result) => {\n    if (err == null) return handleCallback(callback, err, result);\n    /**\n     * The following errors mean that the server recognized `createIndex` as a command so we don't need to fallback to an insert:\n     * 67 = 'CannotCreateIndex' (malformed index options)\n     * 85 = 'IndexOptionsConflict' (index already exists with different options)\n     * 86 = 'IndexKeySpecsConflict' (index already exists with the same name)\n     * 11000 = 'DuplicateKey' (couldn't build unique index because of dupes)\n     * 11600 = 'InterruptedAtShutdown' (interrupted at shutdown)\n     * 197 = 'InvalidIndexSpecificationOption' (`_id` with `background: true`)\n     */\n\n    if (err.code === 67 || err.code === 11000 || err.code === 85 || err.code === 86 || err.code === 11600 || err.code === 197) {\n      return handleCallback(callback, err, result);\n    } // Create command\n\n\n    const doc = createCreateIndexCommand(db, name, fieldOrSpec, options); // Set no key checking\n\n    finalOptions.checkKeys = false; // Insert document\n\n    db.s.topology.insert(db.s.namespace.withCollection(CONSTANTS.SYSTEM_INDEX_COLLECTION), doc, finalOptions, (err, result) => {\n      if (callback == null) return;\n      if (err) return handleCallback(callback, err);\n      if (result == null) return handleCallback(callback, null, null);\n      if (result.result.writeErrors) return handleCallback(callback, MongoError.create(result.result.writeErrors[0]), null);\n      handleCallback(callback, null, doc.name);\n    });\n  });\n} // Add listeners to topology\n\n\nfunction createListener(db, e, object) {\n  function listener(err) {\n    if (object.listeners(e).length > 0) {\n      object.emit(e, err, db); // Emit on all associated db's if available\n\n      for (let i = 0; i < db.s.children.length; i++) {\n        db.s.children[i].emit(e, err, db.s.children[i]);\n      }\n    }\n  }\n\n  return listener;\n}\n/**\n * Ensures that an index exists. If it does not, creates it.\n *\n * @method\n * @param {Db} db The Db instance on which to ensure the index.\n * @param {string} name The index name\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings. See Db.prototype.ensureIndex for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\n\n\nfunction ensureIndex(db, name, fieldOrSpec, options, callback) {\n  // Get the write concern options\n  const finalOptions = applyWriteConcern({}, {\n    db\n  }, options); // Create command\n\n  const selector = createCreateIndexCommand(db, name, fieldOrSpec, options);\n  const index_name = selector.name; // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Merge primary readPreference\n\n  finalOptions.readPreference = ReadPreference.PRIMARY; // Check if the index already exists\n\n  indexInformation(db, name, finalOptions, (err, indexInformation) => {\n    if (err != null && err.code !== 26) return handleCallback(callback, err, null); // If the index does not exist, create it\n\n    if (indexInformation == null || !indexInformation[index_name]) {\n      createIndex(db, name, fieldOrSpec, options, callback);\n    } else {\n      if (typeof callback === 'function') return handleCallback(callback, null, index_name);\n    }\n  });\n}\n/**\n * Evaluate JavaScript on the server\n *\n * @method\n * @param {Db} db The Db instance.\n * @param {Code} code JavaScript to execute on server.\n * @param {(object|array)} parameters The parameters for the call.\n * @param {object} [options] Optional settings. See Db.prototype.eval for a list of options.\n * @param {Db~resultCallback} [callback] The results callback\n * @deprecated Eval is deprecated on MongoDB 3.2 and forward\n */\n\n\nfunction evaluate(db, code, parameters, options, callback) {\n  let finalCode = code;\n  let finalParameters = []; // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // If not a code object translate to one\n\n  if (!(finalCode && finalCode._bsontype === 'Code')) finalCode = new Code(finalCode); // Ensure the parameters are correct\n\n  if (parameters != null && !Array.isArray(parameters) && typeof parameters !== 'function') {\n    finalParameters = [parameters];\n  } else if (parameters != null && Array.isArray(parameters) && typeof parameters !== 'function') {\n    finalParameters = parameters;\n  } // Create execution selector\n\n\n  let cmd = {\n    $eval: finalCode,\n    args: finalParameters\n  }; // Check if the nolock parameter is passed in\n\n  if (options['nolock']) {\n    cmd['nolock'] = options['nolock'];\n  } // Set primary read preference\n\n\n  options.readPreference = new ReadPreference(ReadPreference.PRIMARY); // Execute the command\n\n  executeCommand(db, cmd, options, (err, result) => {\n    if (err) return handleCallback(callback, err, null);\n    if (result && result.ok === 1) return handleCallback(callback, null, result.retval);\n    if (result) return handleCallback(callback, MongoError.create({\n      message: `eval failed: ${result.errmsg}`,\n      driver: true\n    }), null);\n    handleCallback(callback, err, result);\n  });\n}\n/**\n * Execute a command\n *\n * @method\n * @param {Db} db The Db instance on which to execute the command.\n * @param {object} command The command hash\n * @param {object} [options] Optional settings. See Db.prototype.command for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\n\n\nfunction executeCommand(db, command, options, callback) {\n  // Did the user destroy the topology\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Get the db name we are executing against\n\n  const dbName = options.dbName || options.authdb || db.databaseName; // Convert the readPreference if its not a write\n\n  options.readPreference = ReadPreference.resolve(db, options); // Debug information\n\n  if (db.s.logger.isDebug()) db.s.logger.debug(`executing command ${JSON.stringify(command)} against ${dbName}.$cmd with options [${JSON.stringify(debugOptions(debugFields, options))}]`); // Execute command\n\n  db.s.topology.command(db.s.namespace.withCollection('$cmd'), command, options, (err, result) => {\n    if (err) return handleCallback(callback, err);\n    if (options.full) return handleCallback(callback, null, result);\n    handleCallback(callback, null, result.result);\n  });\n}\n/**\n * Runs a command on the database as admin.\n *\n * @method\n * @param {Db} db The Db instance on which to execute the command.\n * @param {object} command The command hash\n * @param {object} [options] Optional settings. See Db.prototype.executeDbAdminCommand for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\n\n\nfunction executeDbAdminCommand(db, command, options, callback) {\n  const namespace = new MongoDBNamespace('admin', '$cmd');\n  db.s.topology.command(namespace, command, options, (err, result) => {\n    // Did the user destroy the topology\n    if (db.serverConfig && db.serverConfig.isDestroyed()) {\n      return callback(new MongoError('topology was destroyed'));\n    }\n\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, result.result);\n  });\n}\n/**\n * Retrieves this collections index info.\n *\n * @method\n * @param {Db} db The Db instance on which to retrieve the index info.\n * @param {string} name The name of the collection.\n * @param {object} [options] Optional settings. See Db.prototype.indexInformation for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\n\n\nfunction indexInformation(db, name, options, callback) {\n  // If we specified full information\n  const full = options['full'] == null ? false : options['full']; // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Process all the results from the index command and collection\n\n  function processResults(indexes) {\n    // Contains all the information\n    let info = {}; // Process all the indexes\n\n    for (let i = 0; i < indexes.length; i++) {\n      const index = indexes[i]; // Let's unpack the object\n\n      info[index.name] = [];\n\n      for (let name in index.key) {\n        info[index.name].push([name, index.key[name]]);\n      }\n    }\n\n    return info;\n  } // Get the list of indexes of the specified collection\n\n\n  db.collection(name).listIndexes(options).toArray((err, indexes) => {\n    if (err) return callback(toError(err));\n    if (!Array.isArray(indexes)) return handleCallback(callback, null, []);\n    if (full) return handleCallback(callback, null, indexes);\n    handleCallback(callback, null, processResults(indexes));\n  });\n}\n/**\n * Retrieve the current profiling information for MongoDB\n *\n * @method\n * @param {Db} db The Db instance on which to retrieve the profiling info.\n * @param {Object} [options] Optional settings. See Db.protoype.profilingInfo for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback.\n * @deprecated Query the system.profile collection directly.\n */\n\n\nfunction profilingInfo(db, options, callback) {\n  try {\n    db.collection('system.profile').find({}, options).toArray(callback);\n  } catch (err) {\n    return callback(err, null);\n  }\n} // Validate the database name\n\n\nfunction validateDatabaseName(databaseName) {\n  if (typeof databaseName !== 'string') throw MongoError.create({\n    message: 'database name must be a string',\n    driver: true\n  });\n  if (databaseName.length === 0) throw MongoError.create({\n    message: 'database name cannot be the empty string',\n    driver: true\n  });\n  if (databaseName === '$external') return;\n  const invalidChars = [' ', '.', '$', '/', '\\\\'];\n\n  for (let i = 0; i < invalidChars.length; i++) {\n    if (databaseName.indexOf(invalidChars[i]) !== -1) throw MongoError.create({\n      message: \"database names cannot contain the character '\" + invalidChars[i] + \"'\",\n      driver: true\n    });\n  }\n}\n/**\n * Create the command object for Db.prototype.createIndex.\n *\n * @param {Db} db The Db instance on which to create the command.\n * @param {string} name Name of the collection to create the index on.\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {Object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\n * @return {Object} The insert command object.\n */\n\n\nfunction createCreateIndexCommand(db, name, fieldOrSpec, options) {\n  const indexParameters = parseIndexOptions(fieldOrSpec);\n  const fieldHash = indexParameters.fieldHash; // Generate the index name\n\n  const indexName = typeof options.name === 'string' ? options.name : indexParameters.name;\n  const selector = {\n    ns: db.s.namespace.withCollection(name).toString(),\n    key: fieldHash,\n    name: indexName\n  }; // Ensure we have a correct finalUnique\n\n  const finalUnique = options == null || 'object' === typeof options ? false : options; // Set up options\n\n  options = options == null || typeof options === 'boolean' ? {} : options; // Add all the options\n\n  const keysToOmit = Object.keys(selector);\n\n  for (let optionName in options) {\n    if (keysToOmit.indexOf(optionName) === -1) {\n      selector[optionName] = options[optionName];\n    }\n  }\n\n  if (selector['unique'] == null) selector['unique'] = finalUnique; // Remove any write concern operations\n\n  const removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference', 'session'];\n\n  for (let i = 0; i < removeKeys.length; i++) {\n    delete selector[removeKeys[i]];\n  } // Return the command creation selector\n\n\n  return selector;\n}\n/**\n * Create index using the createIndexes command.\n *\n * @param {Db} db The Db instance on which to execute the command.\n * @param {string} name Name of the collection to create the index on.\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {Object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback.\n */\n\n\nfunction createIndexUsingCreateIndexes(db, name, fieldOrSpec, options, callback) {\n  // Build the index\n  const indexParameters = parseIndexOptions(fieldOrSpec); // Generate the index name\n\n  const indexName = typeof options.name === 'string' ? options.name : indexParameters.name; // Set up the index\n\n  const indexes = [{\n    name: indexName,\n    key: indexParameters.fieldHash\n  }]; // merge all the options\n\n  const keysToOmit = Object.keys(indexes[0]).concat(['writeConcern', 'w', 'wtimeout', 'j', 'fsync', 'readPreference', 'session']);\n\n  for (let optionName in options) {\n    if (keysToOmit.indexOf(optionName) === -1) {\n      indexes[0][optionName] = options[optionName];\n    }\n  } // Get capabilities\n\n\n  const capabilities = db.s.topology.capabilities(); // Did the user pass in a collation, check if our write server supports it\n\n  if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) {\n    // Create a new error\n    const error = new MongoError('server/primary/mongos does not support collation');\n    error.code = 67; // Return the error\n\n    return callback(error);\n  } // Create command, apply write concern to command\n\n\n  const cmd = applyWriteConcern({\n    createIndexes: name,\n    indexes\n  }, {\n    db\n  }, options); // ReadPreference primary\n\n  options.readPreference = ReadPreference.PRIMARY; // Build the command\n\n  executeCommand(db, cmd, options, (err, result) => {\n    if (err) return handleCallback(callback, err, null);\n    if (result.ok === 0) return handleCallback(callback, toError(result), null); // Return the indexName for backward compatibility\n\n    handleCallback(callback, null, indexName);\n  });\n}\n\nmodule.exports = {\n  createListener,\n  createIndex,\n  ensureIndex,\n  evaluate,\n  executeCommand,\n  executeDbAdminCommand,\n  indexInformation,\n  profilingInfo,\n  validateDatabaseName\n};","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/operations/db_ops.js"],"names":["applyWriteConcern","require","Code","BSON","debugOptions","handleCallback","MongoError","parseIndexOptions","ReadPreference","toError","CONSTANTS","MongoDBNamespace","debugFields","createIndex","db","name","fieldOrSpec","options","callback","finalOptions","Object","assign","readPreference","PRIMARY","writeConcern","create","message","driver","serverConfig","isDestroyed","createIndexUsingCreateIndexes","err","result","code","doc","createCreateIndexCommand","checkKeys","s","topology","insert","namespace","withCollection","SYSTEM_INDEX_COLLECTION","writeErrors","createListener","e","object","listener","listeners","length","emit","i","children","ensureIndex","selector","index_name","indexInformation","evaluate","parameters","finalCode","finalParameters","_bsontype","Array","isArray","cmd","$eval","args","executeCommand","ok","retval","errmsg","command","dbName","authdb","databaseName","resolve","logger","isDebug","debug","JSON","stringify","full","executeDbAdminCommand","processResults","indexes","info","index","key","push","collection","listIndexes","toArray","profilingInfo","find","validateDatabaseName","invalidChars","indexOf","indexParameters","fieldHash","indexName","ns","toString","finalUnique","keysToOmit","keys","optionName","removeKeys","concat","capabilities","collation","commandsTakeCollation","error","createIndexes","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\nconst Code = require('../core').BSON.Code;\nconst debugOptions = require('../utils').debugOptions;\nconst handleCallback = require('../utils').handleCallback;\nconst MongoError = require('../core').MongoError;\nconst parseIndexOptions = require('../utils').parseIndexOptions;\nconst ReadPreference = require('../core').ReadPreference;\nconst toError = require('../utils').toError;\nconst CONSTANTS = require('../constants');\nconst MongoDBNamespace = require('../utils').MongoDBNamespace;\n\nconst debugFields = [\n  'authSource',\n  'w',\n  'wtimeout',\n  'j',\n  'native_parser',\n  'forceServerObjectId',\n  'serializeFunctions',\n  'raw',\n  'promoteLongs',\n  'promoteValues',\n  'promoteBuffers',\n  'bufferMaxEntries',\n  'numberOfRetries',\n  'retryMiliSeconds',\n  'readPreference',\n  'pkFactory',\n  'parentDb',\n  'promiseLibrary',\n  'noListener'\n];\n\n/**\n * Creates an index on the db and collection.\n * @method\n * @param {Db} db The Db instance on which to create an index.\n * @param {string} name Name of the collection to create the index on.\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\nfunction createIndex(db, name, fieldOrSpec, options, callback) {\n  // Get the write concern options\n  let finalOptions = Object.assign({}, { readPreference: ReadPreference.PRIMARY }, options);\n  finalOptions = applyWriteConcern(finalOptions, { db }, options);\n\n  // Ensure we have a callback\n  if (finalOptions.writeConcern && typeof callback !== 'function') {\n    throw MongoError.create({\n      message: 'Cannot use a writeConcern without a provided callback',\n      driver: true\n    });\n  }\n\n  // Did the user destroy the topology\n  if (db.serverConfig && db.serverConfig.isDestroyed())\n    return callback(new MongoError('topology was destroyed'));\n\n  // Attempt to run using createIndexes command\n  createIndexUsingCreateIndexes(db, name, fieldOrSpec, finalOptions, (err, result) => {\n    if (err == null) return handleCallback(callback, err, result);\n\n    /**\n     * The following errors mean that the server recognized `createIndex` as a command so we don't need to fallback to an insert:\n     * 67 = 'CannotCreateIndex' (malformed index options)\n     * 85 = 'IndexOptionsConflict' (index already exists with different options)\n     * 86 = 'IndexKeySpecsConflict' (index already exists with the same name)\n     * 11000 = 'DuplicateKey' (couldn't build unique index because of dupes)\n     * 11600 = 'InterruptedAtShutdown' (interrupted at shutdown)\n     * 197 = 'InvalidIndexSpecificationOption' (`_id` with `background: true`)\n     */\n    if (\n      err.code === 67 ||\n      err.code === 11000 ||\n      err.code === 85 ||\n      err.code === 86 ||\n      err.code === 11600 ||\n      err.code === 197\n    ) {\n      return handleCallback(callback, err, result);\n    }\n\n    // Create command\n    const doc = createCreateIndexCommand(db, name, fieldOrSpec, options);\n    // Set no key checking\n    finalOptions.checkKeys = false;\n    // Insert document\n    db.s.topology.insert(\n      db.s.namespace.withCollection(CONSTANTS.SYSTEM_INDEX_COLLECTION),\n      doc,\n      finalOptions,\n      (err, result) => {\n        if (callback == null) return;\n        if (err) return handleCallback(callback, err);\n        if (result == null) return handleCallback(callback, null, null);\n        if (result.result.writeErrors)\n          return handleCallback(callback, MongoError.create(result.result.writeErrors[0]), null);\n        handleCallback(callback, null, doc.name);\n      }\n    );\n  });\n}\n\n// Add listeners to topology\nfunction createListener(db, e, object) {\n  function listener(err) {\n    if (object.listeners(e).length > 0) {\n      object.emit(e, err, db);\n\n      // Emit on all associated db's if available\n      for (let i = 0; i < db.s.children.length; i++) {\n        db.s.children[i].emit(e, err, db.s.children[i]);\n      }\n    }\n  }\n  return listener;\n}\n\n/**\n * Ensures that an index exists. If it does not, creates it.\n *\n * @method\n * @param {Db} db The Db instance on which to ensure the index.\n * @param {string} name The index name\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings. See Db.prototype.ensureIndex for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\nfunction ensureIndex(db, name, fieldOrSpec, options, callback) {\n  // Get the write concern options\n  const finalOptions = applyWriteConcern({}, { db }, options);\n  // Create command\n  const selector = createCreateIndexCommand(db, name, fieldOrSpec, options);\n  const index_name = selector.name;\n\n  // Did the user destroy the topology\n  if (db.serverConfig && db.serverConfig.isDestroyed())\n    return callback(new MongoError('topology was destroyed'));\n\n  // Merge primary readPreference\n  finalOptions.readPreference = ReadPreference.PRIMARY;\n\n  // Check if the index already exists\n  indexInformation(db, name, finalOptions, (err, indexInformation) => {\n    if (err != null && err.code !== 26) return handleCallback(callback, err, null);\n    // If the index does not exist, create it\n    if (indexInformation == null || !indexInformation[index_name]) {\n      createIndex(db, name, fieldOrSpec, options, callback);\n    } else {\n      if (typeof callback === 'function') return handleCallback(callback, null, index_name);\n    }\n  });\n}\n\n/**\n * Evaluate JavaScript on the server\n *\n * @method\n * @param {Db} db The Db instance.\n * @param {Code} code JavaScript to execute on server.\n * @param {(object|array)} parameters The parameters for the call.\n * @param {object} [options] Optional settings. See Db.prototype.eval for a list of options.\n * @param {Db~resultCallback} [callback] The results callback\n * @deprecated Eval is deprecated on MongoDB 3.2 and forward\n */\nfunction evaluate(db, code, parameters, options, callback) {\n  let finalCode = code;\n  let finalParameters = [];\n\n  // Did the user destroy the topology\n  if (db.serverConfig && db.serverConfig.isDestroyed())\n    return callback(new MongoError('topology was destroyed'));\n\n  // If not a code object translate to one\n  if (!(finalCode && finalCode._bsontype === 'Code')) finalCode = new Code(finalCode);\n  // Ensure the parameters are correct\n  if (parameters != null && !Array.isArray(parameters) && typeof parameters !== 'function') {\n    finalParameters = [parameters];\n  } else if (parameters != null && Array.isArray(parameters) && typeof parameters !== 'function') {\n    finalParameters = parameters;\n  }\n\n  // Create execution selector\n  let cmd = { $eval: finalCode, args: finalParameters };\n  // Check if the nolock parameter is passed in\n  if (options['nolock']) {\n    cmd['nolock'] = options['nolock'];\n  }\n\n  // Set primary read preference\n  options.readPreference = new ReadPreference(ReadPreference.PRIMARY);\n\n  // Execute the command\n  executeCommand(db, cmd, options, (err, result) => {\n    if (err) return handleCallback(callback, err, null);\n    if (result && result.ok === 1) return handleCallback(callback, null, result.retval);\n    if (result)\n      return handleCallback(\n        callback,\n        MongoError.create({ message: `eval failed: ${result.errmsg}`, driver: true }),\n        null\n      );\n    handleCallback(callback, err, result);\n  });\n}\n\n/**\n * Execute a command\n *\n * @method\n * @param {Db} db The Db instance on which to execute the command.\n * @param {object} command The command hash\n * @param {object} [options] Optional settings. See Db.prototype.command for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\nfunction executeCommand(db, command, options, callback) {\n  // Did the user destroy the topology\n  if (db.serverConfig && db.serverConfig.isDestroyed())\n    return callback(new MongoError('topology was destroyed'));\n  // Get the db name we are executing against\n  const dbName = options.dbName || options.authdb || db.databaseName;\n\n  // Convert the readPreference if its not a write\n  options.readPreference = ReadPreference.resolve(db, options);\n\n  // Debug information\n  if (db.s.logger.isDebug())\n    db.s.logger.debug(\n      `executing command ${JSON.stringify(\n        command\n      )} against ${dbName}.$cmd with options [${JSON.stringify(\n        debugOptions(debugFields, options)\n      )}]`\n    );\n\n  // Execute command\n  db.s.topology.command(db.s.namespace.withCollection('$cmd'), command, options, (err, result) => {\n    if (err) return handleCallback(callback, err);\n    if (options.full) return handleCallback(callback, null, result);\n    handleCallback(callback, null, result.result);\n  });\n}\n\n/**\n * Runs a command on the database as admin.\n *\n * @method\n * @param {Db} db The Db instance on which to execute the command.\n * @param {object} command The command hash\n * @param {object} [options] Optional settings. See Db.prototype.executeDbAdminCommand for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\nfunction executeDbAdminCommand(db, command, options, callback) {\n  const namespace = new MongoDBNamespace('admin', '$cmd');\n\n  db.s.topology.command(namespace, command, options, (err, result) => {\n    // Did the user destroy the topology\n    if (db.serverConfig && db.serverConfig.isDestroyed()) {\n      return callback(new MongoError('topology was destroyed'));\n    }\n\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, result.result);\n  });\n}\n\n/**\n * Retrieves this collections index info.\n *\n * @method\n * @param {Db} db The Db instance on which to retrieve the index info.\n * @param {string} name The name of the collection.\n * @param {object} [options] Optional settings. See Db.prototype.indexInformation for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\nfunction indexInformation(db, name, options, callback) {\n  // If we specified full information\n  const full = options['full'] == null ? false : options['full'];\n\n  // Did the user destroy the topology\n  if (db.serverConfig && db.serverConfig.isDestroyed())\n    return callback(new MongoError('topology was destroyed'));\n  // Process all the results from the index command and collection\n  function processResults(indexes) {\n    // Contains all the information\n    let info = {};\n    // Process all the indexes\n    for (let i = 0; i < indexes.length; i++) {\n      const index = indexes[i];\n      // Let's unpack the object\n      info[index.name] = [];\n      for (let name in index.key) {\n        info[index.name].push([name, index.key[name]]);\n      }\n    }\n\n    return info;\n  }\n\n  // Get the list of indexes of the specified collection\n  db.collection(name)\n    .listIndexes(options)\n    .toArray((err, indexes) => {\n      if (err) return callback(toError(err));\n      if (!Array.isArray(indexes)) return handleCallback(callback, null, []);\n      if (full) return handleCallback(callback, null, indexes);\n      handleCallback(callback, null, processResults(indexes));\n    });\n}\n\n/**\n * Retrieve the current profiling information for MongoDB\n *\n * @method\n * @param {Db} db The Db instance on which to retrieve the profiling info.\n * @param {Object} [options] Optional settings. See Db.protoype.profilingInfo for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback.\n * @deprecated Query the system.profile collection directly.\n */\nfunction profilingInfo(db, options, callback) {\n  try {\n    db.collection('system.profile')\n      .find({}, options)\n      .toArray(callback);\n  } catch (err) {\n    return callback(err, null);\n  }\n}\n\n// Validate the database name\nfunction validateDatabaseName(databaseName) {\n  if (typeof databaseName !== 'string')\n    throw MongoError.create({ message: 'database name must be a string', driver: true });\n  if (databaseName.length === 0)\n    throw MongoError.create({ message: 'database name cannot be the empty string', driver: true });\n  if (databaseName === '$external') return;\n\n  const invalidChars = [' ', '.', '$', '/', '\\\\'];\n  for (let i = 0; i < invalidChars.length; i++) {\n    if (databaseName.indexOf(invalidChars[i]) !== -1)\n      throw MongoError.create({\n        message: \"database names cannot contain the character '\" + invalidChars[i] + \"'\",\n        driver: true\n      });\n  }\n}\n\n/**\n * Create the command object for Db.prototype.createIndex.\n *\n * @param {Db} db The Db instance on which to create the command.\n * @param {string} name Name of the collection to create the index on.\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {Object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\n * @return {Object} The insert command object.\n */\nfunction createCreateIndexCommand(db, name, fieldOrSpec, options) {\n  const indexParameters = parseIndexOptions(fieldOrSpec);\n  const fieldHash = indexParameters.fieldHash;\n\n  // Generate the index name\n  const indexName = typeof options.name === 'string' ? options.name : indexParameters.name;\n  const selector = {\n    ns: db.s.namespace.withCollection(name).toString(),\n    key: fieldHash,\n    name: indexName\n  };\n\n  // Ensure we have a correct finalUnique\n  const finalUnique = options == null || 'object' === typeof options ? false : options;\n  // Set up options\n  options = options == null || typeof options === 'boolean' ? {} : options;\n\n  // Add all the options\n  const keysToOmit = Object.keys(selector);\n  for (let optionName in options) {\n    if (keysToOmit.indexOf(optionName) === -1) {\n      selector[optionName] = options[optionName];\n    }\n  }\n\n  if (selector['unique'] == null) selector['unique'] = finalUnique;\n\n  // Remove any write concern operations\n  const removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference', 'session'];\n  for (let i = 0; i < removeKeys.length; i++) {\n    delete selector[removeKeys[i]];\n  }\n\n  // Return the command creation selector\n  return selector;\n}\n\n/**\n * Create index using the createIndexes command.\n *\n * @param {Db} db The Db instance on which to execute the command.\n * @param {string} name Name of the collection to create the index on.\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {Object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback.\n */\nfunction createIndexUsingCreateIndexes(db, name, fieldOrSpec, options, callback) {\n  // Build the index\n  const indexParameters = parseIndexOptions(fieldOrSpec);\n  // Generate the index name\n  const indexName = typeof options.name === 'string' ? options.name : indexParameters.name;\n  // Set up the index\n  const indexes = [{ name: indexName, key: indexParameters.fieldHash }];\n  // merge all the options\n  const keysToOmit = Object.keys(indexes[0]).concat([\n    'writeConcern',\n    'w',\n    'wtimeout',\n    'j',\n    'fsync',\n    'readPreference',\n    'session'\n  ]);\n\n  for (let optionName in options) {\n    if (keysToOmit.indexOf(optionName) === -1) {\n      indexes[0][optionName] = options[optionName];\n    }\n  }\n\n  // Get capabilities\n  const capabilities = db.s.topology.capabilities();\n\n  // Did the user pass in a collation, check if our write server supports it\n  if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) {\n    // Create a new error\n    const error = new MongoError('server/primary/mongos does not support collation');\n    error.code = 67;\n    // Return the error\n    return callback(error);\n  }\n\n  // Create command, apply write concern to command\n  const cmd = applyWriteConcern({ createIndexes: name, indexes }, { db }, options);\n\n  // ReadPreference primary\n  options.readPreference = ReadPreference.PRIMARY;\n\n  // Build the command\n  executeCommand(db, cmd, options, (err, result) => {\n    if (err) return handleCallback(callback, err, null);\n    if (result.ok === 0) return handleCallback(callback, toError(result), null);\n    // Return the indexName for backward compatibility\n    handleCallback(callback, null, indexName);\n  });\n}\n\nmodule.exports = {\n  createListener,\n  createIndex,\n  ensureIndex,\n  evaluate,\n  executeCommand,\n  executeDbAdminCommand,\n  indexInformation,\n  profilingInfo,\n  validateDatabaseName\n};\n"]},"metadata":{},"sourceType":"script"}