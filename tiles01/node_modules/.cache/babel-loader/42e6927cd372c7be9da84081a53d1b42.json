{"ast":null,"code":"'use strict';\n\nvar stream = require('stream'),\n    util = require('util');\n\nmodule.exports = GridFSBucketReadStream;\n/**\n * A readable stream that enables you to read buffers from GridFS.\n *\n * Do not instantiate this class directly. Use `openDownloadStream()` instead.\n *\n * @class\n * @extends external:Readable\n * @param {Collection} chunks Handle for chunks collection\n * @param {Collection} files Handle for files collection\n * @param {Object} readPreference The read preference to use\n * @param {Object} filter The query to use to find the file document\n * @param {Object} [options] Optional settings.\n * @param {Number} [options.sort] Optional sort for the file find query\n * @param {Number} [options.skip] Optional skip for the file find query\n * @param {Number} [options.start] Optional 0-based offset in bytes to start streaming from\n * @param {Number} [options.end] Optional 0-based offset in bytes to stop streaming before\n * @fires GridFSBucketReadStream#error\n * @fires GridFSBucketReadStream#file\n */\n\nfunction GridFSBucketReadStream(chunks, files, readPreference, filter, options) {\n  this.s = {\n    bytesRead: 0,\n    chunks: chunks,\n    cursor: null,\n    expected: 0,\n    files: files,\n    filter: filter,\n    init: false,\n    expectedEnd: 0,\n    file: null,\n    options: options,\n    readPreference: readPreference\n  };\n  stream.Readable.call(this);\n}\n\nutil.inherits(GridFSBucketReadStream, stream.Readable);\n/**\n * An error occurred\n *\n * @event GridFSBucketReadStream#error\n * @type {Error}\n */\n\n/**\n * Fires when the stream loaded the file document corresponding to the\n * provided id.\n *\n * @event GridFSBucketReadStream#file\n * @type {object}\n */\n\n/**\n * Emitted when a chunk of data is available to be consumed.\n *\n * @event GridFSBucketReadStream#data\n * @type {object}\n */\n\n/**\n * Fired when the stream is exhausted (no more data events).\n *\n * @event GridFSBucketReadStream#end\n * @type {object}\n */\n\n/**\n * Fired when the stream is exhausted and the underlying cursor is killed\n *\n * @event GridFSBucketReadStream#close\n * @type {object}\n */\n\n/**\n * Reads from the cursor and pushes to the stream.\n * Private Impl, do not call directly\n * @ignore\n * @method\n */\n\nGridFSBucketReadStream.prototype._read = function () {\n  var _this = this;\n\n  if (this.destroyed) {\n    return;\n  }\n\n  waitForFile(_this, function () {\n    doRead(_this);\n  });\n};\n/**\n * Sets the 0-based offset in bytes to start streaming from. Throws\n * an error if this stream has entered flowing mode\n * (e.g. if you've already called `on('data')`)\n * @method\n * @param {Number} start Offset in bytes to start reading at\n * @return {GridFSBucketReadStream} Reference to Self\n */\n\n\nGridFSBucketReadStream.prototype.start = function (start) {\n  throwIfInitialized(this);\n  this.s.options.start = start;\n  return this;\n};\n/**\n * Sets the 0-based offset in bytes to start streaming from. Throws\n * an error if this stream has entered flowing mode\n * (e.g. if you've already called `on('data')`)\n * @method\n * @param {Number} end Offset in bytes to stop reading at\n * @return {GridFSBucketReadStream} Reference to self\n */\n\n\nGridFSBucketReadStream.prototype.end = function (end) {\n  throwIfInitialized(this);\n  this.s.options.end = end;\n  return this;\n};\n/**\n * Marks this stream as aborted (will never push another `data` event)\n * and kills the underlying cursor. Will emit the 'end' event, and then\n * the 'close' event once the cursor is successfully killed.\n *\n * @method\n * @param {GridFSBucket~errorCallback} [callback] called when the cursor is successfully closed or an error occurred.\n * @fires GridFSBucketWriteStream#close\n * @fires GridFSBucketWriteStream#end\n */\n\n\nGridFSBucketReadStream.prototype.abort = function (callback) {\n  var _this = this;\n\n  this.push(null);\n  this.destroyed = true;\n\n  if (this.s.cursor) {\n    this.s.cursor.close(function (error) {\n      _this.emit('close');\n\n      callback && callback(error);\n    });\n  } else {\n    if (!this.s.init) {\n      // If not initialized, fire close event because we will never\n      // get a cursor\n      _this.emit('close');\n    }\n\n    callback && callback();\n  }\n};\n/**\n * @ignore\n */\n\n\nfunction throwIfInitialized(self) {\n  if (self.s.init) {\n    throw new Error('You cannot change options after the stream has entered' + 'flowing mode!');\n  }\n}\n/**\n * @ignore\n */\n\n\nfunction doRead(_this) {\n  if (_this.destroyed) {\n    return;\n  }\n\n  _this.s.cursor.next(function (error, doc) {\n    if (_this.destroyed) {\n      return;\n    }\n\n    if (error) {\n      return __handleError(_this, error);\n    }\n\n    if (!doc) {\n      _this.push(null);\n\n      process.nextTick(() => {\n        _this.s.cursor.close(function (error) {\n          if (error) {\n            __handleError(_this, error);\n\n            return;\n          }\n\n          _this.emit('close');\n        });\n      });\n      return;\n    }\n\n    var bytesRemaining = _this.s.file.length - _this.s.bytesRead;\n    var expectedN = _this.s.expected++;\n    var expectedLength = Math.min(_this.s.file.chunkSize, bytesRemaining);\n\n    if (doc.n > expectedN) {\n      var errmsg = 'ChunkIsMissing: Got unexpected n: ' + doc.n + ', expected: ' + expectedN;\n      return __handleError(_this, new Error(errmsg));\n    }\n\n    if (doc.n < expectedN) {\n      errmsg = 'ExtraChunk: Got unexpected n: ' + doc.n + ', expected: ' + expectedN;\n      return __handleError(_this, new Error(errmsg));\n    }\n\n    var buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;\n\n    if (buf.length !== expectedLength) {\n      if (bytesRemaining <= 0) {\n        errmsg = 'ExtraChunk: Got unexpected n: ' + doc.n;\n        return __handleError(_this, new Error(errmsg));\n      }\n\n      errmsg = 'ChunkIsWrongSize: Got unexpected length: ' + buf.length + ', expected: ' + expectedLength;\n      return __handleError(_this, new Error(errmsg));\n    }\n\n    _this.s.bytesRead += buf.length;\n\n    if (buf.length === 0) {\n      return _this.push(null);\n    }\n\n    var sliceStart = null;\n    var sliceEnd = null;\n\n    if (_this.s.bytesToSkip != null) {\n      sliceStart = _this.s.bytesToSkip;\n      _this.s.bytesToSkip = 0;\n    }\n\n    const atEndOfStream = expectedN === _this.s.expectedEnd - 1;\n    const bytesLeftToRead = _this.s.options.end - _this.s.bytesToSkip;\n\n    if (atEndOfStream && _this.s.bytesToTrim != null) {\n      sliceEnd = _this.s.file.chunkSize - _this.s.bytesToTrim;\n    } else if (_this.s.options.end && bytesLeftToRead < doc.data.length()) {\n      sliceEnd = bytesLeftToRead;\n    }\n\n    if (sliceStart != null || sliceEnd != null) {\n      buf = buf.slice(sliceStart || 0, sliceEnd || buf.length);\n    }\n\n    _this.push(buf);\n  });\n}\n/**\n * @ignore\n */\n\n\nfunction init(self) {\n  var findOneOptions = {};\n\n  if (self.s.readPreference) {\n    findOneOptions.readPreference = self.s.readPreference;\n  }\n\n  if (self.s.options && self.s.options.sort) {\n    findOneOptions.sort = self.s.options.sort;\n  }\n\n  if (self.s.options && self.s.options.skip) {\n    findOneOptions.skip = self.s.options.skip;\n  }\n\n  self.s.files.findOne(self.s.filter, findOneOptions, function (error, doc) {\n    if (error) {\n      return __handleError(self, error);\n    }\n\n    if (!doc) {\n      var identifier = self.s.filter._id ? self.s.filter._id.toString() : self.s.filter.filename;\n      var errmsg = 'FileNotFound: file ' + identifier + ' was not found';\n      var err = new Error(errmsg);\n      err.code = 'ENOENT';\n      return __handleError(self, err);\n    } // If document is empty, kill the stream immediately and don't\n    // execute any reads\n\n\n    if (doc.length <= 0) {\n      self.push(null);\n      return;\n    }\n\n    if (self.destroyed) {\n      // If user destroys the stream before we have a cursor, wait\n      // until the query is done to say we're 'closed' because we can't\n      // cancel a query.\n      self.emit('close');\n      return;\n    }\n\n    try {\n      self.s.bytesToSkip = handleStartOption(self, doc, self.s.options);\n    } catch (error) {\n      return __handleError(self, error);\n    }\n\n    var filter = {\n      files_id: doc._id\n    }; // Currently (MongoDB 3.4.4) skip function does not support the index,\n    // it needs to retrieve all the documents first and then skip them. (CS-25811)\n    // As work around we use $gte on the \"n\" field.\n\n    if (self.s.options && self.s.options.start != null) {\n      var skip = Math.floor(self.s.options.start / doc.chunkSize);\n\n      if (skip > 0) {\n        filter['n'] = {\n          $gte: skip\n        };\n      }\n    }\n\n    self.s.cursor = self.s.chunks.find(filter).sort({\n      n: 1\n    });\n\n    if (self.s.readPreference) {\n      self.s.cursor.setReadPreference(self.s.readPreference);\n    }\n\n    self.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);\n    self.s.file = doc;\n\n    try {\n      self.s.bytesToTrim = handleEndOption(self, doc, self.s.cursor, self.s.options);\n    } catch (error) {\n      return __handleError(self, error);\n    }\n\n    self.emit('file', doc);\n  });\n}\n/**\n * @ignore\n */\n\n\nfunction waitForFile(_this, callback) {\n  if (_this.s.file) {\n    return callback();\n  }\n\n  if (!_this.s.init) {\n    init(_this);\n    _this.s.init = true;\n  }\n\n  _this.once('file', function () {\n    callback();\n  });\n}\n/**\n * @ignore\n */\n\n\nfunction handleStartOption(stream, doc, options) {\n  if (options && options.start != null) {\n    if (options.start > doc.length) {\n      throw new Error('Stream start (' + options.start + ') must not be ' + 'more than the length of the file (' + doc.length + ')');\n    }\n\n    if (options.start < 0) {\n      throw new Error('Stream start (' + options.start + ') must not be ' + 'negative');\n    }\n\n    if (options.end != null && options.end < options.start) {\n      throw new Error('Stream start (' + options.start + ') must not be ' + 'greater than stream end (' + options.end + ')');\n    }\n\n    stream.s.bytesRead = Math.floor(options.start / doc.chunkSize) * doc.chunkSize;\n    stream.s.expected = Math.floor(options.start / doc.chunkSize);\n    return options.start - stream.s.bytesRead;\n  }\n}\n/**\n * @ignore\n */\n\n\nfunction handleEndOption(stream, doc, cursor, options) {\n  if (options && options.end != null) {\n    if (options.end > doc.length) {\n      throw new Error('Stream end (' + options.end + ') must not be ' + 'more than the length of the file (' + doc.length + ')');\n    }\n\n    if (options.start < 0) {\n      throw new Error('Stream end (' + options.end + ') must not be ' + 'negative');\n    }\n\n    var start = options.start != null ? Math.floor(options.start / doc.chunkSize) : 0;\n    cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);\n    stream.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);\n    return Math.ceil(options.end / doc.chunkSize) * doc.chunkSize - options.end;\n  }\n}\n/**\n * @ignore\n */\n\n\nfunction __handleError(_this, error) {\n  _this.emit('error', error);\n}","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/gridfs-stream/download.js"],"names":["stream","require","util","module","exports","GridFSBucketReadStream","chunks","files","readPreference","filter","options","s","bytesRead","cursor","expected","init","expectedEnd","file","Readable","call","inherits","prototype","_read","_this","destroyed","waitForFile","doRead","start","throwIfInitialized","end","abort","callback","push","close","error","emit","self","Error","next","doc","__handleError","process","nextTick","bytesRemaining","length","expectedN","expectedLength","Math","min","chunkSize","n","errmsg","buf","Buffer","isBuffer","data","buffer","sliceStart","sliceEnd","bytesToSkip","atEndOfStream","bytesLeftToRead","bytesToTrim","slice","findOneOptions","sort","skip","findOne","identifier","_id","toString","filename","err","code","handleStartOption","files_id","floor","$gte","find","setReadPreference","ceil","handleEndOption","once","limit"],"mappings":"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","sourcesContent":["'use strict';\n\nvar stream = require('stream'),\n  util = require('util');\n\nmodule.exports = GridFSBucketReadStream;\n\n/**\n * A readable stream that enables you to read buffers from GridFS.\n *\n * Do not instantiate this class directly. Use `openDownloadStream()` instead.\n *\n * @class\n * @extends external:Readable\n * @param {Collection} chunks Handle for chunks collection\n * @param {Collection} files Handle for files collection\n * @param {Object} readPreference The read preference to use\n * @param {Object} filter The query to use to find the file document\n * @param {Object} [options] Optional settings.\n * @param {Number} [options.sort] Optional sort for the file find query\n * @param {Number} [options.skip] Optional skip for the file find query\n * @param {Number} [options.start] Optional 0-based offset in bytes to start streaming from\n * @param {Number} [options.end] Optional 0-based offset in bytes to stop streaming before\n * @fires GridFSBucketReadStream#error\n * @fires GridFSBucketReadStream#file\n */\nfunction GridFSBucketReadStream(chunks, files, readPreference, filter, options) {\n  this.s = {\n    bytesRead: 0,\n    chunks: chunks,\n    cursor: null,\n    expected: 0,\n    files: files,\n    filter: filter,\n    init: false,\n    expectedEnd: 0,\n    file: null,\n    options: options,\n    readPreference: readPreference\n  };\n\n  stream.Readable.call(this);\n}\n\nutil.inherits(GridFSBucketReadStream, stream.Readable);\n\n/**\n * An error occurred\n *\n * @event GridFSBucketReadStream#error\n * @type {Error}\n */\n\n/**\n * Fires when the stream loaded the file document corresponding to the\n * provided id.\n *\n * @event GridFSBucketReadStream#file\n * @type {object}\n */\n\n/**\n * Emitted when a chunk of data is available to be consumed.\n *\n * @event GridFSBucketReadStream#data\n * @type {object}\n */\n\n/**\n * Fired when the stream is exhausted (no more data events).\n *\n * @event GridFSBucketReadStream#end\n * @type {object}\n */\n\n/**\n * Fired when the stream is exhausted and the underlying cursor is killed\n *\n * @event GridFSBucketReadStream#close\n * @type {object}\n */\n\n/**\n * Reads from the cursor and pushes to the stream.\n * Private Impl, do not call directly\n * @ignore\n * @method\n */\n\nGridFSBucketReadStream.prototype._read = function() {\n  var _this = this;\n  if (this.destroyed) {\n    return;\n  }\n\n  waitForFile(_this, function() {\n    doRead(_this);\n  });\n};\n\n/**\n * Sets the 0-based offset in bytes to start streaming from. Throws\n * an error if this stream has entered flowing mode\n * (e.g. if you've already called `on('data')`)\n * @method\n * @param {Number} start Offset in bytes to start reading at\n * @return {GridFSBucketReadStream} Reference to Self\n */\n\nGridFSBucketReadStream.prototype.start = function(start) {\n  throwIfInitialized(this);\n  this.s.options.start = start;\n  return this;\n};\n\n/**\n * Sets the 0-based offset in bytes to start streaming from. Throws\n * an error if this stream has entered flowing mode\n * (e.g. if you've already called `on('data')`)\n * @method\n * @param {Number} end Offset in bytes to stop reading at\n * @return {GridFSBucketReadStream} Reference to self\n */\n\nGridFSBucketReadStream.prototype.end = function(end) {\n  throwIfInitialized(this);\n  this.s.options.end = end;\n  return this;\n};\n\n/**\n * Marks this stream as aborted (will never push another `data` event)\n * and kills the underlying cursor. Will emit the 'end' event, and then\n * the 'close' event once the cursor is successfully killed.\n *\n * @method\n * @param {GridFSBucket~errorCallback} [callback] called when the cursor is successfully closed or an error occurred.\n * @fires GridFSBucketWriteStream#close\n * @fires GridFSBucketWriteStream#end\n */\n\nGridFSBucketReadStream.prototype.abort = function(callback) {\n  var _this = this;\n  this.push(null);\n  this.destroyed = true;\n  if (this.s.cursor) {\n    this.s.cursor.close(function(error) {\n      _this.emit('close');\n      callback && callback(error);\n    });\n  } else {\n    if (!this.s.init) {\n      // If not initialized, fire close event because we will never\n      // get a cursor\n      _this.emit('close');\n    }\n    callback && callback();\n  }\n};\n\n/**\n * @ignore\n */\n\nfunction throwIfInitialized(self) {\n  if (self.s.init) {\n    throw new Error('You cannot change options after the stream has entered' + 'flowing mode!');\n  }\n}\n\n/**\n * @ignore\n */\n\nfunction doRead(_this) {\n  if (_this.destroyed) {\n    return;\n  }\n\n  _this.s.cursor.next(function(error, doc) {\n    if (_this.destroyed) {\n      return;\n    }\n    if (error) {\n      return __handleError(_this, error);\n    }\n    if (!doc) {\n      _this.push(null);\n\n      process.nextTick(() => {\n        _this.s.cursor.close(function(error) {\n          if (error) {\n            __handleError(_this, error);\n            return;\n          }\n\n          _this.emit('close');\n        });\n      });\n\n      return;\n    }\n\n    var bytesRemaining = _this.s.file.length - _this.s.bytesRead;\n    var expectedN = _this.s.expected++;\n    var expectedLength = Math.min(_this.s.file.chunkSize, bytesRemaining);\n\n    if (doc.n > expectedN) {\n      var errmsg = 'ChunkIsMissing: Got unexpected n: ' + doc.n + ', expected: ' + expectedN;\n      return __handleError(_this, new Error(errmsg));\n    }\n\n    if (doc.n < expectedN) {\n      errmsg = 'ExtraChunk: Got unexpected n: ' + doc.n + ', expected: ' + expectedN;\n      return __handleError(_this, new Error(errmsg));\n    }\n\n    var buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;\n\n    if (buf.length !== expectedLength) {\n      if (bytesRemaining <= 0) {\n        errmsg = 'ExtraChunk: Got unexpected n: ' + doc.n;\n        return __handleError(_this, new Error(errmsg));\n      }\n\n      errmsg =\n        'ChunkIsWrongSize: Got unexpected length: ' + buf.length + ', expected: ' + expectedLength;\n      return __handleError(_this, new Error(errmsg));\n    }\n\n    _this.s.bytesRead += buf.length;\n\n    if (buf.length === 0) {\n      return _this.push(null);\n    }\n\n    var sliceStart = null;\n    var sliceEnd = null;\n\n    if (_this.s.bytesToSkip != null) {\n      sliceStart = _this.s.bytesToSkip;\n      _this.s.bytesToSkip = 0;\n    }\n\n    const atEndOfStream = expectedN === _this.s.expectedEnd - 1;\n    const bytesLeftToRead = _this.s.options.end - _this.s.bytesToSkip;\n    if (atEndOfStream && _this.s.bytesToTrim != null) {\n      sliceEnd = _this.s.file.chunkSize - _this.s.bytesToTrim;\n    } else if (_this.s.options.end && bytesLeftToRead < doc.data.length()) {\n      sliceEnd = bytesLeftToRead;\n    }\n\n    if (sliceStart != null || sliceEnd != null) {\n      buf = buf.slice(sliceStart || 0, sliceEnd || buf.length);\n    }\n\n    _this.push(buf);\n  });\n}\n\n/**\n * @ignore\n */\n\nfunction init(self) {\n  var findOneOptions = {};\n  if (self.s.readPreference) {\n    findOneOptions.readPreference = self.s.readPreference;\n  }\n  if (self.s.options && self.s.options.sort) {\n    findOneOptions.sort = self.s.options.sort;\n  }\n  if (self.s.options && self.s.options.skip) {\n    findOneOptions.skip = self.s.options.skip;\n  }\n\n  self.s.files.findOne(self.s.filter, findOneOptions, function(error, doc) {\n    if (error) {\n      return __handleError(self, error);\n    }\n\n    if (!doc) {\n      var identifier = self.s.filter._id ? self.s.filter._id.toString() : self.s.filter.filename;\n      var errmsg = 'FileNotFound: file ' + identifier + ' was not found';\n      var err = new Error(errmsg);\n      err.code = 'ENOENT';\n      return __handleError(self, err);\n    }\n\n    // If document is empty, kill the stream immediately and don't\n    // execute any reads\n    if (doc.length <= 0) {\n      self.push(null);\n      return;\n    }\n\n    if (self.destroyed) {\n      // If user destroys the stream before we have a cursor, wait\n      // until the query is done to say we're 'closed' because we can't\n      // cancel a query.\n      self.emit('close');\n      return;\n    }\n\n    try {\n      self.s.bytesToSkip = handleStartOption(self, doc, self.s.options);\n    } catch (error) {\n      return __handleError(self, error);\n    }\n\n    var filter = { files_id: doc._id };\n\n    // Currently (MongoDB 3.4.4) skip function does not support the index,\n    // it needs to retrieve all the documents first and then skip them. (CS-25811)\n    // As work around we use $gte on the \"n\" field.\n    if (self.s.options && self.s.options.start != null) {\n      var skip = Math.floor(self.s.options.start / doc.chunkSize);\n      if (skip > 0) {\n        filter['n'] = { $gte: skip };\n      }\n    }\n    self.s.cursor = self.s.chunks.find(filter).sort({ n: 1 });\n\n    if (self.s.readPreference) {\n      self.s.cursor.setReadPreference(self.s.readPreference);\n    }\n\n    self.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);\n    self.s.file = doc;\n\n    try {\n      self.s.bytesToTrim = handleEndOption(self, doc, self.s.cursor, self.s.options);\n    } catch (error) {\n      return __handleError(self, error);\n    }\n\n    self.emit('file', doc);\n  });\n}\n\n/**\n * @ignore\n */\n\nfunction waitForFile(_this, callback) {\n  if (_this.s.file) {\n    return callback();\n  }\n\n  if (!_this.s.init) {\n    init(_this);\n    _this.s.init = true;\n  }\n\n  _this.once('file', function() {\n    callback();\n  });\n}\n\n/**\n * @ignore\n */\n\nfunction handleStartOption(stream, doc, options) {\n  if (options && options.start != null) {\n    if (options.start > doc.length) {\n      throw new Error(\n        'Stream start (' +\n          options.start +\n          ') must not be ' +\n          'more than the length of the file (' +\n          doc.length +\n          ')'\n      );\n    }\n    if (options.start < 0) {\n      throw new Error('Stream start (' + options.start + ') must not be ' + 'negative');\n    }\n    if (options.end != null && options.end < options.start) {\n      throw new Error(\n        'Stream start (' +\n          options.start +\n          ') must not be ' +\n          'greater than stream end (' +\n          options.end +\n          ')'\n      );\n    }\n\n    stream.s.bytesRead = Math.floor(options.start / doc.chunkSize) * doc.chunkSize;\n    stream.s.expected = Math.floor(options.start / doc.chunkSize);\n\n    return options.start - stream.s.bytesRead;\n  }\n}\n\n/**\n * @ignore\n */\n\nfunction handleEndOption(stream, doc, cursor, options) {\n  if (options && options.end != null) {\n    if (options.end > doc.length) {\n      throw new Error(\n        'Stream end (' +\n          options.end +\n          ') must not be ' +\n          'more than the length of the file (' +\n          doc.length +\n          ')'\n      );\n    }\n    if (options.start < 0) {\n      throw new Error('Stream end (' + options.end + ') must not be ' + 'negative');\n    }\n\n    var start = options.start != null ? Math.floor(options.start / doc.chunkSize) : 0;\n\n    cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);\n\n    stream.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);\n\n    return Math.ceil(options.end / doc.chunkSize) * doc.chunkSize - options.end;\n  }\n}\n\n/**\n * @ignore\n */\n\nfunction __handleError(_this, error) {\n  _this.emit('error', error);\n}\n"]},"metadata":{},"sourceType":"script"}