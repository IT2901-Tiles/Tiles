{"ast":null,"code":"'use strict';\n\nvar inherits = require('util').inherits,\n    f = require('util').format,\n    diff = require('./shared').diff,\n    EventEmitter = require('events').EventEmitter,\n    Logger = require('../connection/logger'),\n    ReadPreference = require('./read_preference'),\n    MongoError = require('../error').MongoError,\n    Buffer = require('safe-buffer').Buffer;\n\nvar TopologyType = {\n  Single: 'Single',\n  ReplicaSetNoPrimary: 'ReplicaSetNoPrimary',\n  ReplicaSetWithPrimary: 'ReplicaSetWithPrimary',\n  Sharded: 'Sharded',\n  Unknown: 'Unknown'\n};\nvar ServerType = {\n  Standalone: 'Standalone',\n  Mongos: 'Mongos',\n  PossiblePrimary: 'PossiblePrimary',\n  RSPrimary: 'RSPrimary',\n  RSSecondary: 'RSSecondary',\n  RSArbiter: 'RSArbiter',\n  RSOther: 'RSOther',\n  RSGhost: 'RSGhost',\n  Unknown: 'Unknown'\n};\n\nvar ReplSetState = function (options) {\n  options = options || {}; // Add event listener\n\n  EventEmitter.call(this); // Topology state\n\n  this.topologyType = TopologyType.ReplicaSetNoPrimary;\n  this.setName = options.setName; // Server set\n\n  this.set = {}; // Unpacked options\n\n  this.id = options.id;\n  this.setName = options.setName; // Replicaset logger\n\n  this.logger = options.logger || Logger('ReplSet', options); // Server selection index\n\n  this.index = 0; // Acceptable latency\n\n  this.acceptableLatency = options.acceptableLatency || 15; // heartbeatFrequencyMS\n\n  this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 10000; // Server side\n\n  this.primary = null;\n  this.secondaries = [];\n  this.arbiters = [];\n  this.passives = [];\n  this.ghosts = []; // Current unknown hosts\n\n  this.unknownServers = []; // In set status\n\n  this.set = {}; // Status\n\n  this.maxElectionId = null;\n  this.maxSetVersion = 0; // Description of the Replicaset\n\n  this.replicasetDescription = {\n    topologyType: 'Unknown',\n    servers: []\n  };\n  this.logicalSessionTimeoutMinutes = undefined;\n};\n\ninherits(ReplSetState, EventEmitter);\n\nReplSetState.prototype.hasPrimaryAndSecondary = function () {\n  return this.primary != null && this.secondaries.length > 0;\n};\n\nReplSetState.prototype.hasPrimaryOrSecondary = function () {\n  return this.hasPrimary() || this.hasSecondary();\n};\n\nReplSetState.prototype.hasPrimary = function () {\n  return this.primary != null;\n};\n\nReplSetState.prototype.hasSecondary = function () {\n  return this.secondaries.length > 0;\n};\n\nReplSetState.prototype.get = function (host) {\n  var servers = this.allServers();\n\n  for (var i = 0; i < servers.length; i++) {\n    if (servers[i].name.toLowerCase() === host.toLowerCase()) {\n      return servers[i];\n    }\n  }\n\n  return null;\n};\n\nReplSetState.prototype.allServers = function (options) {\n  options = options || {};\n  var servers = this.primary ? [this.primary] : [];\n  servers = servers.concat(this.secondaries);\n  if (!options.ignoreArbiters) servers = servers.concat(this.arbiters);\n  servers = servers.concat(this.passives);\n  return servers;\n};\n\nReplSetState.prototype.destroy = function (options, callback) {\n  const serversToDestroy = this.secondaries.concat(this.arbiters).concat(this.passives).concat(this.ghosts);\n  if (this.primary) serversToDestroy.push(this.primary);\n  let serverCount = serversToDestroy.length;\n\n  const serverDestroyed = () => {\n    serverCount--;\n\n    if (serverCount > 0) {\n      return;\n    } // Clear out the complete state\n\n\n    this.secondaries = [];\n    this.arbiters = [];\n    this.passives = [];\n    this.ghosts = [];\n    this.unknownServers = [];\n    this.set = {};\n    this.primary = null; // Emit the topology changed\n\n    emitTopologyDescriptionChanged(this);\n\n    if (typeof callback === 'function') {\n      callback(null, null);\n    }\n  };\n\n  if (serverCount === 0) {\n    serverDestroyed();\n    return;\n  }\n\n  serversToDestroy.forEach(server => server.destroy(options, serverDestroyed));\n};\n\nReplSetState.prototype.remove = function (server, options) {\n  options = options || {}; // Get the server name and lowerCase it\n\n  var serverName = server.name.toLowerCase(); // Only remove if the current server is not connected\n\n  var servers = this.primary ? [this.primary] : [];\n  servers = servers.concat(this.secondaries);\n  servers = servers.concat(this.arbiters);\n  servers = servers.concat(this.passives); // Check if it's active and this is just a failed connection attempt\n\n  for (var i = 0; i < servers.length; i++) {\n    if (!options.force && servers[i].equals(server) && servers[i].isConnected && servers[i].isConnected()) {\n      return;\n    }\n  } // If we have it in the set remove it\n\n\n  if (this.set[serverName]) {\n    this.set[serverName].type = ServerType.Unknown;\n    this.set[serverName].electionId = null;\n    this.set[serverName].setName = null;\n    this.set[serverName].setVersion = null;\n  } // Remove type\n\n\n  var removeType = null; // Remove from any lists\n\n  if (this.primary && this.primary.equals(server)) {\n    this.primary = null;\n    this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    removeType = 'primary';\n  } // Remove from any other server lists\n\n\n  removeType = removeFrom(server, this.secondaries) ? 'secondary' : removeType;\n  removeType = removeFrom(server, this.arbiters) ? 'arbiter' : removeType;\n  removeType = removeFrom(server, this.passives) ? 'secondary' : removeType;\n  removeFrom(server, this.ghosts);\n  removeFrom(server, this.unknownServers); // Push to unknownServers\n\n  this.unknownServers.push(serverName); // Do we have a removeType\n\n  if (removeType) {\n    this.emit('left', removeType, server);\n  }\n};\n\nconst isArbiter = ismaster => ismaster.arbiterOnly && ismaster.setName;\n\nReplSetState.prototype.update = function (server) {\n  var self = this; // Get the current ismaster\n\n  var ismaster = server.lastIsMaster(); // Get the server name and lowerCase it\n\n  var serverName = server.name.toLowerCase(); //\n  // Add any hosts\n  //\n\n  if (ismaster) {\n    // Join all the possible new hosts\n    var hosts = Array.isArray(ismaster.hosts) ? ismaster.hosts : [];\n    hosts = hosts.concat(Array.isArray(ismaster.arbiters) ? ismaster.arbiters : []);\n    hosts = hosts.concat(Array.isArray(ismaster.passives) ? ismaster.passives : []);\n    hosts = hosts.map(function (s) {\n      return s.toLowerCase();\n    }); // Add all hosts as unknownServers\n\n    for (var i = 0; i < hosts.length; i++) {\n      // Add to the list of unknown server\n      if (this.unknownServers.indexOf(hosts[i]) === -1 && (!this.set[hosts[i]] || this.set[hosts[i]].type === ServerType.Unknown)) {\n        this.unknownServers.push(hosts[i].toLowerCase());\n      }\n\n      if (!this.set[hosts[i]]) {\n        this.set[hosts[i]] = {\n          type: ServerType.Unknown,\n          electionId: null,\n          setName: null,\n          setVersion: null\n        };\n      }\n    }\n  } //\n  // Unknown server\n  //\n\n\n  if (!ismaster && !inList(ismaster, server, this.unknownServers)) {\n    self.set[serverName] = {\n      type: ServerType.Unknown,\n      setVersion: null,\n      electionId: null,\n      setName: null\n    }; // Update set information about the server instance\n\n    self.set[serverName].type = ServerType.Unknown;\n    self.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;\n    self.set[serverName].setName = ismaster ? ismaster.setName : ismaster;\n    self.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;\n\n    if (self.unknownServers.indexOf(server.name) === -1) {\n      self.unknownServers.push(serverName);\n    } // Set the topology\n\n\n    return false;\n  } // Update logicalSessionTimeoutMinutes\n\n\n  if (ismaster.logicalSessionTimeoutMinutes !== undefined && !isArbiter(ismaster)) {\n    if (self.logicalSessionTimeoutMinutes === undefined || ismaster.logicalSessionTimeoutMinutes === null) {\n      self.logicalSessionTimeoutMinutes = ismaster.logicalSessionTimeoutMinutes;\n    } else {\n      self.logicalSessionTimeoutMinutes = Math.min(self.logicalSessionTimeoutMinutes, ismaster.logicalSessionTimeoutMinutes);\n    }\n  } //\n  // Is this a mongos\n  //\n\n\n  if (ismaster && ismaster.msg === 'isdbgrid') {\n    if (this.primary && this.primary.name === serverName) {\n      this.primary = null;\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    }\n\n    return false;\n  } // A RSGhost instance\n\n\n  if (ismaster.isreplicaset) {\n    self.set[serverName] = {\n      type: ServerType.RSGhost,\n      setVersion: null,\n      electionId: null,\n      setName: ismaster.setName\n    };\n\n    if (this.primary && this.primary.name === serverName) {\n      this.primary = null;\n    } // Set the topology\n\n\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName; // Set the topology\n\n    return false;\n  } // A RSOther instance\n\n\n  if (ismaster.setName && ismaster.hidden || ismaster.setName && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly && !ismaster.passive) {\n    self.set[serverName] = {\n      type: ServerType.RSOther,\n      setVersion: null,\n      electionId: null,\n      setName: ismaster.setName\n    }; // Set the topology\n\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    return false;\n  } //\n  // Standalone server, destroy and return\n  //\n\n\n  if (ismaster && ismaster.ismaster && !ismaster.setName) {\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.Unknown;\n    this.remove(server, {\n      force: true\n    });\n    return false;\n  } //\n  // Server in maintanance mode\n  //\n\n\n  if (ismaster && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) {\n    this.remove(server, {\n      force: true\n    });\n    return false;\n  } //\n  // If the .me field does not match the passed in server\n  //\n\n\n  if (ismaster.me && ismaster.me.toLowerCase() !== serverName) {\n    if (this.logger.isWarn()) {\n      this.logger.warn(f('the seedlist server was removed due to its address %s not matching its ismaster.me address %s', server.name, ismaster.me));\n    } // Delete from the set\n\n\n    delete this.set[serverName]; // Delete unknown servers\n\n    removeFrom(server, self.unknownServers); // Destroy the instance\n\n    server.destroy({\n      force: true\n    }); // Set the type of topology we have\n\n    if (this.primary && !this.primary.equals(server)) {\n      this.topologyType = TopologyType.ReplicaSetWithPrimary;\n    } else {\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    } //\n    // We have a potential primary\n    //\n\n\n    if (!this.primary && ismaster.primary) {\n      this.set[ismaster.primary.toLowerCase()] = {\n        type: ServerType.PossiblePrimary,\n        setName: null,\n        electionId: null,\n        setVersion: null\n      };\n    }\n\n    return false;\n  } //\n  // Primary handling\n  //\n\n\n  if (!this.primary && ismaster.ismaster && ismaster.setName) {\n    var ismasterElectionId = server.lastIsMaster().electionId;\n\n    if (this.setName && this.setName !== ismaster.setName) {\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n      return new MongoError(f('setName from ismaster does not match provided connection setName [%s] != [%s]', ismaster.setName, this.setName));\n    }\n\n    if (!this.maxElectionId && ismasterElectionId) {\n      this.maxElectionId = ismasterElectionId;\n    } else if (this.maxElectionId && ismasterElectionId) {\n      var result = compareObjectIds(this.maxElectionId, ismasterElectionId); // Get the electionIds\n\n      var ismasterSetVersion = server.lastIsMaster().setVersion;\n\n      if (result === 1) {\n        this.topologyType = TopologyType.ReplicaSetNoPrimary;\n        return false;\n      } else if (result === 0 && ismasterSetVersion) {\n        if (ismasterSetVersion < this.maxSetVersion) {\n          this.topologyType = TopologyType.ReplicaSetNoPrimary;\n          return false;\n        }\n      }\n\n      this.maxSetVersion = ismasterSetVersion;\n      this.maxElectionId = ismasterElectionId;\n    } // Hande normalization of server names\n\n\n    var normalizedHosts = ismaster.hosts.map(function (x) {\n      return x.toLowerCase();\n    });\n    var locationIndex = normalizedHosts.indexOf(serverName); // Validate that the server exists in the host list\n\n    if (locationIndex !== -1) {\n      self.primary = server;\n      self.set[serverName] = {\n        type: ServerType.RSPrimary,\n        setVersion: ismaster.setVersion,\n        electionId: ismaster.electionId,\n        setName: ismaster.setName\n      }; // Set the topology\n\n      this.topologyType = TopologyType.ReplicaSetWithPrimary;\n      if (ismaster.setName) this.setName = ismaster.setName;\n      removeFrom(server, self.unknownServers);\n      removeFrom(server, self.secondaries);\n      removeFrom(server, self.passives);\n      self.emit('joined', 'primary', server);\n    } else {\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    }\n\n    emitTopologyDescriptionChanged(self);\n    return true;\n  } else if (ismaster.ismaster && ismaster.setName) {\n    // Get the electionIds\n    var currentElectionId = self.set[self.primary.name.toLowerCase()].electionId;\n    var currentSetVersion = self.set[self.primary.name.toLowerCase()].setVersion;\n    var currentSetName = self.set[self.primary.name.toLowerCase()].setName;\n    ismasterElectionId = server.lastIsMaster().electionId;\n    ismasterSetVersion = server.lastIsMaster().setVersion;\n    var ismasterSetName = server.lastIsMaster().setName; // Is it the same server instance\n\n    if (this.primary.equals(server) && currentSetName === ismasterSetName) {\n      return false;\n    } // If we do not have the same rs name\n\n\n    if (currentSetName && currentSetName !== ismasterSetName) {\n      if (!this.primary.equals(server)) {\n        this.topologyType = TopologyType.ReplicaSetWithPrimary;\n      } else {\n        this.topologyType = TopologyType.ReplicaSetNoPrimary;\n      }\n\n      return false;\n    } // Check if we need to replace the server\n\n\n    if (currentElectionId && ismasterElectionId) {\n      result = compareObjectIds(currentElectionId, ismasterElectionId);\n\n      if (result === 1) {\n        return false;\n      } else if (result === 0 && currentSetVersion > ismasterSetVersion) {\n        return false;\n      }\n    } else if (!currentElectionId && ismasterElectionId && ismasterSetVersion) {\n      if (ismasterSetVersion < this.maxSetVersion) {\n        return false;\n      }\n    }\n\n    if (!this.maxElectionId && ismasterElectionId) {\n      this.maxElectionId = ismasterElectionId;\n    } else if (this.maxElectionId && ismasterElectionId) {\n      result = compareObjectIds(this.maxElectionId, ismasterElectionId);\n\n      if (result === 1) {\n        return false;\n      } else if (result === 0 && currentSetVersion && ismasterSetVersion) {\n        if (ismasterSetVersion < this.maxSetVersion) {\n          return false;\n        }\n      } else {\n        if (ismasterSetVersion < this.maxSetVersion) {\n          return false;\n        }\n      }\n\n      this.maxElectionId = ismasterElectionId;\n      this.maxSetVersion = ismasterSetVersion;\n    } else {\n      this.maxSetVersion = ismasterSetVersion;\n    } // Modify the entry to unknown\n\n\n    self.set[self.primary.name.toLowerCase()] = {\n      type: ServerType.Unknown,\n      setVersion: null,\n      electionId: null,\n      setName: null\n    }; // Signal primary left\n\n    self.emit('left', 'primary', this.primary); // Destroy the instance\n\n    self.primary.destroy({\n      force: true\n    }); // Set the new instance\n\n    self.primary = server; // Set the set information\n\n    self.set[serverName] = {\n      type: ServerType.RSPrimary,\n      setVersion: ismaster.setVersion,\n      electionId: ismaster.electionId,\n      setName: ismaster.setName\n    }; // Set the topology\n\n    this.topologyType = TopologyType.ReplicaSetWithPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers);\n    removeFrom(server, self.secondaries);\n    removeFrom(server, self.passives);\n    self.emit('joined', 'primary', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  } // A possible instance\n\n\n  if (!this.primary && ismaster.primary) {\n    self.set[ismaster.primary.toLowerCase()] = {\n      type: ServerType.PossiblePrimary,\n      setVersion: null,\n      electionId: null,\n      setName: null\n    };\n  } //\n  // Secondary handling\n  //\n\n\n  if (ismaster.secondary && ismaster.setName && !inList(ismaster, server, this.secondaries) && this.setName && this.setName === ismaster.setName) {\n    addToList(self, ServerType.RSSecondary, ismaster, server, this.secondaries); // Set the topology\n\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers); // Remove primary\n\n    if (this.primary && this.primary.name.toLowerCase() === serverName) {\n      server.destroy({\n        force: true\n      });\n      this.primary = null;\n      self.emit('left', 'primary', server);\n    } // Emit secondary joined replicaset\n\n\n    self.emit('joined', 'secondary', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  } //\n  // Arbiter handling\n  //\n\n\n  if (isArbiter(ismaster) && !inList(ismaster, server, this.arbiters) && this.setName && this.setName === ismaster.setName) {\n    addToList(self, ServerType.RSArbiter, ismaster, server, this.arbiters); // Set the topology\n\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers);\n    self.emit('joined', 'arbiter', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  } //\n  // Passive handling\n  //\n\n\n  if (ismaster.passive && ismaster.setName && !inList(ismaster, server, this.passives) && this.setName && this.setName === ismaster.setName) {\n    addToList(self, ServerType.RSSecondary, ismaster, server, this.passives); // Set the topology\n\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers); // Remove primary\n\n    if (this.primary && this.primary.name.toLowerCase() === serverName) {\n      server.destroy({\n        force: true\n      });\n      this.primary = null;\n      self.emit('left', 'primary', server);\n    }\n\n    self.emit('joined', 'secondary', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  } //\n  // Remove the primary\n  //\n\n\n  if (this.set[serverName] && this.set[serverName].type === ServerType.RSPrimary) {\n    self.emit('left', 'primary', this.primary);\n    this.primary.destroy({\n      force: true\n    });\n    this.primary = null;\n    this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    return false;\n  }\n\n  this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;\n  return false;\n};\n/**\n * Recalculate single server max staleness\n * @method\n */\n\n\nReplSetState.prototype.updateServerMaxStaleness = function (server, haInterval) {\n  // Locate the max secondary lastwrite\n  var max = 0; // Go over all secondaries\n\n  for (var i = 0; i < this.secondaries.length; i++) {\n    max = Math.max(max, this.secondaries[i].lastWriteDate);\n  } // Perform this servers staleness calculation\n\n\n  if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary && this.hasPrimary()) {\n    server.staleness = server.lastUpdateTime - server.lastWriteDate - (this.primary.lastUpdateTime - this.primary.lastWriteDate) + haInterval;\n  } else if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary) {\n    server.staleness = max - server.lastWriteDate + haInterval;\n  }\n};\n/**\n * Recalculate all the staleness values for secodaries\n * @method\n */\n\n\nReplSetState.prototype.updateSecondariesMaxStaleness = function (haInterval) {\n  for (var i = 0; i < this.secondaries.length; i++) {\n    this.updateServerMaxStaleness(this.secondaries[i], haInterval);\n  }\n};\n/**\n * Pick a server by the passed in ReadPreference\n * @method\n * @param {ReadPreference} readPreference The ReadPreference instance to use\n */\n\n\nReplSetState.prototype.pickServer = function (readPreference) {\n  // If no read Preference set to primary by default\n  readPreference = readPreference || ReadPreference.primary; // maxStalenessSeconds is not allowed with a primary read\n\n  if (readPreference.preference === 'primary' && readPreference.maxStalenessSeconds != null) {\n    return new MongoError('primary readPreference incompatible with maxStalenessSeconds');\n  } // Check if we have any non compatible servers for maxStalenessSeconds\n\n\n  var allservers = this.primary ? [this.primary] : [];\n  allservers = allservers.concat(this.secondaries); // Does any of the servers not support the right wire protocol version\n  // for maxStalenessSeconds when maxStalenessSeconds specified on readPreference. Then error out\n\n  if (readPreference.maxStalenessSeconds != null) {\n    for (var i = 0; i < allservers.length; i++) {\n      if (allservers[i].ismaster.maxWireVersion < 5) {\n        return new MongoError('maxStalenessSeconds not supported by at least one of the replicaset members');\n      }\n    }\n  } // Do we have the nearest readPreference\n\n\n  if (readPreference.preference === 'nearest' && readPreference.maxStalenessSeconds == null) {\n    return pickNearest(this, readPreference);\n  } else if (readPreference.preference === 'nearest' && readPreference.maxStalenessSeconds != null) {\n    return pickNearestMaxStalenessSeconds(this, readPreference);\n  } // Get all the secondaries\n\n\n  var secondaries = this.secondaries; // Check if we can satisfy and of the basic read Preferences\n\n  if (readPreference.equals(ReadPreference.secondary) && secondaries.length === 0) {\n    return new MongoError('no secondary server available');\n  }\n\n  if (readPreference.equals(ReadPreference.secondaryPreferred) && secondaries.length === 0 && this.primary == null) {\n    return new MongoError('no secondary or primary server available');\n  }\n\n  if (readPreference.equals(ReadPreference.primary) && this.primary == null) {\n    return new MongoError('no primary server available');\n  } // Secondary preferred or just secondaries\n\n\n  if (readPreference.equals(ReadPreference.secondaryPreferred) || readPreference.equals(ReadPreference.secondary)) {\n    if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {\n      // Pick nearest of any other servers available\n      var server = pickNearest(this, readPreference); // No server in the window return primary\n\n      if (server) {\n        return server;\n      }\n    } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {\n      // Pick nearest of any other servers available\n      server = pickNearestMaxStalenessSeconds(this, readPreference); // No server in the window return primary\n\n      if (server) {\n        return server;\n      }\n    }\n\n    if (readPreference.equals(ReadPreference.secondaryPreferred)) {\n      return this.primary;\n    }\n\n    return null;\n  } // Primary preferred\n\n\n  if (readPreference.equals(ReadPreference.primaryPreferred)) {\n    server = null; // We prefer the primary if it's available\n\n    if (this.primary) {\n      return this.primary;\n    } // Pick a secondary\n\n\n    if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {\n      server = pickNearest(this, readPreference);\n    } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {\n      server = pickNearestMaxStalenessSeconds(this, readPreference);\n    } //  Did we find a server\n\n\n    if (server) return server;\n  } // Return the primary\n\n\n  return this.primary;\n}; //\n// Filter serves by tags\n\n\nvar filterByTags = function (readPreference, servers) {\n  if (readPreference.tags == null) return servers;\n  var filteredServers = [];\n  var tagsArray = Array.isArray(readPreference.tags) ? readPreference.tags : [readPreference.tags]; // Iterate over the tags\n\n  for (var j = 0; j < tagsArray.length; j++) {\n    var tags = tagsArray[j]; // Iterate over all the servers\n\n    for (var i = 0; i < servers.length; i++) {\n      var serverTag = servers[i].lastIsMaster().tags || {}; // Did we find the a matching server\n\n      var found = true; // Check if the server is valid\n\n      for (var name in tags) {\n        if (serverTag[name] !== tags[name]) {\n          found = false;\n        }\n      } // Add to candidate list\n\n\n      if (found) {\n        filteredServers.push(servers[i]);\n      }\n    }\n  } // Returned filtered servers\n\n\n  return filteredServers;\n};\n\nfunction pickNearestMaxStalenessSeconds(self, readPreference) {\n  // Only get primary and secondaries as seeds\n  var servers = []; // Get the maxStalenessMS\n\n  var maxStalenessMS = readPreference.maxStalenessSeconds * 1000; // Check if the maxStalenessMS > 90 seconds\n\n  if (maxStalenessMS < 90 * 1000) {\n    return new MongoError('maxStalenessSeconds must be set to at least 90 seconds');\n  } // Add primary to list if not a secondary read preference\n\n\n  if (self.primary && readPreference.preference !== 'secondary' && readPreference.preference !== 'secondaryPreferred') {\n    servers.push(self.primary);\n  } // Add all the secondaries\n\n\n  for (var i = 0; i < self.secondaries.length; i++) {\n    servers.push(self.secondaries[i]);\n  } // If we have a secondaryPreferred readPreference and no server add the primary\n\n\n  if (self.primary && servers.length === 0 && readPreference.preference !== 'secondaryPreferred') {\n    servers.push(self.primary);\n  } // Filter by tags\n\n\n  servers = filterByTags(readPreference, servers); // Filter by latency\n\n  servers = servers.filter(function (s) {\n    return s.staleness <= maxStalenessMS;\n  }); // Sort by time\n\n  servers.sort(function (a, b) {\n    return a.lastIsMasterMS - b.lastIsMasterMS;\n  }); // No servers, default to primary\n\n  if (servers.length === 0) {\n    return null;\n  } // Ensure index does not overflow the number of available servers\n\n\n  self.index = self.index % servers.length; // Get the server\n\n  var server = servers[self.index]; // Add to the index\n\n  self.index = self.index + 1; // Return the first server of the sorted and filtered list\n\n  return server;\n}\n\nfunction pickNearest(self, readPreference) {\n  // Only get primary and secondaries as seeds\n  var servers = []; // Add primary to list if not a secondary read preference\n\n  if (self.primary && readPreference.preference !== 'secondary' && readPreference.preference !== 'secondaryPreferred') {\n    servers.push(self.primary);\n  } // Add all the secondaries\n\n\n  for (var i = 0; i < self.secondaries.length; i++) {\n    servers.push(self.secondaries[i]);\n  } // If we have a secondaryPreferred readPreference and no server add the primary\n\n\n  if (servers.length === 0 && self.primary && readPreference.preference !== 'secondaryPreferred') {\n    servers.push(self.primary);\n  } // Filter by tags\n\n\n  servers = filterByTags(readPreference, servers); // Sort by time\n\n  servers.sort(function (a, b) {\n    return a.lastIsMasterMS - b.lastIsMasterMS;\n  }); // Locate lowest time (picked servers are lowest time + acceptable Latency margin)\n\n  var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0; // Filter by latency\n\n  servers = servers.filter(function (s) {\n    return s.lastIsMasterMS <= lowest + self.acceptableLatency;\n  }); // No servers, default to primary\n\n  if (servers.length === 0) {\n    return null;\n  } // Ensure index does not overflow the number of available servers\n\n\n  self.index = self.index % servers.length; // Get the server\n\n  var server = servers[self.index]; // Add to the index\n\n  self.index = self.index + 1; // Return the first server of the sorted and filtered list\n\n  return server;\n}\n\nfunction inList(ismaster, server, list) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i] && list[i].name && list[i].name.toLowerCase() === server.name.toLowerCase()) return true;\n  }\n\n  return false;\n}\n\nfunction addToList(self, type, ismaster, server, list) {\n  var serverName = server.name.toLowerCase(); // Update set information about the server instance\n\n  self.set[serverName].type = type;\n  self.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;\n  self.set[serverName].setName = ismaster ? ismaster.setName : ismaster;\n  self.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster; // Add to the list\n\n  list.push(server);\n}\n\nfunction compareObjectIds(id1, id2) {\n  var a = Buffer.from(id1.toHexString(), 'hex');\n  var b = Buffer.from(id2.toHexString(), 'hex');\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (typeof Buffer.compare === 'function') {\n    return Buffer.compare(a, b);\n  }\n\n  var x = a.length;\n  var y = b.length;\n  var len = Math.min(x, y);\n\n  for (var i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      break;\n    }\n  }\n\n  if (i !== len) {\n    x = a[i];\n    y = b[i];\n  }\n\n  return x < y ? -1 : y < x ? 1 : 0;\n}\n\nfunction removeFrom(server, list) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i].equals && list[i].equals(server)) {\n      list.splice(i, 1);\n      return true;\n    } else if (typeof list[i] === 'string' && list[i].toLowerCase() === server.name.toLowerCase()) {\n      list.splice(i, 1);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction emitTopologyDescriptionChanged(self) {\n  if (self.listeners('topologyDescriptionChanged').length > 0) {\n    var topology = 'Unknown';\n    var setName = self.setName;\n\n    if (self.hasPrimaryAndSecondary()) {\n      topology = 'ReplicaSetWithPrimary';\n    } else if (!self.hasPrimary() && self.hasSecondary()) {\n      topology = 'ReplicaSetNoPrimary';\n    } // Generate description\n\n\n    var description = {\n      topologyType: topology,\n      setName: setName,\n      servers: []\n    }; // Add the primary to the list\n\n    if (self.hasPrimary()) {\n      var desc = self.primary.getDescription();\n      desc.type = 'RSPrimary';\n      description.servers.push(desc);\n    } // Add all the secondaries\n\n\n    description.servers = description.servers.concat(self.secondaries.map(function (x) {\n      var description = x.getDescription();\n      description.type = 'RSSecondary';\n      return description;\n    })); // Add all the arbiters\n\n    description.servers = description.servers.concat(self.arbiters.map(function (x) {\n      var description = x.getDescription();\n      description.type = 'RSArbiter';\n      return description;\n    })); // Add all the passives\n\n    description.servers = description.servers.concat(self.passives.map(function (x) {\n      var description = x.getDescription();\n      description.type = 'RSSecondary';\n      return description;\n    })); // Get the diff\n\n    var diffResult = diff(self.replicasetDescription, description); // Create the result\n\n    var result = {\n      topologyId: self.id,\n      previousDescription: self.replicasetDescription,\n      newDescription: description,\n      diff: diffResult\n    }; // Emit the topologyDescription change\n    // if(diffResult.servers.length > 0) {\n\n    self.emit('topologyDescriptionChanged', result); // }\n    // Set the new description\n\n    self.replicasetDescription = description;\n  }\n}\n\nmodule.exports = ReplSetState;","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/core/topologies/replset_state.js"],"names":["inherits","require","f","format","diff","EventEmitter","Logger","ReadPreference","MongoError","Buffer","TopologyType","Single","ReplicaSetNoPrimary","ReplicaSetWithPrimary","Sharded","Unknown","ServerType","Standalone","Mongos","PossiblePrimary","RSPrimary","RSSecondary","RSArbiter","RSOther","RSGhost","ReplSetState","options","call","topologyType","setName","set","id","logger","index","acceptableLatency","heartbeatFrequencyMS","primary","secondaries","arbiters","passives","ghosts","unknownServers","maxElectionId","maxSetVersion","replicasetDescription","servers","logicalSessionTimeoutMinutes","undefined","prototype","hasPrimaryAndSecondary","length","hasPrimaryOrSecondary","hasPrimary","hasSecondary","get","host","allServers","i","name","toLowerCase","concat","ignoreArbiters","destroy","callback","serversToDestroy","push","serverCount","serverDestroyed","emitTopologyDescriptionChanged","forEach","server","remove","serverName","force","equals","isConnected","type","electionId","setVersion","removeType","removeFrom","emit","isArbiter","ismaster","arbiterOnly","update","self","lastIsMaster","hosts","Array","isArray","map","s","indexOf","inList","Math","min","msg","isreplicaset","hidden","secondary","passive","me","isWarn","warn","ismasterElectionId","result","compareObjectIds","ismasterSetVersion","normalizedHosts","x","locationIndex","currentElectionId","currentSetVersion","currentSetName","ismasterSetName","addToList","updateServerMaxStaleness","haInterval","max","lastWriteDate","maxWireVersion","staleness","lastUpdateTime","updateSecondariesMaxStaleness","pickServer","readPreference","preference","maxStalenessSeconds","allservers","pickNearest","pickNearestMaxStalenessSeconds","secondaryPreferred","primaryPreferred","filterByTags","tags","filteredServers","tagsArray","j","serverTag","found","maxStalenessMS","filter","sort","a","b","lastIsMasterMS","lowest","list","id1","id2","from","toHexString","compare","y","len","splice","listeners","topology","description","desc","getDescription","diffResult","topologyId","previousDescription","newDescription","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar inherits = require('util').inherits,\n  f = require('util').format,\n  diff = require('./shared').diff,\n  EventEmitter = require('events').EventEmitter,\n  Logger = require('../connection/logger'),\n  ReadPreference = require('./read_preference'),\n  MongoError = require('../error').MongoError,\n  Buffer = require('safe-buffer').Buffer;\n\nvar TopologyType = {\n  Single: 'Single',\n  ReplicaSetNoPrimary: 'ReplicaSetNoPrimary',\n  ReplicaSetWithPrimary: 'ReplicaSetWithPrimary',\n  Sharded: 'Sharded',\n  Unknown: 'Unknown'\n};\n\nvar ServerType = {\n  Standalone: 'Standalone',\n  Mongos: 'Mongos',\n  PossiblePrimary: 'PossiblePrimary',\n  RSPrimary: 'RSPrimary',\n  RSSecondary: 'RSSecondary',\n  RSArbiter: 'RSArbiter',\n  RSOther: 'RSOther',\n  RSGhost: 'RSGhost',\n  Unknown: 'Unknown'\n};\n\nvar ReplSetState = function(options) {\n  options = options || {};\n  // Add event listener\n  EventEmitter.call(this);\n  // Topology state\n  this.topologyType = TopologyType.ReplicaSetNoPrimary;\n  this.setName = options.setName;\n\n  // Server set\n  this.set = {};\n\n  // Unpacked options\n  this.id = options.id;\n  this.setName = options.setName;\n\n  // Replicaset logger\n  this.logger = options.logger || Logger('ReplSet', options);\n\n  // Server selection index\n  this.index = 0;\n  // Acceptable latency\n  this.acceptableLatency = options.acceptableLatency || 15;\n\n  // heartbeatFrequencyMS\n  this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 10000;\n\n  // Server side\n  this.primary = null;\n  this.secondaries = [];\n  this.arbiters = [];\n  this.passives = [];\n  this.ghosts = [];\n  // Current unknown hosts\n  this.unknownServers = [];\n  // In set status\n  this.set = {};\n  // Status\n  this.maxElectionId = null;\n  this.maxSetVersion = 0;\n  // Description of the Replicaset\n  this.replicasetDescription = {\n    topologyType: 'Unknown',\n    servers: []\n  };\n\n  this.logicalSessionTimeoutMinutes = undefined;\n};\n\ninherits(ReplSetState, EventEmitter);\n\nReplSetState.prototype.hasPrimaryAndSecondary = function() {\n  return this.primary != null && this.secondaries.length > 0;\n};\n\nReplSetState.prototype.hasPrimaryOrSecondary = function() {\n  return this.hasPrimary() || this.hasSecondary();\n};\n\nReplSetState.prototype.hasPrimary = function() {\n  return this.primary != null;\n};\n\nReplSetState.prototype.hasSecondary = function() {\n  return this.secondaries.length > 0;\n};\n\nReplSetState.prototype.get = function(host) {\n  var servers = this.allServers();\n\n  for (var i = 0; i < servers.length; i++) {\n    if (servers[i].name.toLowerCase() === host.toLowerCase()) {\n      return servers[i];\n    }\n  }\n\n  return null;\n};\n\nReplSetState.prototype.allServers = function(options) {\n  options = options || {};\n  var servers = this.primary ? [this.primary] : [];\n  servers = servers.concat(this.secondaries);\n  if (!options.ignoreArbiters) servers = servers.concat(this.arbiters);\n  servers = servers.concat(this.passives);\n  return servers;\n};\n\nReplSetState.prototype.destroy = function(options, callback) {\n  const serversToDestroy = this.secondaries\n    .concat(this.arbiters)\n    .concat(this.passives)\n    .concat(this.ghosts);\n  if (this.primary) serversToDestroy.push(this.primary);\n\n  let serverCount = serversToDestroy.length;\n  const serverDestroyed = () => {\n    serverCount--;\n    if (serverCount > 0) {\n      return;\n    }\n\n    // Clear out the complete state\n    this.secondaries = [];\n    this.arbiters = [];\n    this.passives = [];\n    this.ghosts = [];\n    this.unknownServers = [];\n    this.set = {};\n    this.primary = null;\n\n    // Emit the topology changed\n    emitTopologyDescriptionChanged(this);\n\n    if (typeof callback === 'function') {\n      callback(null, null);\n    }\n  };\n\n  if (serverCount === 0) {\n    serverDestroyed();\n    return;\n  }\n\n  serversToDestroy.forEach(server => server.destroy(options, serverDestroyed));\n};\n\nReplSetState.prototype.remove = function(server, options) {\n  options = options || {};\n\n  // Get the server name and lowerCase it\n  var serverName = server.name.toLowerCase();\n\n  // Only remove if the current server is not connected\n  var servers = this.primary ? [this.primary] : [];\n  servers = servers.concat(this.secondaries);\n  servers = servers.concat(this.arbiters);\n  servers = servers.concat(this.passives);\n\n  // Check if it's active and this is just a failed connection attempt\n  for (var i = 0; i < servers.length; i++) {\n    if (\n      !options.force &&\n      servers[i].equals(server) &&\n      servers[i].isConnected &&\n      servers[i].isConnected()\n    ) {\n      return;\n    }\n  }\n\n  // If we have it in the set remove it\n  if (this.set[serverName]) {\n    this.set[serverName].type = ServerType.Unknown;\n    this.set[serverName].electionId = null;\n    this.set[serverName].setName = null;\n    this.set[serverName].setVersion = null;\n  }\n\n  // Remove type\n  var removeType = null;\n\n  // Remove from any lists\n  if (this.primary && this.primary.equals(server)) {\n    this.primary = null;\n    this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    removeType = 'primary';\n  }\n\n  // Remove from any other server lists\n  removeType = removeFrom(server, this.secondaries) ? 'secondary' : removeType;\n  removeType = removeFrom(server, this.arbiters) ? 'arbiter' : removeType;\n  removeType = removeFrom(server, this.passives) ? 'secondary' : removeType;\n  removeFrom(server, this.ghosts);\n  removeFrom(server, this.unknownServers);\n\n  // Push to unknownServers\n  this.unknownServers.push(serverName);\n\n  // Do we have a removeType\n  if (removeType) {\n    this.emit('left', removeType, server);\n  }\n};\n\nconst isArbiter = ismaster => ismaster.arbiterOnly && ismaster.setName;\n\nReplSetState.prototype.update = function(server) {\n  var self = this;\n  // Get the current ismaster\n  var ismaster = server.lastIsMaster();\n\n  // Get the server name and lowerCase it\n  var serverName = server.name.toLowerCase();\n\n  //\n  // Add any hosts\n  //\n  if (ismaster) {\n    // Join all the possible new hosts\n    var hosts = Array.isArray(ismaster.hosts) ? ismaster.hosts : [];\n    hosts = hosts.concat(Array.isArray(ismaster.arbiters) ? ismaster.arbiters : []);\n    hosts = hosts.concat(Array.isArray(ismaster.passives) ? ismaster.passives : []);\n    hosts = hosts.map(function(s) {\n      return s.toLowerCase();\n    });\n\n    // Add all hosts as unknownServers\n    for (var i = 0; i < hosts.length; i++) {\n      // Add to the list of unknown server\n      if (\n        this.unknownServers.indexOf(hosts[i]) === -1 &&\n        (!this.set[hosts[i]] || this.set[hosts[i]].type === ServerType.Unknown)\n      ) {\n        this.unknownServers.push(hosts[i].toLowerCase());\n      }\n\n      if (!this.set[hosts[i]]) {\n        this.set[hosts[i]] = {\n          type: ServerType.Unknown,\n          electionId: null,\n          setName: null,\n          setVersion: null\n        };\n      }\n    }\n  }\n\n  //\n  // Unknown server\n  //\n  if (!ismaster && !inList(ismaster, server, this.unknownServers)) {\n    self.set[serverName] = {\n      type: ServerType.Unknown,\n      setVersion: null,\n      electionId: null,\n      setName: null\n    };\n    // Update set information about the server instance\n    self.set[serverName].type = ServerType.Unknown;\n    self.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;\n    self.set[serverName].setName = ismaster ? ismaster.setName : ismaster;\n    self.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;\n\n    if (self.unknownServers.indexOf(server.name) === -1) {\n      self.unknownServers.push(serverName);\n    }\n\n    // Set the topology\n    return false;\n  }\n\n  // Update logicalSessionTimeoutMinutes\n  if (ismaster.logicalSessionTimeoutMinutes !== undefined && !isArbiter(ismaster)) {\n    if (\n      self.logicalSessionTimeoutMinutes === undefined ||\n      ismaster.logicalSessionTimeoutMinutes === null\n    ) {\n      self.logicalSessionTimeoutMinutes = ismaster.logicalSessionTimeoutMinutes;\n    } else {\n      self.logicalSessionTimeoutMinutes = Math.min(\n        self.logicalSessionTimeoutMinutes,\n        ismaster.logicalSessionTimeoutMinutes\n      );\n    }\n  }\n\n  //\n  // Is this a mongos\n  //\n  if (ismaster && ismaster.msg === 'isdbgrid') {\n    if (this.primary && this.primary.name === serverName) {\n      this.primary = null;\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    }\n\n    return false;\n  }\n\n  // A RSGhost instance\n  if (ismaster.isreplicaset) {\n    self.set[serverName] = {\n      type: ServerType.RSGhost,\n      setVersion: null,\n      electionId: null,\n      setName: ismaster.setName\n    };\n\n    if (this.primary && this.primary.name === serverName) {\n      this.primary = null;\n    }\n\n    // Set the topology\n    this.topologyType = this.primary\n      ? TopologyType.ReplicaSetWithPrimary\n      : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n\n    // Set the topology\n    return false;\n  }\n\n  // A RSOther instance\n  if (\n    (ismaster.setName && ismaster.hidden) ||\n    (ismaster.setName &&\n      !ismaster.ismaster &&\n      !ismaster.secondary &&\n      !ismaster.arbiterOnly &&\n      !ismaster.passive)\n  ) {\n    self.set[serverName] = {\n      type: ServerType.RSOther,\n      setVersion: null,\n      electionId: null,\n      setName: ismaster.setName\n    };\n\n    // Set the topology\n    this.topologyType = this.primary\n      ? TopologyType.ReplicaSetWithPrimary\n      : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    return false;\n  }\n\n  //\n  // Standalone server, destroy and return\n  //\n  if (ismaster && ismaster.ismaster && !ismaster.setName) {\n    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.Unknown;\n    this.remove(server, { force: true });\n    return false;\n  }\n\n  //\n  // Server in maintanance mode\n  //\n  if (ismaster && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) {\n    this.remove(server, { force: true });\n    return false;\n  }\n\n  //\n  // If the .me field does not match the passed in server\n  //\n  if (ismaster.me && ismaster.me.toLowerCase() !== serverName) {\n    if (this.logger.isWarn()) {\n      this.logger.warn(\n        f(\n          'the seedlist server was removed due to its address %s not matching its ismaster.me address %s',\n          server.name,\n          ismaster.me\n        )\n      );\n    }\n\n    // Delete from the set\n    delete this.set[serverName];\n    // Delete unknown servers\n    removeFrom(server, self.unknownServers);\n\n    // Destroy the instance\n    server.destroy({ force: true });\n\n    // Set the type of topology we have\n    if (this.primary && !this.primary.equals(server)) {\n      this.topologyType = TopologyType.ReplicaSetWithPrimary;\n    } else {\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    }\n\n    //\n    // We have a potential primary\n    //\n    if (!this.primary && ismaster.primary) {\n      this.set[ismaster.primary.toLowerCase()] = {\n        type: ServerType.PossiblePrimary,\n        setName: null,\n        electionId: null,\n        setVersion: null\n      };\n    }\n\n    return false;\n  }\n\n  //\n  // Primary handling\n  //\n  if (!this.primary && ismaster.ismaster && ismaster.setName) {\n    var ismasterElectionId = server.lastIsMaster().electionId;\n    if (this.setName && this.setName !== ismaster.setName) {\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n      return new MongoError(\n        f(\n          'setName from ismaster does not match provided connection setName [%s] != [%s]',\n          ismaster.setName,\n          this.setName\n        )\n      );\n    }\n\n    if (!this.maxElectionId && ismasterElectionId) {\n      this.maxElectionId = ismasterElectionId;\n    } else if (this.maxElectionId && ismasterElectionId) {\n      var result = compareObjectIds(this.maxElectionId, ismasterElectionId);\n      // Get the electionIds\n      var ismasterSetVersion = server.lastIsMaster().setVersion;\n\n      if (result === 1) {\n        this.topologyType = TopologyType.ReplicaSetNoPrimary;\n        return false;\n      } else if (result === 0 && ismasterSetVersion) {\n        if (ismasterSetVersion < this.maxSetVersion) {\n          this.topologyType = TopologyType.ReplicaSetNoPrimary;\n          return false;\n        }\n      }\n\n      this.maxSetVersion = ismasterSetVersion;\n      this.maxElectionId = ismasterElectionId;\n    }\n\n    // Hande normalization of server names\n    var normalizedHosts = ismaster.hosts.map(function(x) {\n      return x.toLowerCase();\n    });\n    var locationIndex = normalizedHosts.indexOf(serverName);\n\n    // Validate that the server exists in the host list\n    if (locationIndex !== -1) {\n      self.primary = server;\n      self.set[serverName] = {\n        type: ServerType.RSPrimary,\n        setVersion: ismaster.setVersion,\n        electionId: ismaster.electionId,\n        setName: ismaster.setName\n      };\n\n      // Set the topology\n      this.topologyType = TopologyType.ReplicaSetWithPrimary;\n      if (ismaster.setName) this.setName = ismaster.setName;\n      removeFrom(server, self.unknownServers);\n      removeFrom(server, self.secondaries);\n      removeFrom(server, self.passives);\n      self.emit('joined', 'primary', server);\n    } else {\n      this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    }\n\n    emitTopologyDescriptionChanged(self);\n    return true;\n  } else if (ismaster.ismaster && ismaster.setName) {\n    // Get the electionIds\n    var currentElectionId = self.set[self.primary.name.toLowerCase()].electionId;\n    var currentSetVersion = self.set[self.primary.name.toLowerCase()].setVersion;\n    var currentSetName = self.set[self.primary.name.toLowerCase()].setName;\n    ismasterElectionId = server.lastIsMaster().electionId;\n    ismasterSetVersion = server.lastIsMaster().setVersion;\n    var ismasterSetName = server.lastIsMaster().setName;\n\n    // Is it the same server instance\n    if (this.primary.equals(server) && currentSetName === ismasterSetName) {\n      return false;\n    }\n\n    // If we do not have the same rs name\n    if (currentSetName && currentSetName !== ismasterSetName) {\n      if (!this.primary.equals(server)) {\n        this.topologyType = TopologyType.ReplicaSetWithPrimary;\n      } else {\n        this.topologyType = TopologyType.ReplicaSetNoPrimary;\n      }\n\n      return false;\n    }\n\n    // Check if we need to replace the server\n    if (currentElectionId && ismasterElectionId) {\n      result = compareObjectIds(currentElectionId, ismasterElectionId);\n\n      if (result === 1) {\n        return false;\n      } else if (result === 0 && currentSetVersion > ismasterSetVersion) {\n        return false;\n      }\n    } else if (!currentElectionId && ismasterElectionId && ismasterSetVersion) {\n      if (ismasterSetVersion < this.maxSetVersion) {\n        return false;\n      }\n    }\n\n    if (!this.maxElectionId && ismasterElectionId) {\n      this.maxElectionId = ismasterElectionId;\n    } else if (this.maxElectionId && ismasterElectionId) {\n      result = compareObjectIds(this.maxElectionId, ismasterElectionId);\n\n      if (result === 1) {\n        return false;\n      } else if (result === 0 && currentSetVersion && ismasterSetVersion) {\n        if (ismasterSetVersion < this.maxSetVersion) {\n          return false;\n        }\n      } else {\n        if (ismasterSetVersion < this.maxSetVersion) {\n          return false;\n        }\n      }\n\n      this.maxElectionId = ismasterElectionId;\n      this.maxSetVersion = ismasterSetVersion;\n    } else {\n      this.maxSetVersion = ismasterSetVersion;\n    }\n\n    // Modify the entry to unknown\n    self.set[self.primary.name.toLowerCase()] = {\n      type: ServerType.Unknown,\n      setVersion: null,\n      electionId: null,\n      setName: null\n    };\n\n    // Signal primary left\n    self.emit('left', 'primary', this.primary);\n    // Destroy the instance\n    self.primary.destroy({ force: true });\n    // Set the new instance\n    self.primary = server;\n    // Set the set information\n    self.set[serverName] = {\n      type: ServerType.RSPrimary,\n      setVersion: ismaster.setVersion,\n      electionId: ismaster.electionId,\n      setName: ismaster.setName\n    };\n\n    // Set the topology\n    this.topologyType = TopologyType.ReplicaSetWithPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers);\n    removeFrom(server, self.secondaries);\n    removeFrom(server, self.passives);\n    self.emit('joined', 'primary', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  }\n\n  // A possible instance\n  if (!this.primary && ismaster.primary) {\n    self.set[ismaster.primary.toLowerCase()] = {\n      type: ServerType.PossiblePrimary,\n      setVersion: null,\n      electionId: null,\n      setName: null\n    };\n  }\n\n  //\n  // Secondary handling\n  //\n  if (\n    ismaster.secondary &&\n    ismaster.setName &&\n    !inList(ismaster, server, this.secondaries) &&\n    this.setName &&\n    this.setName === ismaster.setName\n  ) {\n    addToList(self, ServerType.RSSecondary, ismaster, server, this.secondaries);\n    // Set the topology\n    this.topologyType = this.primary\n      ? TopologyType.ReplicaSetWithPrimary\n      : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers);\n\n    // Remove primary\n    if (this.primary && this.primary.name.toLowerCase() === serverName) {\n      server.destroy({ force: true });\n      this.primary = null;\n      self.emit('left', 'primary', server);\n    }\n\n    // Emit secondary joined replicaset\n    self.emit('joined', 'secondary', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  }\n\n  //\n  // Arbiter handling\n  //\n  if (\n    isArbiter(ismaster) &&\n    !inList(ismaster, server, this.arbiters) &&\n    this.setName &&\n    this.setName === ismaster.setName\n  ) {\n    addToList(self, ServerType.RSArbiter, ismaster, server, this.arbiters);\n    // Set the topology\n    this.topologyType = this.primary\n      ? TopologyType.ReplicaSetWithPrimary\n      : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers);\n    self.emit('joined', 'arbiter', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  }\n\n  //\n  // Passive handling\n  //\n  if (\n    ismaster.passive &&\n    ismaster.setName &&\n    !inList(ismaster, server, this.passives) &&\n    this.setName &&\n    this.setName === ismaster.setName\n  ) {\n    addToList(self, ServerType.RSSecondary, ismaster, server, this.passives);\n    // Set the topology\n    this.topologyType = this.primary\n      ? TopologyType.ReplicaSetWithPrimary\n      : TopologyType.ReplicaSetNoPrimary;\n    if (ismaster.setName) this.setName = ismaster.setName;\n    removeFrom(server, self.unknownServers);\n\n    // Remove primary\n    if (this.primary && this.primary.name.toLowerCase() === serverName) {\n      server.destroy({ force: true });\n      this.primary = null;\n      self.emit('left', 'primary', server);\n    }\n\n    self.emit('joined', 'secondary', server);\n    emitTopologyDescriptionChanged(self);\n    return true;\n  }\n\n  //\n  // Remove the primary\n  //\n  if (this.set[serverName] && this.set[serverName].type === ServerType.RSPrimary) {\n    self.emit('left', 'primary', this.primary);\n    this.primary.destroy({ force: true });\n    this.primary = null;\n    this.topologyType = TopologyType.ReplicaSetNoPrimary;\n    return false;\n  }\n\n  this.topologyType = this.primary\n    ? TopologyType.ReplicaSetWithPrimary\n    : TopologyType.ReplicaSetNoPrimary;\n  return false;\n};\n\n/**\n * Recalculate single server max staleness\n * @method\n */\nReplSetState.prototype.updateServerMaxStaleness = function(server, haInterval) {\n  // Locate the max secondary lastwrite\n  var max = 0;\n  // Go over all secondaries\n  for (var i = 0; i < this.secondaries.length; i++) {\n    max = Math.max(max, this.secondaries[i].lastWriteDate);\n  }\n\n  // Perform this servers staleness calculation\n  if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary && this.hasPrimary()) {\n    server.staleness =\n      server.lastUpdateTime -\n      server.lastWriteDate -\n      (this.primary.lastUpdateTime - this.primary.lastWriteDate) +\n      haInterval;\n  } else if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary) {\n    server.staleness = max - server.lastWriteDate + haInterval;\n  }\n};\n\n/**\n * Recalculate all the staleness values for secodaries\n * @method\n */\nReplSetState.prototype.updateSecondariesMaxStaleness = function(haInterval) {\n  for (var i = 0; i < this.secondaries.length; i++) {\n    this.updateServerMaxStaleness(this.secondaries[i], haInterval);\n  }\n};\n\n/**\n * Pick a server by the passed in ReadPreference\n * @method\n * @param {ReadPreference} readPreference The ReadPreference instance to use\n */\nReplSetState.prototype.pickServer = function(readPreference) {\n  // If no read Preference set to primary by default\n  readPreference = readPreference || ReadPreference.primary;\n\n  // maxStalenessSeconds is not allowed with a primary read\n  if (readPreference.preference === 'primary' && readPreference.maxStalenessSeconds != null) {\n    return new MongoError('primary readPreference incompatible with maxStalenessSeconds');\n  }\n\n  // Check if we have any non compatible servers for maxStalenessSeconds\n  var allservers = this.primary ? [this.primary] : [];\n  allservers = allservers.concat(this.secondaries);\n\n  // Does any of the servers not support the right wire protocol version\n  // for maxStalenessSeconds when maxStalenessSeconds specified on readPreference. Then error out\n  if (readPreference.maxStalenessSeconds != null) {\n    for (var i = 0; i < allservers.length; i++) {\n      if (allservers[i].ismaster.maxWireVersion < 5) {\n        return new MongoError(\n          'maxStalenessSeconds not supported by at least one of the replicaset members'\n        );\n      }\n    }\n  }\n\n  // Do we have the nearest readPreference\n  if (readPreference.preference === 'nearest' && readPreference.maxStalenessSeconds == null) {\n    return pickNearest(this, readPreference);\n  } else if (\n    readPreference.preference === 'nearest' &&\n    readPreference.maxStalenessSeconds != null\n  ) {\n    return pickNearestMaxStalenessSeconds(this, readPreference);\n  }\n\n  // Get all the secondaries\n  var secondaries = this.secondaries;\n\n  // Check if we can satisfy and of the basic read Preferences\n  if (readPreference.equals(ReadPreference.secondary) && secondaries.length === 0) {\n    return new MongoError('no secondary server available');\n  }\n\n  if (\n    readPreference.equals(ReadPreference.secondaryPreferred) &&\n    secondaries.length === 0 &&\n    this.primary == null\n  ) {\n    return new MongoError('no secondary or primary server available');\n  }\n\n  if (readPreference.equals(ReadPreference.primary) && this.primary == null) {\n    return new MongoError('no primary server available');\n  }\n\n  // Secondary preferred or just secondaries\n  if (\n    readPreference.equals(ReadPreference.secondaryPreferred) ||\n    readPreference.equals(ReadPreference.secondary)\n  ) {\n    if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {\n      // Pick nearest of any other servers available\n      var server = pickNearest(this, readPreference);\n      // No server in the window return primary\n      if (server) {\n        return server;\n      }\n    } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {\n      // Pick nearest of any other servers available\n      server = pickNearestMaxStalenessSeconds(this, readPreference);\n      // No server in the window return primary\n      if (server) {\n        return server;\n      }\n    }\n\n    if (readPreference.equals(ReadPreference.secondaryPreferred)) {\n      return this.primary;\n    }\n\n    return null;\n  }\n\n  // Primary preferred\n  if (readPreference.equals(ReadPreference.primaryPreferred)) {\n    server = null;\n\n    // We prefer the primary if it's available\n    if (this.primary) {\n      return this.primary;\n    }\n\n    // Pick a secondary\n    if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {\n      server = pickNearest(this, readPreference);\n    } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {\n      server = pickNearestMaxStalenessSeconds(this, readPreference);\n    }\n\n    //  Did we find a server\n    if (server) return server;\n  }\n\n  // Return the primary\n  return this.primary;\n};\n\n//\n// Filter serves by tags\nvar filterByTags = function(readPreference, servers) {\n  if (readPreference.tags == null) return servers;\n  var filteredServers = [];\n  var tagsArray = Array.isArray(readPreference.tags) ? readPreference.tags : [readPreference.tags];\n\n  // Iterate over the tags\n  for (var j = 0; j < tagsArray.length; j++) {\n    var tags = tagsArray[j];\n\n    // Iterate over all the servers\n    for (var i = 0; i < servers.length; i++) {\n      var serverTag = servers[i].lastIsMaster().tags || {};\n\n      // Did we find the a matching server\n      var found = true;\n      // Check if the server is valid\n      for (var name in tags) {\n        if (serverTag[name] !== tags[name]) {\n          found = false;\n        }\n      }\n\n      // Add to candidate list\n      if (found) {\n        filteredServers.push(servers[i]);\n      }\n    }\n  }\n\n  // Returned filtered servers\n  return filteredServers;\n};\n\nfunction pickNearestMaxStalenessSeconds(self, readPreference) {\n  // Only get primary and secondaries as seeds\n  var servers = [];\n\n  // Get the maxStalenessMS\n  var maxStalenessMS = readPreference.maxStalenessSeconds * 1000;\n\n  // Check if the maxStalenessMS > 90 seconds\n  if (maxStalenessMS < 90 * 1000) {\n    return new MongoError('maxStalenessSeconds must be set to at least 90 seconds');\n  }\n\n  // Add primary to list if not a secondary read preference\n  if (\n    self.primary &&\n    readPreference.preference !== 'secondary' &&\n    readPreference.preference !== 'secondaryPreferred'\n  ) {\n    servers.push(self.primary);\n  }\n\n  // Add all the secondaries\n  for (var i = 0; i < self.secondaries.length; i++) {\n    servers.push(self.secondaries[i]);\n  }\n\n  // If we have a secondaryPreferred readPreference and no server add the primary\n  if (self.primary && servers.length === 0 && readPreference.preference !== 'secondaryPreferred') {\n    servers.push(self.primary);\n  }\n\n  // Filter by tags\n  servers = filterByTags(readPreference, servers);\n\n  // Filter by latency\n  servers = servers.filter(function(s) {\n    return s.staleness <= maxStalenessMS;\n  });\n\n  // Sort by time\n  servers.sort(function(a, b) {\n    return a.lastIsMasterMS - b.lastIsMasterMS;\n  });\n\n  // No servers, default to primary\n  if (servers.length === 0) {\n    return null;\n  }\n\n  // Ensure index does not overflow the number of available servers\n  self.index = self.index % servers.length;\n\n  // Get the server\n  var server = servers[self.index];\n  // Add to the index\n  self.index = self.index + 1;\n  // Return the first server of the sorted and filtered list\n  return server;\n}\n\nfunction pickNearest(self, readPreference) {\n  // Only get primary and secondaries as seeds\n  var servers = [];\n\n  // Add primary to list if not a secondary read preference\n  if (\n    self.primary &&\n    readPreference.preference !== 'secondary' &&\n    readPreference.preference !== 'secondaryPreferred'\n  ) {\n    servers.push(self.primary);\n  }\n\n  // Add all the secondaries\n  for (var i = 0; i < self.secondaries.length; i++) {\n    servers.push(self.secondaries[i]);\n  }\n\n  // If we have a secondaryPreferred readPreference and no server add the primary\n  if (servers.length === 0 && self.primary && readPreference.preference !== 'secondaryPreferred') {\n    servers.push(self.primary);\n  }\n\n  // Filter by tags\n  servers = filterByTags(readPreference, servers);\n\n  // Sort by time\n  servers.sort(function(a, b) {\n    return a.lastIsMasterMS - b.lastIsMasterMS;\n  });\n\n  // Locate lowest time (picked servers are lowest time + acceptable Latency margin)\n  var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0;\n\n  // Filter by latency\n  servers = servers.filter(function(s) {\n    return s.lastIsMasterMS <= lowest + self.acceptableLatency;\n  });\n\n  // No servers, default to primary\n  if (servers.length === 0) {\n    return null;\n  }\n\n  // Ensure index does not overflow the number of available servers\n  self.index = self.index % servers.length;\n  // Get the server\n  var server = servers[self.index];\n  // Add to the index\n  self.index = self.index + 1;\n  // Return the first server of the sorted and filtered list\n  return server;\n}\n\nfunction inList(ismaster, server, list) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i] && list[i].name && list[i].name.toLowerCase() === server.name.toLowerCase())\n      return true;\n  }\n\n  return false;\n}\n\nfunction addToList(self, type, ismaster, server, list) {\n  var serverName = server.name.toLowerCase();\n  // Update set information about the server instance\n  self.set[serverName].type = type;\n  self.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;\n  self.set[serverName].setName = ismaster ? ismaster.setName : ismaster;\n  self.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;\n  // Add to the list\n  list.push(server);\n}\n\nfunction compareObjectIds(id1, id2) {\n  var a = Buffer.from(id1.toHexString(), 'hex');\n  var b = Buffer.from(id2.toHexString(), 'hex');\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (typeof Buffer.compare === 'function') {\n    return Buffer.compare(a, b);\n  }\n\n  var x = a.length;\n  var y = b.length;\n  var len = Math.min(x, y);\n\n  for (var i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      break;\n    }\n  }\n\n  if (i !== len) {\n    x = a[i];\n    y = b[i];\n  }\n\n  return x < y ? -1 : y < x ? 1 : 0;\n}\n\nfunction removeFrom(server, list) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i].equals && list[i].equals(server)) {\n      list.splice(i, 1);\n      return true;\n    } else if (typeof list[i] === 'string' && list[i].toLowerCase() === server.name.toLowerCase()) {\n      list.splice(i, 1);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction emitTopologyDescriptionChanged(self) {\n  if (self.listeners('topologyDescriptionChanged').length > 0) {\n    var topology = 'Unknown';\n    var setName = self.setName;\n\n    if (self.hasPrimaryAndSecondary()) {\n      topology = 'ReplicaSetWithPrimary';\n    } else if (!self.hasPrimary() && self.hasSecondary()) {\n      topology = 'ReplicaSetNoPrimary';\n    }\n\n    // Generate description\n    var description = {\n      topologyType: topology,\n      setName: setName,\n      servers: []\n    };\n\n    // Add the primary to the list\n    if (self.hasPrimary()) {\n      var desc = self.primary.getDescription();\n      desc.type = 'RSPrimary';\n      description.servers.push(desc);\n    }\n\n    // Add all the secondaries\n    description.servers = description.servers.concat(\n      self.secondaries.map(function(x) {\n        var description = x.getDescription();\n        description.type = 'RSSecondary';\n        return description;\n      })\n    );\n\n    // Add all the arbiters\n    description.servers = description.servers.concat(\n      self.arbiters.map(function(x) {\n        var description = x.getDescription();\n        description.type = 'RSArbiter';\n        return description;\n      })\n    );\n\n    // Add all the passives\n    description.servers = description.servers.concat(\n      self.passives.map(function(x) {\n        var description = x.getDescription();\n        description.type = 'RSSecondary';\n        return description;\n      })\n    );\n\n    // Get the diff\n    var diffResult = diff(self.replicasetDescription, description);\n\n    // Create the result\n    var result = {\n      topologyId: self.id,\n      previousDescription: self.replicasetDescription,\n      newDescription: description,\n      diff: diffResult\n    };\n\n    // Emit the topologyDescription change\n    // if(diffResult.servers.length > 0) {\n    self.emit('topologyDescriptionChanged', result);\n    // }\n\n    // Set the new description\n    self.replicasetDescription = description;\n  }\n}\n\nmodule.exports = ReplSetState;\n"]},"metadata":{},"sourceType":"script"}