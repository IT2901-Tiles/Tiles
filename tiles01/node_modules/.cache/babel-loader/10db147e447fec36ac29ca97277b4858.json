{"ast":null,"code":"'use strict';\n\nconst CommandOperationV2 = require('./command_v2');\n\nconst Aspect = require('./operation').Aspect;\n\nconst defineAspects = require('./operation').defineAspects;\n\nconst maxWireVersion = require('../core/utils').maxWireVersion;\n\nconst CONSTANTS = require('../constants');\n\nconst LIST_COLLECTIONS_WIRE_VERSION = 3;\n\nfunction listCollectionsTransforms(databaseName) {\n  const matching = `${databaseName}.`;\n  return {\n    doc: doc => {\n      const index = doc.name.indexOf(matching); // Remove database name if available\n\n      if (doc.name && index === 0) {\n        doc.name = doc.name.substr(index + matching.length);\n      }\n\n      return doc;\n    }\n  };\n}\n\nclass ListCollectionsOperation extends CommandOperationV2 {\n  constructor(db, filter, options) {\n    super(db, options, {\n      fullResponse: true\n    });\n    this.db = db;\n    this.filter = filter;\n    this.nameOnly = !!this.options.nameOnly;\n\n    if (typeof this.options.batchSize === 'number') {\n      this.batchSize = this.options.batchSize;\n    }\n  }\n\n  execute(server, callback) {\n    if (maxWireVersion(server) < LIST_COLLECTIONS_WIRE_VERSION) {\n      let filter = this.filter;\n      const databaseName = this.db.s.namespace.db; // If we have legacy mode and have not provided a full db name filter it\n\n      if (typeof filter.name === 'string' && !new RegExp('^' + databaseName + '\\\\.').test(filter.name)) {\n        filter = Object.assign({}, filter);\n        filter.name = this.db.s.namespace.withCollection(filter.name).toString();\n      } // No filter, filter by current database\n\n\n      if (filter == null) {\n        filter.name = `/${databaseName}/`;\n      } // Rewrite the filter to use $and to filter out indexes\n\n\n      if (filter.name) {\n        filter = {\n          $and: [{\n            name: filter.name\n          }, {\n            name: /^((?!\\$).)*$/\n          }]\n        };\n      } else {\n        filter = {\n          name: /^((?!\\$).)*$/\n        };\n      }\n\n      const transforms = listCollectionsTransforms(databaseName);\n      server.query(`${databaseName}.${CONSTANTS.SYSTEM_NAMESPACE_COLLECTION}`, {\n        query: filter\n      }, {\n        batchSize: this.batchSize || 1000\n      }, {}, (err, result) => {\n        if (result && result.message && result.message.documents && Array.isArray(result.message.documents)) {\n          result.message.documents = result.message.documents.map(transforms.doc);\n        }\n\n        callback(err, result);\n      });\n      return;\n    }\n\n    const command = {\n      listCollections: 1,\n      filter: this.filter,\n      cursor: this.batchSize ? {\n        batchSize: this.batchSize\n      } : {},\n      nameOnly: this.nameOnly\n    };\n    return super.executeCommand(server, command, callback);\n  }\n\n}\n\ndefineAspects(ListCollectionsOperation, [Aspect.READ_OPERATION, Aspect.RETRYABLE, Aspect.EXECUTE_WITH_SELECTION]);\nmodule.exports = ListCollectionsOperation;","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/operations/list_collections.js"],"names":["CommandOperationV2","require","Aspect","defineAspects","maxWireVersion","CONSTANTS","LIST_COLLECTIONS_WIRE_VERSION","listCollectionsTransforms","databaseName","matching","doc","index","name","indexOf","substr","length","ListCollectionsOperation","constructor","db","filter","options","fullResponse","nameOnly","batchSize","execute","server","callback","s","namespace","RegExp","test","Object","assign","withCollection","toString","$and","transforms","query","SYSTEM_NAMESPACE_COLLECTION","err","result","message","documents","Array","isArray","map","command","listCollections","cursor","executeCommand","READ_OPERATION","RETRYABLE","EXECUTE_WITH_SELECTION","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst CommandOperationV2 = require('./command_v2');\nconst Aspect = require('./operation').Aspect;\nconst defineAspects = require('./operation').defineAspects;\nconst maxWireVersion = require('../core/utils').maxWireVersion;\nconst CONSTANTS = require('../constants');\n\nconst LIST_COLLECTIONS_WIRE_VERSION = 3;\n\nfunction listCollectionsTransforms(databaseName) {\n  const matching = `${databaseName}.`;\n\n  return {\n    doc: doc => {\n      const index = doc.name.indexOf(matching);\n      // Remove database name if available\n      if (doc.name && index === 0) {\n        doc.name = doc.name.substr(index + matching.length);\n      }\n\n      return doc;\n    }\n  };\n}\n\nclass ListCollectionsOperation extends CommandOperationV2 {\n  constructor(db, filter, options) {\n    super(db, options, { fullResponse: true });\n\n    this.db = db;\n    this.filter = filter;\n    this.nameOnly = !!this.options.nameOnly;\n\n    if (typeof this.options.batchSize === 'number') {\n      this.batchSize = this.options.batchSize;\n    }\n  }\n\n  execute(server, callback) {\n    if (maxWireVersion(server) < LIST_COLLECTIONS_WIRE_VERSION) {\n      let filter = this.filter;\n      const databaseName = this.db.s.namespace.db;\n\n      // If we have legacy mode and have not provided a full db name filter it\n      if (\n        typeof filter.name === 'string' &&\n        !new RegExp('^' + databaseName + '\\\\.').test(filter.name)\n      ) {\n        filter = Object.assign({}, filter);\n        filter.name = this.db.s.namespace.withCollection(filter.name).toString();\n      }\n\n      // No filter, filter by current database\n      if (filter == null) {\n        filter.name = `/${databaseName}/`;\n      }\n\n      // Rewrite the filter to use $and to filter out indexes\n      if (filter.name) {\n        filter = { $and: [{ name: filter.name }, { name: /^((?!\\$).)*$/ }] };\n      } else {\n        filter = { name: /^((?!\\$).)*$/ };\n      }\n\n      const transforms = listCollectionsTransforms(databaseName);\n      server.query(\n        `${databaseName}.${CONSTANTS.SYSTEM_NAMESPACE_COLLECTION}`,\n        { query: filter },\n        { batchSize: this.batchSize || 1000 },\n        {},\n        (err, result) => {\n          if (\n            result &&\n            result.message &&\n            result.message.documents &&\n            Array.isArray(result.message.documents)\n          ) {\n            result.message.documents = result.message.documents.map(transforms.doc);\n          }\n\n          callback(err, result);\n        }\n      );\n\n      return;\n    }\n\n    const command = {\n      listCollections: 1,\n      filter: this.filter,\n      cursor: this.batchSize ? { batchSize: this.batchSize } : {},\n      nameOnly: this.nameOnly\n    };\n\n    return super.executeCommand(server, command, callback);\n  }\n}\n\ndefineAspects(ListCollectionsOperation, [\n  Aspect.READ_OPERATION,\n  Aspect.RETRYABLE,\n  Aspect.EXECUTE_WITH_SELECTION\n]);\n\nmodule.exports = ListCollectionsOperation;\n"]},"metadata":{},"sourceType":"script"}