{"ast":null,"code":"'use strict';\n\nconst Duplex = require('stream').Duplex;\n\nconst BufferList = require('bl');\n\nconst MongoParseError = require('../core/error').MongoParseError;\n\nconst decompress = require('../core/wireprotocol/compression').decompress;\n\nconst Response = require('../core/connection/commands').Response;\n\nconst BinMsg = require('../core/connection/msg').BinMsg;\n\nconst MongoError = require('../core/error').MongoError;\n\nconst OP_COMPRESSED = require('../core/wireprotocol/shared').opcodes.OP_COMPRESSED;\n\nconst OP_MSG = require('../core/wireprotocol/shared').opcodes.OP_MSG;\n\nconst MESSAGE_HEADER_SIZE = require('../core/wireprotocol/shared').MESSAGE_HEADER_SIZE;\n\nconst COMPRESSION_DETAILS_SIZE = require('../core/wireprotocol/shared').COMPRESSION_DETAILS_SIZE;\n\nconst opcodes = require('../core/wireprotocol/shared').opcodes;\n\nconst compress = require('../core/wireprotocol/compression').compress;\n\nconst compressorIDs = require('../core/wireprotocol/compression').compressorIDs;\n\nconst uncompressibleCommands = require('../core/wireprotocol/compression').uncompressibleCommands;\n\nconst Msg = require('../core/connection/msg').Msg;\n\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\nconst kBuffer = Symbol('buffer');\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n */\n\nclass MessageStream extends Duplex {\n  constructor(options) {\n    options = options || {};\n    super(options);\n    this.bson = options.bson;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n    this[kBuffer] = new BufferList();\n  }\n\n  _write(chunk, _, callback) {\n    const buffer = this[kBuffer];\n    buffer.append(chunk);\n    processIncomingData(this, callback);\n  }\n\n  _read()\n  /* size */\n  {\n    // NOTE: This implementation is empty because we explicitly push data to be read\n    //       when `writeMessage` is called.\n    return;\n  }\n\n  writeCommand(command, operationDescription) {\n    // TODO: agreed compressor should live in `StreamDescription`\n    const shouldCompress = operationDescription && !!operationDescription.agreedCompressor;\n\n    if (!shouldCompress || !canCompress(command)) {\n      const data = command.toBin();\n      this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n      return;\n    } // otherwise, compress the message\n\n\n    const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE); // Extract information needed for OP_COMPRESSED from the uncompressed message\n\n    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12); // Compress the message body\n\n    compress({\n      options: operationDescription\n    }, messageToBeCompressed, (err, compressedMessage) => {\n      if (err) {\n        operationDescription.cb(err, null);\n        return;\n      } // Create the msgHeader of OP_COMPRESSED\n\n\n      const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n      msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n\n      msgHeader.writeInt32LE(command.requestId, 4); // requestID\n\n      msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n\n      msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\n      // Create the compression details of OP_COMPRESSED\n\n      const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n      compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n\n      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n\n      compressionDetails.writeUInt8(compressorIDs[operationDescription.agreedCompressor], 8); // compressorID\n\n      this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n    });\n  }\n\n} // Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\n\n\nfunction canCompress(command) {\n  const commandDoc = command instanceof Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !uncompressibleCommands.has(commandName);\n}\n\nfunction processIncomingData(stream, callback) {\n  const buffer = stream[kBuffer];\n\n  if (buffer.length < 4) {\n    callback();\n    return;\n  }\n\n  const sizeOfMessage = buffer.readInt32LE(0);\n\n  if (sizeOfMessage < 0) {\n    callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n    return;\n  }\n\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\n    callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));\n    return;\n  }\n\n  if (sizeOfMessage > buffer.length) {\n    callback();\n    return;\n  }\n\n  const message = buffer.slice(0, sizeOfMessage);\n  buffer.consume(sizeOfMessage);\n  const messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n  let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  const responseOptions = stream.responseOptions;\n\n  if (messageHeader.opCode !== OP_COMPRESSED) {\n    const messageBody = message.slice(MESSAGE_HEADER_SIZE);\n    stream.emit('message', new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n\n    return;\n  }\n\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9); // recalculate based on wrapped opcode\n\n  ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  decompress(compressorID, compressedBuffer, (err, messageBody) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (messageBody.length !== messageHeader.length) {\n      callback(new MongoError('Decompressing a compressed message from the server failed. The message is corrupt.'));\n      return;\n    }\n\n    stream.emit('message', new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n  });\n}\n\nmodule.exports = MessageStream;","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/cmap/message_stream.js"],"names":["Duplex","require","BufferList","MongoParseError","decompress","Response","BinMsg","MongoError","OP_COMPRESSED","opcodes","OP_MSG","MESSAGE_HEADER_SIZE","COMPRESSION_DETAILS_SIZE","compress","compressorIDs","uncompressibleCommands","Msg","kDefaultMaxBsonMessageSize","kBuffer","Symbol","MessageStream","constructor","options","bson","maxBsonMessageSize","_write","chunk","_","callback","buffer","append","processIncomingData","_read","writeCommand","command","operationDescription","shouldCompress","agreedCompressor","canCompress","data","toBin","push","Array","isArray","Buffer","concat","concatenatedOriginalCommandBuffer","messageToBeCompressed","slice","originalCommandOpCode","readInt32LE","err","compressedMessage","cb","msgHeader","alloc","writeInt32LE","length","requestId","compressionDetails","writeUInt8","commandDoc","query","commandName","Object","keys","has","stream","sizeOfMessage","message","consume","messageHeader","responseTo","opCode","ResponseType","responseOptions","messageBody","emit","fromCompressed","compressorID","compressedBuffer","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Duplex = require('stream').Duplex;\nconst BufferList = require('bl');\nconst MongoParseError = require('../core/error').MongoParseError;\nconst decompress = require('../core/wireprotocol/compression').decompress;\nconst Response = require('../core/connection/commands').Response;\nconst BinMsg = require('../core/connection/msg').BinMsg;\nconst MongoError = require('../core/error').MongoError;\nconst OP_COMPRESSED = require('../core/wireprotocol/shared').opcodes.OP_COMPRESSED;\nconst OP_MSG = require('../core/wireprotocol/shared').opcodes.OP_MSG;\nconst MESSAGE_HEADER_SIZE = require('../core/wireprotocol/shared').MESSAGE_HEADER_SIZE;\nconst COMPRESSION_DETAILS_SIZE = require('../core/wireprotocol/shared').COMPRESSION_DETAILS_SIZE;\nconst opcodes = require('../core/wireprotocol/shared').opcodes;\nconst compress = require('../core/wireprotocol/compression').compress;\nconst compressorIDs = require('../core/wireprotocol/compression').compressorIDs;\nconst uncompressibleCommands = require('../core/wireprotocol/compression').uncompressibleCommands;\nconst Msg = require('../core/connection/msg').Msg;\n\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\nconst kBuffer = Symbol('buffer');\n\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n */\nclass MessageStream extends Duplex {\n  constructor(options) {\n    options = options || {};\n    super(options);\n\n    this.bson = options.bson;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n\n    this[kBuffer] = new BufferList();\n  }\n\n  _write(chunk, _, callback) {\n    const buffer = this[kBuffer];\n    buffer.append(chunk);\n\n    processIncomingData(this, callback);\n  }\n\n  _read(/* size */) {\n    // NOTE: This implementation is empty because we explicitly push data to be read\n    //       when `writeMessage` is called.\n    return;\n  }\n\n  writeCommand(command, operationDescription) {\n    // TODO: agreed compressor should live in `StreamDescription`\n    const shouldCompress = operationDescription && !!operationDescription.agreedCompressor;\n    if (!shouldCompress || !canCompress(command)) {\n      const data = command.toBin();\n      this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n      return;\n    }\n\n    // otherwise, compress the message\n    const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\n\n    // Extract information needed for OP_COMPRESSED from the uncompressed message\n    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\n\n    // Compress the message body\n    compress({ options: operationDescription }, messageToBeCompressed, (err, compressedMessage) => {\n      if (err) {\n        operationDescription.cb(err, null);\n        return;\n      }\n\n      // Create the msgHeader of OP_COMPRESSED\n      const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n      msgHeader.writeInt32LE(\n        MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length,\n        0\n      ); // messageLength\n      msgHeader.writeInt32LE(command.requestId, 4); // requestID\n      msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n      msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\n\n      // Create the compression details of OP_COMPRESSED\n      const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n      compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n      compressionDetails.writeUInt8(compressorIDs[operationDescription.agreedCompressor], 8); // compressorID\n\n      this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n    });\n  }\n}\n\n// Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\nfunction canCompress(command) {\n  const commandDoc = command instanceof Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !uncompressibleCommands.has(commandName);\n}\n\nfunction processIncomingData(stream, callback) {\n  const buffer = stream[kBuffer];\n  if (buffer.length < 4) {\n    callback();\n    return;\n  }\n\n  const sizeOfMessage = buffer.readInt32LE(0);\n  if (sizeOfMessage < 0) {\n    callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n    return;\n  }\n\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\n    callback(\n      new MongoParseError(\n        `Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`\n      )\n    );\n    return;\n  }\n\n  if (sizeOfMessage > buffer.length) {\n    callback();\n    return;\n  }\n\n  const message = buffer.slice(0, sizeOfMessage);\n  buffer.consume(sizeOfMessage);\n\n  const messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n\n  let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  const responseOptions = stream.responseOptions;\n  if (messageHeader.opCode !== OP_COMPRESSED) {\n    const messageBody = message.slice(MESSAGE_HEADER_SIZE);\n    stream.emit(\n      'message',\n      new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions)\n    );\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n\n    return;\n  }\n\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);\n\n  // recalculate based on wrapped opcode\n  ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n\n  decompress(compressorID, compressedBuffer, (err, messageBody) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (messageBody.length !== messageHeader.length) {\n      callback(\n        new MongoError(\n          'Decompressing a compressed message from the server failed. The message is corrupt.'\n        )\n      );\n\n      return;\n    }\n\n    stream.emit(\n      'message',\n      new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions)\n    );\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n  });\n}\n\nmodule.exports = MessageStream;\n"]},"metadata":{},"sourceType":"script"}