{"ast":null,"code":"'use strict';\n\nconst Msg = require('../connection/msg').Msg;\n\nconst KillCursor = require('../connection/commands').KillCursor;\n\nconst GetMore = require('../connection/commands').GetMore;\n\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs;\n/** Commands that we want to redact because of the sensitive nature of their contents */\n\n\nconst SENSITIVE_COMMANDS = new Set(['authenticate', 'saslStart', 'saslContinue', 'getnonce', 'createUser', 'updateUser', 'copydbgetnonce', 'copydbsaslstart', 'copydb']); // helper methods\n\nconst extractCommandName = commandDoc => Object.keys(commandDoc)[0];\n\nconst namespace = command => command.ns;\n\nconst databaseName = command => command.ns.split('.')[0];\n\nconst collectionName = command => command.ns.split('.')[1];\n\nconst generateConnectionId = pool => pool.options ? `${pool.options.host}:${pool.options.port}` : pool.address;\n\nconst maybeRedact = (commandName, result) => SENSITIVE_COMMANDS.has(commandName) ? {} : result;\n\nconst isLegacyPool = pool => pool.s && pool.queue;\n\nconst LEGACY_FIND_QUERY_MAP = {\n  $query: 'filter',\n  $orderby: 'sort',\n  $hint: 'hint',\n  $comment: 'comment',\n  $maxScan: 'maxScan',\n  $max: 'max',\n  $min: 'min',\n  $returnKey: 'returnKey',\n  $showDiskLoc: 'showRecordId',\n  $maxTimeMS: 'maxTimeMS',\n  $snapshot: 'snapshot'\n};\nconst LEGACY_FIND_OPTIONS_MAP = {\n  numberToSkip: 'skip',\n  numberToReturn: 'batchSize',\n  returnFieldsSelector: 'projection'\n};\nconst OP_QUERY_KEYS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial', 'exhaust'];\n/**\n * Extract the actual command from the query, possibly upconverting if it's a legacy\n * format\n *\n * @param {Object} command the command\n */\n\nconst extractCommand = command => {\n  if (command instanceof GetMore) {\n    return {\n      getMore: command.cursorId,\n      collection: collectionName(command),\n      batchSize: command.numberToReturn\n    };\n  }\n\n  if (command instanceof KillCursor) {\n    return {\n      killCursors: collectionName(command),\n      cursors: command.cursorIds\n    };\n  }\n\n  if (command instanceof Msg) {\n    return command.command;\n  }\n\n  if (command.query && command.query.$query) {\n    let result;\n\n    if (command.ns === 'admin.$cmd') {\n      // upconvert legacy command\n      result = Object.assign({}, command.query.$query);\n    } else {\n      // upconvert legacy find command\n      result = {\n        find: collectionName(command)\n      };\n      Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => {\n        if (typeof command.query[key] !== 'undefined') result[LEGACY_FIND_QUERY_MAP[key]] = command.query[key];\n      });\n    }\n\n    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => {\n      if (typeof command[key] !== 'undefined') result[LEGACY_FIND_OPTIONS_MAP[key]] = command[key];\n    });\n    OP_QUERY_KEYS.forEach(key => {\n      if (command[key]) result[key] = command[key];\n    });\n\n    if (typeof command.pre32Limit !== 'undefined') {\n      result.limit = command.pre32Limit;\n    }\n\n    if (command.query.$explain) {\n      return {\n        explain: result\n      };\n    }\n\n    return result;\n  }\n\n  return command.query ? command.query : command;\n};\n\nconst extractReply = (command, reply) => {\n  if (command instanceof GetMore) {\n    return {\n      ok: 1,\n      cursor: {\n        id: reply.message.cursorId,\n        ns: namespace(command),\n        nextBatch: reply.message.documents\n      }\n    };\n  }\n\n  if (command instanceof KillCursor) {\n    return {\n      ok: 1,\n      cursorsUnknown: command.cursorIds\n    };\n  } // is this a legacy find command?\n\n\n  if (command.query && typeof command.query.$query !== 'undefined') {\n    return {\n      ok: 1,\n      cursor: {\n        id: reply.message.cursorId,\n        ns: namespace(command),\n        firstBatch: reply.message.documents\n      }\n    };\n  }\n\n  return reply && reply.result ? reply.result : reply;\n};\n\nconst extractConnectionDetails = pool => {\n  if (isLegacyPool(pool)) {\n    return {\n      connectionId: generateConnectionId(pool)\n    };\n  } // APM in the modern pool is done at the `Connection` level, so we rename it here for\n  // readability.\n\n\n  const connection = pool;\n  return {\n    address: connection.address,\n    connectionId: connection.id\n  };\n};\n/** An event indicating the start of a given command */\n\n\nclass CommandStartedEvent {\n  /**\n   * Create a started event\n   *\n   * @param {Pool} pool the pool that originated the command\n   * @param {Object} command the command\n   */\n  constructor(pool, command) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const connectionDetails = extractConnectionDetails(pool); // NOTE: remove in major revision, this is not spec behavior\n\n    if (SENSITIVE_COMMANDS.has(commandName)) {\n      this.commandObj = {};\n      this.commandObj[commandName] = true;\n    }\n\n    Object.assign(this, connectionDetails, {\n      requestId: command.requestId,\n      databaseName: databaseName(command),\n      commandName,\n      command: cmd\n    });\n  }\n\n}\n/** An event indicating the success of a given command */\n\n\nclass CommandSucceededEvent {\n  /**\n   * Create a succeeded event\n   *\n   * @param {Pool} pool the pool that originated the command\n   * @param {Object} command the command\n   * @param {Object} reply the reply for this command from the server\n   * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(pool, command, reply, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const connectionDetails = extractConnectionDetails(pool);\n    Object.assign(this, connectionDetails, {\n      requestId: command.requestId,\n      commandName,\n      duration: calculateDurationInMs(started),\n      reply: maybeRedact(commandName, extractReply(command, reply))\n    });\n  }\n\n}\n/** An event indicating the failure of a given command */\n\n\nclass CommandFailedEvent {\n  /**\n   * Create a failure event\n   *\n   * @param {Pool} pool the pool that originated the command\n   * @param {Object} command the command\n   * @param {MongoError|Object} error the generated error or a server error response\n   * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(pool, command, error, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const connectionDetails = extractConnectionDetails(pool);\n    Object.assign(this, connectionDetails, {\n      requestId: command.requestId,\n      commandName,\n      duration: calculateDurationInMs(started),\n      failure: maybeRedact(commandName, error)\n    });\n  }\n\n}\n\nmodule.exports = {\n  CommandStartedEvent,\n  CommandSucceededEvent,\n  CommandFailedEvent\n};","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/core/connection/apm.js"],"names":["Msg","require","KillCursor","GetMore","calculateDurationInMs","SENSITIVE_COMMANDS","Set","extractCommandName","commandDoc","Object","keys","namespace","command","ns","databaseName","split","collectionName","generateConnectionId","pool","options","host","port","address","maybeRedact","commandName","result","has","isLegacyPool","s","queue","LEGACY_FIND_QUERY_MAP","$query","$orderby","$hint","$comment","$maxScan","$max","$min","$returnKey","$showDiskLoc","$maxTimeMS","$snapshot","LEGACY_FIND_OPTIONS_MAP","numberToSkip","numberToReturn","returnFieldsSelector","OP_QUERY_KEYS","extractCommand","getMore","cursorId","collection","batchSize","killCursors","cursors","cursorIds","query","assign","find","forEach","key","pre32Limit","limit","$explain","explain","extractReply","reply","ok","cursor","id","message","nextBatch","documents","cursorsUnknown","firstBatch","extractConnectionDetails","connectionId","connection","CommandStartedEvent","constructor","cmd","connectionDetails","commandObj","requestId","CommandSucceededEvent","started","duration","CommandFailedEvent","error","failure","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst Msg = require('../connection/msg').Msg;\nconst KillCursor = require('../connection/commands').KillCursor;\nconst GetMore = require('../connection/commands').GetMore;\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs;\n\n/** Commands that we want to redact because of the sensitive nature of their contents */\nconst SENSITIVE_COMMANDS = new Set([\n  'authenticate',\n  'saslStart',\n  'saslContinue',\n  'getnonce',\n  'createUser',\n  'updateUser',\n  'copydbgetnonce',\n  'copydbsaslstart',\n  'copydb'\n]);\n\n// helper methods\nconst extractCommandName = commandDoc => Object.keys(commandDoc)[0];\nconst namespace = command => command.ns;\nconst databaseName = command => command.ns.split('.')[0];\nconst collectionName = command => command.ns.split('.')[1];\nconst generateConnectionId = pool =>\n  pool.options ? `${pool.options.host}:${pool.options.port}` : pool.address;\nconst maybeRedact = (commandName, result) => (SENSITIVE_COMMANDS.has(commandName) ? {} : result);\nconst isLegacyPool = pool => pool.s && pool.queue;\n\nconst LEGACY_FIND_QUERY_MAP = {\n  $query: 'filter',\n  $orderby: 'sort',\n  $hint: 'hint',\n  $comment: 'comment',\n  $maxScan: 'maxScan',\n  $max: 'max',\n  $min: 'min',\n  $returnKey: 'returnKey',\n  $showDiskLoc: 'showRecordId',\n  $maxTimeMS: 'maxTimeMS',\n  $snapshot: 'snapshot'\n};\n\nconst LEGACY_FIND_OPTIONS_MAP = {\n  numberToSkip: 'skip',\n  numberToReturn: 'batchSize',\n  returnFieldsSelector: 'projection'\n};\n\nconst OP_QUERY_KEYS = [\n  'tailable',\n  'oplogReplay',\n  'noCursorTimeout',\n  'awaitData',\n  'partial',\n  'exhaust'\n];\n\n/**\n * Extract the actual command from the query, possibly upconverting if it's a legacy\n * format\n *\n * @param {Object} command the command\n */\nconst extractCommand = command => {\n  if (command instanceof GetMore) {\n    return {\n      getMore: command.cursorId,\n      collection: collectionName(command),\n      batchSize: command.numberToReturn\n    };\n  }\n\n  if (command instanceof KillCursor) {\n    return {\n      killCursors: collectionName(command),\n      cursors: command.cursorIds\n    };\n  }\n\n  if (command instanceof Msg) {\n    return command.command;\n  }\n\n  if (command.query && command.query.$query) {\n    let result;\n    if (command.ns === 'admin.$cmd') {\n      // upconvert legacy command\n      result = Object.assign({}, command.query.$query);\n    } else {\n      // upconvert legacy find command\n      result = { find: collectionName(command) };\n      Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => {\n        if (typeof command.query[key] !== 'undefined')\n          result[LEGACY_FIND_QUERY_MAP[key]] = command.query[key];\n      });\n    }\n\n    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => {\n      if (typeof command[key] !== 'undefined') result[LEGACY_FIND_OPTIONS_MAP[key]] = command[key];\n    });\n\n    OP_QUERY_KEYS.forEach(key => {\n      if (command[key]) result[key] = command[key];\n    });\n\n    if (typeof command.pre32Limit !== 'undefined') {\n      result.limit = command.pre32Limit;\n    }\n\n    if (command.query.$explain) {\n      return { explain: result };\n    }\n\n    return result;\n  }\n\n  return command.query ? command.query : command;\n};\n\nconst extractReply = (command, reply) => {\n  if (command instanceof GetMore) {\n    return {\n      ok: 1,\n      cursor: {\n        id: reply.message.cursorId,\n        ns: namespace(command),\n        nextBatch: reply.message.documents\n      }\n    };\n  }\n\n  if (command instanceof KillCursor) {\n    return {\n      ok: 1,\n      cursorsUnknown: command.cursorIds\n    };\n  }\n\n  // is this a legacy find command?\n  if (command.query && typeof command.query.$query !== 'undefined') {\n    return {\n      ok: 1,\n      cursor: {\n        id: reply.message.cursorId,\n        ns: namespace(command),\n        firstBatch: reply.message.documents\n      }\n    };\n  }\n\n  return reply && reply.result ? reply.result : reply;\n};\n\nconst extractConnectionDetails = pool => {\n  if (isLegacyPool(pool)) {\n    return {\n      connectionId: generateConnectionId(pool)\n    };\n  }\n\n  // APM in the modern pool is done at the `Connection` level, so we rename it here for\n  // readability.\n  const connection = pool;\n  return {\n    address: connection.address,\n    connectionId: connection.id\n  };\n};\n\n/** An event indicating the start of a given command */\nclass CommandStartedEvent {\n  /**\n   * Create a started event\n   *\n   * @param {Pool} pool the pool that originated the command\n   * @param {Object} command the command\n   */\n  constructor(pool, command) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const connectionDetails = extractConnectionDetails(pool);\n\n    // NOTE: remove in major revision, this is not spec behavior\n    if (SENSITIVE_COMMANDS.has(commandName)) {\n      this.commandObj = {};\n      this.commandObj[commandName] = true;\n    }\n\n    Object.assign(this, connectionDetails, {\n      requestId: command.requestId,\n      databaseName: databaseName(command),\n      commandName,\n      command: cmd\n    });\n  }\n}\n\n/** An event indicating the success of a given command */\nclass CommandSucceededEvent {\n  /**\n   * Create a succeeded event\n   *\n   * @param {Pool} pool the pool that originated the command\n   * @param {Object} command the command\n   * @param {Object} reply the reply for this command from the server\n   * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(pool, command, reply, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const connectionDetails = extractConnectionDetails(pool);\n\n    Object.assign(this, connectionDetails, {\n      requestId: command.requestId,\n      commandName,\n      duration: calculateDurationInMs(started),\n      reply: maybeRedact(commandName, extractReply(command, reply))\n    });\n  }\n}\n\n/** An event indicating the failure of a given command */\nclass CommandFailedEvent {\n  /**\n   * Create a failure event\n   *\n   * @param {Pool} pool the pool that originated the command\n   * @param {Object} command the command\n   * @param {MongoError|Object} error the generated error or a server error response\n   * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(pool, command, error, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const connectionDetails = extractConnectionDetails(pool);\n\n    Object.assign(this, connectionDetails, {\n      requestId: command.requestId,\n      commandName,\n      duration: calculateDurationInMs(started),\n      failure: maybeRedact(commandName, error)\n    });\n  }\n}\n\nmodule.exports = {\n  CommandStartedEvent,\n  CommandSucceededEvent,\n  CommandFailedEvent\n};\n"]},"metadata":{},"sourceType":"script"}