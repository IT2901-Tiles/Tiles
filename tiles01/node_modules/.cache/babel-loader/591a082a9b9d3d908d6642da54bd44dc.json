{"ast":null,"code":"'use strict';\n\nconst Query = require('../connection/commands').Query;\n\nconst Msg = require('../connection/msg').Msg;\n\nconst MongoError = require('../error').MongoError;\n\nconst getReadPreference = require('./shared').getReadPreference;\n\nconst isSharded = require('./shared').isSharded;\n\nconst databaseNamespace = require('./shared').databaseNamespace;\n\nconst isTransactionCommand = require('../transactions').isTransactionCommand;\n\nconst applySession = require('../sessions').applySession;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst maxWireVersion = require('../utils').maxWireVersion;\n\nfunction isClientEncryptionEnabled(server) {\n  const wireVersion = maxWireVersion(server);\n  return wireVersion && server.autoEncrypter;\n}\n\nfunction command(server, ns, cmd, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n\n  if (cmd == null) {\n    return callback(new MongoError(`command ${JSON.stringify(cmd)} does not return a cursor`));\n  }\n\n  if (!isClientEncryptionEnabled(server)) {\n    _command(server, ns, cmd, options, callback);\n\n    return;\n  }\n\n  const wireVersion = maxWireVersion(server);\n\n  if (typeof wireVersion !== 'number' || wireVersion < 8) {\n    callback(new MongoError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n    return;\n  }\n\n  _cryptCommand(server, ns, cmd, options, callback);\n}\n\nfunction _command(server, ns, cmd, options, callback) {\n  const bson = server.s.bson;\n  const pool = server.s.pool;\n  const readPreference = getReadPreference(cmd, options);\n  const shouldUseOpMsg = supportsOpMsg(server);\n  const session = options.session;\n  let clusterTime = server.clusterTime;\n  let finalCmd = Object.assign({}, cmd);\n\n  if (hasSessionSupport(server) && session) {\n    if (session.clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n      clusterTime = session.clusterTime;\n    }\n\n    const err = applySession(session, finalCmd, options);\n\n    if (err) {\n      return callback(err);\n    }\n  } // if we have a known cluster time, gossip it\n\n\n  if (clusterTime) {\n    finalCmd.$clusterTime = clusterTime;\n  }\n\n  if (isSharded(server) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n    finalCmd = {\n      $query: finalCmd,\n      $readPreference: readPreference.toJSON()\n    };\n  }\n\n  const commandOptions = Object.assign({\n    command: true,\n    numberToSkip: 0,\n    numberToReturn: -1,\n    checkKeys: false\n  }, options); // This value is not overridable\n\n  commandOptions.slaveOk = readPreference.slaveOk();\n  const cmdNs = `${databaseNamespace(ns)}.$cmd`;\n  const message = shouldUseOpMsg ? new Msg(bson, cmdNs, finalCmd, commandOptions) : new Query(bson, cmdNs, finalCmd, commandOptions);\n  const inTransaction = session && (session.inTransaction() || isTransactionCommand(finalCmd));\n  const commandResponseHandler = inTransaction ? function (err) {\n    // We need to add a TransientTransactionError errorLabel, as stated in the transaction spec.\n    if (err && err instanceof MongoNetworkError && !err.hasErrorLabel('TransientTransactionError')) {\n      err.addErrorLabel('TransientTransactionError');\n    }\n\n    if (!cmd.commitTransaction && err && err instanceof MongoError && err.hasErrorLabel('TransientTransactionError')) {\n      session.transaction.unpinServer();\n    }\n\n    return callback.apply(null, arguments);\n  } : callback;\n\n  try {\n    pool.write(message, commandOptions, commandResponseHandler);\n  } catch (err) {\n    commandResponseHandler(err);\n  }\n}\n\nfunction hasSessionSupport(topology) {\n  if (topology == null) return false;\n\n  if (topology.description) {\n    return topology.description.maxWireVersion >= 6;\n  }\n\n  return topology.ismaster == null ? false : topology.ismaster.maxWireVersion >= 6;\n}\n\nfunction supportsOpMsg(topologyOrServer) {\n  const description = topologyOrServer.ismaster ? topologyOrServer.ismaster : topologyOrServer.description;\n\n  if (description == null) {\n    return false;\n  }\n\n  return description.maxWireVersion >= 6 && description.__nodejs_mock_server__ == null;\n}\n\nfunction _cryptCommand(server, ns, cmd, options, callback) {\n  const autoEncrypter = server.autoEncrypter;\n\n  function commandResponseHandler(err, response) {\n    if (err || response == null) {\n      callback(err, response);\n      return;\n    }\n\n    autoEncrypter.decrypt(response.result, options, (err, decrypted) => {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      response.result = decrypted;\n      response.message.documents = [decrypted];\n      callback(null, response);\n    });\n  }\n\n  autoEncrypter.encrypt(ns, cmd, options, (err, encrypted) => {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    _command(server, ns, encrypted, options, commandResponseHandler);\n  });\n}\n\nmodule.exports = command;","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/core/wireprotocol/command.js"],"names":["Query","require","Msg","MongoError","getReadPreference","isSharded","databaseNamespace","isTransactionCommand","applySession","MongoNetworkError","maxWireVersion","isClientEncryptionEnabled","server","wireVersion","autoEncrypter","command","ns","cmd","options","callback","JSON","stringify","_command","_cryptCommand","bson","s","pool","readPreference","shouldUseOpMsg","supportsOpMsg","session","clusterTime","finalCmd","Object","assign","hasSessionSupport","greaterThan","err","$clusterTime","mode","$query","$readPreference","toJSON","commandOptions","numberToSkip","numberToReturn","checkKeys","slaveOk","cmdNs","message","inTransaction","commandResponseHandler","hasErrorLabel","addErrorLabel","commitTransaction","transaction","unpinServer","apply","arguments","write","topology","description","ismaster","topologyOrServer","__nodejs_mock_server__","response","decrypt","result","decrypted","documents","encrypt","encrypted","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Query = require('../connection/commands').Query;\nconst Msg = require('../connection/msg').Msg;\nconst MongoError = require('../error').MongoError;\nconst getReadPreference = require('./shared').getReadPreference;\nconst isSharded = require('./shared').isSharded;\nconst databaseNamespace = require('./shared').databaseNamespace;\nconst isTransactionCommand = require('../transactions').isTransactionCommand;\nconst applySession = require('../sessions').applySession;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst maxWireVersion = require('../utils').maxWireVersion;\n\nfunction isClientEncryptionEnabled(server) {\n  const wireVersion = maxWireVersion(server);\n  return wireVersion && server.autoEncrypter;\n}\n\nfunction command(server, ns, cmd, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  if (cmd == null) {\n    return callback(new MongoError(`command ${JSON.stringify(cmd)} does not return a cursor`));\n  }\n\n  if (!isClientEncryptionEnabled(server)) {\n    _command(server, ns, cmd, options, callback);\n    return;\n  }\n\n  const wireVersion = maxWireVersion(server);\n  if (typeof wireVersion !== 'number' || wireVersion < 8) {\n    callback(new MongoError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n    return;\n  }\n\n  _cryptCommand(server, ns, cmd, options, callback);\n}\n\nfunction _command(server, ns, cmd, options, callback) {\n  const bson = server.s.bson;\n  const pool = server.s.pool;\n  const readPreference = getReadPreference(cmd, options);\n  const shouldUseOpMsg = supportsOpMsg(server);\n  const session = options.session;\n\n  let clusterTime = server.clusterTime;\n  let finalCmd = Object.assign({}, cmd);\n  if (hasSessionSupport(server) && session) {\n    if (\n      session.clusterTime &&\n      session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)\n    ) {\n      clusterTime = session.clusterTime;\n    }\n\n    const err = applySession(session, finalCmd, options);\n    if (err) {\n      return callback(err);\n    }\n  }\n\n  // if we have a known cluster time, gossip it\n  if (clusterTime) {\n    finalCmd.$clusterTime = clusterTime;\n  }\n\n  if (isSharded(server) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n    finalCmd = {\n      $query: finalCmd,\n      $readPreference: readPreference.toJSON()\n    };\n  }\n\n  const commandOptions = Object.assign(\n    {\n      command: true,\n      numberToSkip: 0,\n      numberToReturn: -1,\n      checkKeys: false\n    },\n    options\n  );\n\n  // This value is not overridable\n  commandOptions.slaveOk = readPreference.slaveOk();\n\n  const cmdNs = `${databaseNamespace(ns)}.$cmd`;\n  const message = shouldUseOpMsg\n    ? new Msg(bson, cmdNs, finalCmd, commandOptions)\n    : new Query(bson, cmdNs, finalCmd, commandOptions);\n\n  const inTransaction = session && (session.inTransaction() || isTransactionCommand(finalCmd));\n  const commandResponseHandler = inTransaction\n    ? function(err) {\n        // We need to add a TransientTransactionError errorLabel, as stated in the transaction spec.\n        if (\n          err &&\n          err instanceof MongoNetworkError &&\n          !err.hasErrorLabel('TransientTransactionError')\n        ) {\n          err.addErrorLabel('TransientTransactionError');\n        }\n\n        if (\n          !cmd.commitTransaction &&\n          err &&\n          err instanceof MongoError &&\n          err.hasErrorLabel('TransientTransactionError')\n        ) {\n          session.transaction.unpinServer();\n        }\n\n        return callback.apply(null, arguments);\n      }\n    : callback;\n\n  try {\n    pool.write(message, commandOptions, commandResponseHandler);\n  } catch (err) {\n    commandResponseHandler(err);\n  }\n}\n\nfunction hasSessionSupport(topology) {\n  if (topology == null) return false;\n  if (topology.description) {\n    return topology.description.maxWireVersion >= 6;\n  }\n\n  return topology.ismaster == null ? false : topology.ismaster.maxWireVersion >= 6;\n}\n\nfunction supportsOpMsg(topologyOrServer) {\n  const description = topologyOrServer.ismaster\n    ? topologyOrServer.ismaster\n    : topologyOrServer.description;\n\n  if (description == null) {\n    return false;\n  }\n\n  return description.maxWireVersion >= 6 && description.__nodejs_mock_server__ == null;\n}\n\nfunction _cryptCommand(server, ns, cmd, options, callback) {\n  const autoEncrypter = server.autoEncrypter;\n  function commandResponseHandler(err, response) {\n    if (err || response == null) {\n      callback(err, response);\n      return;\n    }\n\n    autoEncrypter.decrypt(response.result, options, (err, decrypted) => {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      response.result = decrypted;\n      response.message.documents = [decrypted];\n      callback(null, response);\n    });\n  }\n\n  autoEncrypter.encrypt(ns, cmd, options, (err, encrypted) => {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    _command(server, ns, encrypted, options, commandResponseHandler);\n  });\n}\n\nmodule.exports = command;\n"]},"metadata":{},"sourceType":"script"}