{"ast":null,"code":"'use strict';\n\nconst inherits = require('util').inherits;\n\nconst f = require('util').format;\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst ReadPreference = require('./read_preference');\n\nconst CoreCursor = require('../cursor').CoreCursor;\n\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\n\nconst Logger = require('../connection/logger');\n\nconst MongoError = require('../error').MongoError;\n\nconst Server = require('./server');\n\nconst ReplSetState = require('./replset_state');\n\nconst Timeout = require('./shared').Timeout;\n\nconst Interval = require('./shared').Interval;\n\nconst SessionMixins = require('./shared').SessionMixins;\n\nconst isRetryableWritesSupported = require('./shared').isRetryableWritesSupported;\n\nconst relayEvents = require('../utils').relayEvents;\n\nconst BSON = retrieveBSON();\n\nconst getMMAPError = require('./shared').getMMAPError;\n\nconst makeClientMetadata = require('../utils').makeClientMetadata;\n\nconst legacyIsRetryableWriteError = require('./shared').legacyIsRetryableWriteError;\n\nconst now = require('../../utils').now;\n\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs; //\n// States\n\n\nvar DISCONNECTED = 'disconnected';\nvar CONNECTING = 'connecting';\nvar CONNECTED = 'connected';\nvar UNREFERENCED = 'unreferenced';\nvar DESTROYED = 'destroyed';\n\nfunction stateTransition(self, newState) {\n  var legalTransitions = {\n    disconnected: [CONNECTING, DESTROYED, DISCONNECTED],\n    connecting: [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],\n    connected: [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],\n    unreferenced: [UNREFERENCED, DESTROYED],\n    destroyed: [DESTROYED]\n  }; // Get current state\n\n  var legalStates = legalTransitions[self.state];\n\n  if (legalStates && legalStates.indexOf(newState) !== -1) {\n    self.state = newState;\n  } else {\n    self.s.logger.error(f('Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]', self.id, self.state, newState, legalStates));\n  }\n} //\n// ReplSet instance id\n\n\nvar id = 1;\nvar handlers = ['connect', 'close', 'error', 'timeout', 'parseError'];\n/**\n * Creates a new Replset instance\n * @class\n * @param {array} seedlist A list of seeds for the replicaset\n * @param {boolean} options.setName The Replicaset set name\n * @param {boolean} [options.secondaryOnlyConnectionAllowed=false] Allow connection to a secondary only replicaset\n * @param {number} [options.haInterval=10000] The High availability period for replicaset inquiry\n * @param {boolean} [options.emitError=false] Server will emit errors events\n * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors\n * @param {number} [options.size=5] Server connection pool size\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=10000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {number} [options.pingInterval=5000] Ping interval to check the response time to the different servers\n * @param {number} [options.localThresholdMS=15] Cutoff latency point in MS for Replicaset member selection\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\n * @return {ReplSet} A cursor instance\n * @fires ReplSet#connect\n * @fires ReplSet#ha\n * @fires ReplSet#joined\n * @fires ReplSet#left\n * @fires ReplSet#failed\n * @fires ReplSet#fullsetup\n * @fires ReplSet#all\n * @fires ReplSet#error\n * @fires ReplSet#serverHeartbeatStarted\n * @fires ReplSet#serverHeartbeatSucceeded\n * @fires ReplSet#serverHeartbeatFailed\n * @fires ReplSet#topologyOpening\n * @fires ReplSet#topologyClosed\n * @fires ReplSet#topologyDescriptionChanged\n * @property {string} type the topology type.\n * @property {string} parserType the parser type used (c++ or js).\n */\n\nvar ReplSet = function (seedlist, options) {\n  var self = this;\n  options = options || {}; // Validate seedlist\n\n  if (!Array.isArray(seedlist)) throw new MongoError('seedlist must be an array'); // Validate list\n\n  if (seedlist.length === 0) throw new MongoError('seedlist must contain at least one entry'); // Validate entries\n\n  seedlist.forEach(function (e) {\n    if (typeof e.host !== 'string' || typeof e.port !== 'number') throw new MongoError('seedlist entry must contain a host and port');\n  }); // Add event listener\n\n  EventEmitter.call(this); // Get replSet Id\n\n  this.id = id++; // Get the localThresholdMS\n\n  var localThresholdMS = options.localThresholdMS || 15; // Backward compatibility\n\n  if (options.acceptableLatency) localThresholdMS = options.acceptableLatency; // Create a logger\n\n  var logger = Logger('ReplSet', options); // Internal state\n\n  this.s = {\n    options: Object.assign({\n      metadata: makeClientMetadata(options)\n    }, options),\n    // BSON instance\n    bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),\n    // Factory overrides\n    Cursor: options.cursorFactory || CoreCursor,\n    // Logger instance\n    logger: logger,\n    // Seedlist\n    seedlist: seedlist,\n    // Replicaset state\n    replicaSetState: new ReplSetState({\n      id: this.id,\n      setName: options.setName,\n      acceptableLatency: localThresholdMS,\n      heartbeatFrequencyMS: options.haInterval ? options.haInterval : 10000,\n      logger: logger\n    }),\n    // Current servers we are connecting to\n    connectingServers: [],\n    // Ha interval\n    haInterval: options.haInterval ? options.haInterval : 10000,\n    // Minimum heartbeat frequency used if we detect a server close\n    minHeartbeatFrequencyMS: 500,\n    // Disconnect handler\n    disconnectHandler: options.disconnectHandler,\n    // Server selection index\n    index: 0,\n    // Connect function options passed in\n    connectOptions: {},\n    // Are we running in debug mode\n    debug: typeof options.debug === 'boolean' ? options.debug : false\n  }; // Add handler for topology change\n\n  this.s.replicaSetState.on('topologyDescriptionChanged', function (r) {\n    self.emit('topologyDescriptionChanged', r);\n  }); // Log info warning if the socketTimeout < haInterval as it will cause\n  // a lot of recycled connections to happen.\n\n  if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {\n    this.s.logger.warn(f('warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts', this.s.options.socketTimeout, this.s.haInterval));\n  } // Add forwarding of events from state handler\n\n\n  var types = ['joined', 'left'];\n  types.forEach(function (x) {\n    self.s.replicaSetState.on(x, function (t, s) {\n      self.emit(x, t, s);\n    });\n  }); // Connect stat\n\n  this.initialConnectState = {\n    connect: false,\n    fullsetup: false,\n    all: false\n  }; // Disconnected state\n\n  this.state = DISCONNECTED;\n  this.haTimeoutId = null; // Last ismaster\n\n  this.ismaster = null; // Contains the intervalId\n\n  this.intervalIds = []; // Highest clusterTime seen in responses from the current deployment\n\n  this.clusterTime = null;\n};\n\ninherits(ReplSet, EventEmitter);\nObject.assign(ReplSet.prototype, SessionMixins);\nObject.defineProperty(ReplSet.prototype, 'type', {\n  enumerable: true,\n  get: function () {\n    return 'replset';\n  }\n});\nObject.defineProperty(ReplSet.prototype, 'parserType', {\n  enumerable: true,\n  get: function () {\n    return BSON.native ? 'c++' : 'js';\n  }\n});\nObject.defineProperty(ReplSet.prototype, 'logicalSessionTimeoutMinutes', {\n  enumerable: true,\n  get: function () {\n    return this.s.replicaSetState.logicalSessionTimeoutMinutes || null;\n  }\n});\n\nfunction rexecuteOperations(self) {\n  // If we have a primary and a disconnect handler, execute\n  // buffered operations\n  if (self.s.replicaSetState.hasPrimaryAndSecondary() && self.s.disconnectHandler) {\n    self.s.disconnectHandler.execute();\n  } else if (self.s.replicaSetState.hasPrimary() && self.s.disconnectHandler) {\n    self.s.disconnectHandler.execute({\n      executePrimary: true\n    });\n  } else if (self.s.replicaSetState.hasSecondary() && self.s.disconnectHandler) {\n    self.s.disconnectHandler.execute({\n      executeSecondary: true\n    });\n  }\n}\n\nfunction connectNewServers(self, servers, callback) {\n  // No new servers\n  if (servers.length === 0) {\n    return callback();\n  } // Count lefts\n\n\n  var count = servers.length;\n  var error = null;\n\n  function done() {\n    count = count - 1;\n\n    if (count === 0) {\n      callback(error);\n    }\n  } // Handle events\n\n\n  var _handleEvent = function (self, event) {\n    return function (err) {\n      var _self = this; // Destroyed\n\n\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        this.destroy({\n          force: true\n        });\n        return done();\n      }\n\n      if (event === 'connect') {\n        // Update the state\n        var result = self.s.replicaSetState.update(_self); // Update the state with the new server\n\n        if (result) {\n          // Primary lastIsMaster store it\n          if (_self.lastIsMaster() && _self.lastIsMaster().ismaster) {\n            self.ismaster = _self.lastIsMaster();\n          } // Remove the handlers\n\n\n          for (let i = 0; i < handlers.length; i++) {\n            _self.removeAllListeners(handlers[i]);\n          } // Add stable state handlers\n\n\n          _self.on('error', handleEvent(self, 'error'));\n\n          _self.on('close', handleEvent(self, 'close'));\n\n          _self.on('timeout', handleEvent(self, 'timeout'));\n\n          _self.on('parseError', handleEvent(self, 'parseError')); // Enalbe the monitoring of the new server\n\n\n          monitorServer(_self.lastIsMaster().me, self, {}); // Rexecute any stalled operation\n\n          rexecuteOperations(self);\n        } else {\n          _self.destroy({\n            force: true\n          });\n        }\n      } else if (event === 'error') {\n        error = err;\n      } // Rexecute any stalled operation\n\n\n      rexecuteOperations(self);\n      done();\n    };\n  }; // Execute method\n\n\n  function execute(_server, i) {\n    setTimeout(function () {\n      // Destroyed\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        return;\n      } // remove existing connecting server if it's failed to connect, otherwise\n      // wait for that server to connect\n\n\n      const existingServerIdx = self.s.connectingServers.findIndex(s => s.name === _server);\n\n      if (existingServerIdx >= 0) {\n        const connectingServer = self.s.connectingServers[existingServerIdx];\n        connectingServer.destroy({\n          force: true\n        });\n        self.s.connectingServers.splice(existingServerIdx, 1);\n        return done();\n      } // Create a new server instance\n\n\n      var server = new Server(Object.assign({}, self.s.options, {\n        host: _server.split(':')[0],\n        port: parseInt(_server.split(':')[1], 10),\n        reconnect: false,\n        monitoring: false,\n        parent: self\n      })); // Add temp handlers\n\n      server.once('connect', _handleEvent(self, 'connect'));\n      server.once('close', _handleEvent(self, 'close'));\n      server.once('timeout', _handleEvent(self, 'timeout'));\n      server.once('error', _handleEvent(self, 'error'));\n      server.once('parseError', _handleEvent(self, 'parseError')); // SDAM Monitoring events\n\n      server.on('serverOpening', e => self.emit('serverOpening', e));\n      server.on('serverDescriptionChanged', e => self.emit('serverDescriptionChanged', e));\n      server.on('serverClosed', e => self.emit('serverClosed', e)); // Command Monitoring events\n\n      relayEvents(server, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);\n      self.s.connectingServers.push(server);\n      server.connect(self.s.connectOptions);\n    }, i);\n  } // Create new instances\n\n\n  for (var i = 0; i < servers.length; i++) {\n    execute(servers[i], i);\n  }\n} // Ping the server\n\n\nvar pingServer = function (self, server, cb) {\n  // Measure running time\n  var start = new Date().getTime(); // Emit the server heartbeat start\n\n  emitSDAMEvent(self, 'serverHeartbeatStarted', {\n    connectionId: server.name\n  }); // Execute ismaster\n  // Set the socketTimeout for a monitoring message to a low number\n  // Ensuring ismaster calls are timed out quickly\n\n  server.command('admin.$cmd', {\n    ismaster: true\n  }, {\n    monitoring: true,\n    socketTimeout: self.s.options.connectionTimeout || 2000\n  }, function (err, r) {\n    if (self.state === DESTROYED || self.state === UNREFERENCED) {\n      server.destroy({\n        force: true\n      });\n      return cb(err, r);\n    } // Calculate latency\n\n\n    var latencyMS = new Date().getTime() - start; // Set the last updatedTime\n\n    server.lastUpdateTime = now(); // We had an error, remove it from the state\n\n    if (err) {\n      // Emit the server heartbeat failure\n      emitSDAMEvent(self, 'serverHeartbeatFailed', {\n        durationMS: latencyMS,\n        failure: err,\n        connectionId: server.name\n      }); // Remove server from the state\n\n      self.s.replicaSetState.remove(server);\n    } else {\n      // Update the server ismaster\n      server.ismaster = r.result; // Check if we have a lastWriteDate convert it to MS\n      // and store on the server instance for later use\n\n      if (server.ismaster.lastWrite && server.ismaster.lastWrite.lastWriteDate) {\n        server.lastWriteDate = server.ismaster.lastWrite.lastWriteDate.getTime();\n      } // Do we have a brand new server\n\n\n      if (server.lastIsMasterMS === -1) {\n        server.lastIsMasterMS = latencyMS;\n      } else if (server.lastIsMasterMS) {\n        // After the first measurement, average RTT MUST be computed using an\n        // exponentially-weighted moving average formula, with a weighting factor (alpha) of 0.2.\n        // If the prior average is denoted old_rtt, then the new average (new_rtt) is\n        // computed from a new RTT measurement (x) using the following formula:\n        // alpha = 0.2\n        // new_rtt = alpha * x + (1 - alpha) * old_rtt\n        server.lastIsMasterMS = 0.2 * latencyMS + (1 - 0.2) * server.lastIsMasterMS;\n      }\n\n      if (self.s.replicaSetState.update(server)) {\n        // Primary lastIsMaster store it\n        if (server.lastIsMaster() && server.lastIsMaster().ismaster) {\n          self.ismaster = server.lastIsMaster();\n        }\n      } // Server heart beat event\n\n\n      emitSDAMEvent(self, 'serverHeartbeatSucceeded', {\n        durationMS: latencyMS,\n        reply: r.result,\n        connectionId: server.name\n      });\n    } // Calculate the staleness for this server\n\n\n    self.s.replicaSetState.updateServerMaxStaleness(server, self.s.haInterval); // Callback\n\n    cb(err, r);\n  });\n}; // Each server is monitored in parallel in their own timeout loop\n\n\nvar monitorServer = function (host, self, options) {\n  // If this is not the initial scan\n  // Is this server already being monitoried, then skip monitoring\n  if (!options.haInterval) {\n    for (var i = 0; i < self.intervalIds.length; i++) {\n      if (self.intervalIds[i].__host === host) {\n        return;\n      }\n    }\n  } // Get the haInterval\n\n\n  var _process = options.haInterval ? Timeout : Interval;\n\n  var _haInterval = options.haInterval ? options.haInterval : self.s.haInterval; // Create the interval\n\n\n  var intervalId = new _process(function () {\n    if (self.state === DESTROYED || self.state === UNREFERENCED) {\n      // clearInterval(intervalId);\n      intervalId.stop();\n      return;\n    } // Do we already have server connection available for this host\n\n\n    var _server = self.s.replicaSetState.get(host); // Check if we have a known server connection and reuse\n\n\n    if (_server) {\n      // Ping the server\n      return pingServer(self, _server, function (err) {\n        if (err) {\n          // NOTE: should something happen here?\n          return;\n        }\n\n        if (self.state === DESTROYED || self.state === UNREFERENCED) {\n          intervalId.stop();\n          return;\n        } // Filter out all called intervaliIds\n\n\n        self.intervalIds = self.intervalIds.filter(function (intervalId) {\n          return intervalId.isRunning();\n        }); // Initial sweep\n\n        if (_process === Timeout) {\n          if (self.state === CONNECTING && (self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed || self.s.replicaSetState.hasPrimary())) {\n            stateTransition(self, CONNECTED); // Emit connected sign\n\n            process.nextTick(function () {\n              self.emit('connect', self);\n            }); // Start topology interval check\n\n            topologyMonitor(self, {});\n          }\n        } else {\n          if (self.state === DISCONNECTED && (self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed || self.s.replicaSetState.hasPrimary())) {\n            stateTransition(self, CONNECTED); // Rexecute any stalled operation\n\n            rexecuteOperations(self); // Emit connected sign\n\n            process.nextTick(function () {\n              self.emit('reconnect', self);\n            });\n          }\n        }\n\n        if (self.initialConnectState.connect && !self.initialConnectState.fullsetup && self.s.replicaSetState.hasPrimaryAndSecondary()) {\n          // Set initial connect state\n          self.initialConnectState.fullsetup = true;\n          self.initialConnectState.all = true;\n          process.nextTick(function () {\n            self.emit('fullsetup', self);\n            self.emit('all', self);\n          });\n        }\n      });\n    }\n  }, _haInterval); // Start the interval\n\n  intervalId.start(); // Add the intervalId host name\n\n  intervalId.__host = host; // Add the intervalId to our list of intervalIds\n\n  self.intervalIds.push(intervalId);\n};\n\nfunction topologyMonitor(self, options) {\n  if (self.state === DESTROYED || self.state === UNREFERENCED) return;\n  options = options || {}; // Get the servers\n\n  var servers = Object.keys(self.s.replicaSetState.set); // Get the haInterval\n\n  var _process = options.haInterval ? Timeout : Interval;\n\n  var _haInterval = options.haInterval ? options.haInterval : self.s.haInterval;\n\n  if (_process === Timeout) {\n    return connectNewServers(self, self.s.replicaSetState.unknownServers, function (err) {\n      // Don't emit errors if the connection was already\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        return;\n      }\n\n      if (!self.s.replicaSetState.hasPrimary() && !self.s.options.secondaryOnlyConnectionAllowed) {\n        if (err) {\n          return self.emit('error', err);\n        }\n\n        self.emit('error', new MongoError('no primary found in replicaset or invalid replica set name'));\n        return self.destroy({\n          force: true\n        });\n      } else if (!self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed) {\n        if (err) {\n          return self.emit('error', err);\n        }\n\n        self.emit('error', new MongoError('no secondary found in replicaset or invalid replica set name'));\n        return self.destroy({\n          force: true\n        });\n      }\n\n      for (var i = 0; i < servers.length; i++) {\n        monitorServer(servers[i], self, options);\n      }\n    });\n  } else {\n    for (var i = 0; i < servers.length; i++) {\n      monitorServer(servers[i], self, options);\n    }\n  } // Run the reconnect process\n\n\n  function executeReconnect(self) {\n    return function () {\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        return;\n      }\n\n      connectNewServers(self, self.s.replicaSetState.unknownServers, function () {\n        var monitoringFrequencey = self.s.replicaSetState.hasPrimary() ? _haInterval : self.s.minHeartbeatFrequencyMS; // Create a timeout\n\n        self.intervalIds.push(new Timeout(executeReconnect(self), monitoringFrequencey).start());\n      });\n    };\n  } // Decide what kind of interval to use\n\n\n  var intervalTime = !self.s.replicaSetState.hasPrimary() ? self.s.minHeartbeatFrequencyMS : _haInterval;\n  self.intervalIds.push(new Timeout(executeReconnect(self), intervalTime).start());\n}\n\nfunction addServerToList(list, server) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i].name.toLowerCase() === server.name.toLowerCase()) return true;\n  }\n\n  list.push(server);\n}\n\nfunction handleEvent(self, event) {\n  return function () {\n    if (self.state === DESTROYED || self.state === UNREFERENCED) return; // Debug log\n\n    if (self.s.logger.isDebug()) {\n      self.s.logger.debug(f('handleEvent %s from server %s in replset with id %s', event, this.name, self.id));\n    } // Remove from the replicaset state\n\n\n    self.s.replicaSetState.remove(this); // Are we in a destroyed state return\n\n    if (self.state === DESTROYED || self.state === UNREFERENCED) return; // If no primary and secondary available\n\n    if (!self.s.replicaSetState.hasPrimary() && !self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed) {\n      stateTransition(self, DISCONNECTED);\n    } else if (!self.s.replicaSetState.hasPrimary()) {\n      stateTransition(self, DISCONNECTED);\n    }\n\n    addServerToList(self.s.connectingServers, this);\n  };\n}\n\nfunction shouldTriggerConnect(self) {\n  const isConnecting = self.state === CONNECTING;\n  const hasPrimary = self.s.replicaSetState.hasPrimary();\n  const hasSecondary = self.s.replicaSetState.hasSecondary();\n  const secondaryOnlyConnectionAllowed = self.s.options.secondaryOnlyConnectionAllowed;\n  const readPreferenceSecondary = self.s.connectOptions.readPreference && self.s.connectOptions.readPreference.equals(ReadPreference.secondary);\n  return isConnecting && (readPreferenceSecondary && hasSecondary || !readPreferenceSecondary && hasPrimary) || hasSecondary && secondaryOnlyConnectionAllowed;\n}\n\nfunction handleInitialConnectEvent(self, event) {\n  return function () {\n    var _this = this; // Debug log\n\n\n    if (self.s.logger.isDebug()) {\n      self.s.logger.debug(f('handleInitialConnectEvent %s from server %s in replset with id %s', event, this.name, self.id));\n    } // Destroy the instance\n\n\n    if (self.state === DESTROYED || self.state === UNREFERENCED) {\n      return this.destroy({\n        force: true\n      });\n    } // Check the type of server\n\n\n    if (event === 'connect') {\n      // Update the state\n      var result = self.s.replicaSetState.update(_this);\n\n      if (result === true) {\n        // Primary lastIsMaster store it\n        if (_this.lastIsMaster() && _this.lastIsMaster().ismaster) {\n          self.ismaster = _this.lastIsMaster();\n        } // Debug log\n\n\n        if (self.s.logger.isDebug()) {\n          self.s.logger.debug(f('handleInitialConnectEvent %s from server %s in replset with id %s has state [%s]', event, _this.name, self.id, JSON.stringify(self.s.replicaSetState.set)));\n        } // Remove the handlers\n\n\n        for (let i = 0; i < handlers.length; i++) {\n          _this.removeAllListeners(handlers[i]);\n        } // Add stable state handlers\n\n\n        _this.on('error', handleEvent(self, 'error'));\n\n        _this.on('close', handleEvent(self, 'close'));\n\n        _this.on('timeout', handleEvent(self, 'timeout'));\n\n        _this.on('parseError', handleEvent(self, 'parseError')); // Do we have a primary or primaryAndSecondary\n\n\n        if (shouldTriggerConnect(self)) {\n          // We are connected\n          stateTransition(self, CONNECTED); // Set initial connect state\n\n          self.initialConnectState.connect = true; // Emit connect event\n\n          process.nextTick(function () {\n            self.emit('connect', self);\n          });\n          topologyMonitor(self, {});\n        }\n      } else if (result instanceof MongoError) {\n        _this.destroy({\n          force: true\n        });\n\n        self.destroy({\n          force: true\n        });\n        return self.emit('error', result);\n      } else {\n        _this.destroy({\n          force: true\n        });\n      }\n    } else {\n      // Emit failure to connect\n      self.emit('failed', this);\n      addServerToList(self.s.connectingServers, this); // Remove from the state\n\n      self.s.replicaSetState.remove(this);\n    }\n\n    if (self.initialConnectState.connect && !self.initialConnectState.fullsetup && self.s.replicaSetState.hasPrimaryAndSecondary()) {\n      // Set initial connect state\n      self.initialConnectState.fullsetup = true;\n      self.initialConnectState.all = true;\n      process.nextTick(function () {\n        self.emit('fullsetup', self);\n        self.emit('all', self);\n      });\n    } // Remove from the list from connectingServers\n\n\n    for (var i = 0; i < self.s.connectingServers.length; i++) {\n      if (self.s.connectingServers[i].equals(this)) {\n        self.s.connectingServers.splice(i, 1);\n      }\n    } // Trigger topologyMonitor\n\n\n    if (self.s.connectingServers.length === 0 && self.state === CONNECTING) {\n      topologyMonitor(self, {\n        haInterval: 1\n      });\n    }\n  };\n}\n\nfunction connectServers(self, servers) {\n  // Update connectingServers\n  self.s.connectingServers = self.s.connectingServers.concat(servers); // Index used to interleaf the server connects, avoiding\n  // runtime issues on io constrained vm's\n\n  var timeoutInterval = 0;\n\n  function connect(server, timeoutInterval) {\n    setTimeout(function () {\n      // Add the server to the state\n      if (self.s.replicaSetState.update(server)) {\n        // Primary lastIsMaster store it\n        if (server.lastIsMaster() && server.lastIsMaster().ismaster) {\n          self.ismaster = server.lastIsMaster();\n        }\n      } // Add event handlers\n\n\n      server.once('close', handleInitialConnectEvent(self, 'close'));\n      server.once('timeout', handleInitialConnectEvent(self, 'timeout'));\n      server.once('parseError', handleInitialConnectEvent(self, 'parseError'));\n      server.once('error', handleInitialConnectEvent(self, 'error'));\n      server.once('connect', handleInitialConnectEvent(self, 'connect')); // SDAM Monitoring events\n\n      server.on('serverOpening', e => self.emit('serverOpening', e));\n      server.on('serverDescriptionChanged', e => self.emit('serverDescriptionChanged', e));\n      server.on('serverClosed', e => self.emit('serverClosed', e)); // Command Monitoring events\n\n      relayEvents(server, self, ['commandStarted', 'commandSucceeded', 'commandFailed']); // Start connection\n\n      server.connect(self.s.connectOptions);\n    }, timeoutInterval);\n  } // Start all the servers\n\n\n  while (servers.length > 0) {\n    connect(servers.shift(), timeoutInterval++);\n  }\n}\n/**\n * Emit event if it exists\n * @method\n */\n\n\nfunction emitSDAMEvent(self, event, description) {\n  if (self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n}\n/**\n * Initiate server connect\n */\n\n\nReplSet.prototype.connect = function (options) {\n  var self = this; // Add any connect level options to the internal state\n\n  this.s.connectOptions = options || {}; // Set connecting state\n\n  stateTransition(this, CONNECTING); // Create server instances\n\n  var servers = this.s.seedlist.map(function (x) {\n    return new Server(Object.assign({}, self.s.options, x, options, {\n      reconnect: false,\n      monitoring: false,\n      parent: self\n    }));\n  }); // Error out as high availability interval must be < than socketTimeout\n\n  if (this.s.options.socketTimeout > 0 && this.s.options.socketTimeout <= this.s.options.haInterval) {\n    return self.emit('error', new MongoError(f('haInterval [%s] MS must be set to less than socketTimeout [%s] MS', this.s.options.haInterval, this.s.options.socketTimeout)));\n  } // Emit the topology opening event\n\n\n  emitSDAMEvent(this, 'topologyOpening', {\n    topologyId: this.id\n  }); // Start all server connections\n\n  connectServers(self, servers);\n};\n/**\n * Authenticate the topology.\n * @method\n * @param {MongoCredentials} credentials The credentials for authentication we are using\n * @param {authResultCallback} callback A callback function\n */\n\n\nReplSet.prototype.auth = function (credentials, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n/**\n * Destroy the server connection\n * @param {boolean} [options.force=false] Force destroy the pool\n * @method\n */\n\n\nReplSet.prototype.destroy = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  let destroyCount = this.s.connectingServers.length + 1; // +1 for the callback from `replicaSetState.destroy`\n\n  const serverDestroyed = () => {\n    destroyCount--;\n\n    if (destroyCount > 0) {\n      return;\n    } // Emit toplogy closing event\n\n\n    emitSDAMEvent(this, 'topologyClosed', {\n      topologyId: this.id\n    });\n\n    if (typeof callback === 'function') {\n      callback(null, null);\n    }\n  };\n\n  if (this.state === DESTROYED) {\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  } // Transition state\n\n\n  stateTransition(this, DESTROYED); // Clear out any monitoring process\n\n  if (this.haTimeoutId) clearTimeout(this.haTimeoutId); // Clear out all monitoring\n\n  for (var i = 0; i < this.intervalIds.length; i++) {\n    this.intervalIds[i].stop();\n  } // Reset list of intervalIds\n\n\n  this.intervalIds = [];\n\n  if (destroyCount === 0) {\n    serverDestroyed();\n    return;\n  } // Destroy the replicaset\n\n\n  this.s.replicaSetState.destroy(options, serverDestroyed); // Destroy all connecting servers\n\n  this.s.connectingServers.forEach(function (x) {\n    x.destroy(options, serverDestroyed);\n  });\n};\n/**\n * Unref all connections belong to this server\n * @method\n */\n\n\nReplSet.prototype.unref = function () {\n  // Transition state\n  stateTransition(this, UNREFERENCED);\n  this.s.replicaSetState.allServers().forEach(function (x) {\n    x.unref();\n  });\n  clearTimeout(this.haTimeoutId);\n};\n/**\n * Returns the last known ismaster document for this server\n * @method\n * @return {object}\n */\n\n\nReplSet.prototype.lastIsMaster = function () {\n  // If secondaryOnlyConnectionAllowed and no primary but secondary\n  // return the secondaries ismaster result.\n  if (this.s.options.secondaryOnlyConnectionAllowed && !this.s.replicaSetState.hasPrimary() && this.s.replicaSetState.hasSecondary()) {\n    return this.s.replicaSetState.secondaries[0].lastIsMaster();\n  }\n\n  return this.s.replicaSetState.primary ? this.s.replicaSetState.primary.lastIsMaster() : this.ismaster;\n};\n/**\n * All raw connections\n * @method\n * @return {Connection[]}\n */\n\n\nReplSet.prototype.connections = function () {\n  var servers = this.s.replicaSetState.allServers();\n  var connections = [];\n\n  for (var i = 0; i < servers.length; i++) {\n    connections = connections.concat(servers[i].connections());\n  }\n\n  return connections;\n};\n/**\n * Figure out if the server is connected\n * @method\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @return {boolean}\n */\n\n\nReplSet.prototype.isConnected = function (options) {\n  options = options || {}; // If we specified a read preference check if we are connected to something\n  // than can satisfy this\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.secondary)) {\n    return this.s.replicaSetState.hasSecondary();\n  }\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.primary)) {\n    return this.s.replicaSetState.hasPrimary();\n  }\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.primaryPreferred)) {\n    return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();\n  }\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.secondaryPreferred)) {\n    return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();\n  }\n\n  if (this.s.options.secondaryOnlyConnectionAllowed && this.s.replicaSetState.hasSecondary()) {\n    return true;\n  }\n\n  return this.s.replicaSetState.hasPrimary();\n};\n/**\n * Figure out if the replicaset instance was destroyed by calling destroy\n * @method\n * @return {boolean}\n */\n\n\nReplSet.prototype.isDestroyed = function () {\n  return this.state === DESTROYED;\n};\n\nconst SERVER_SELECTION_TIMEOUT_MS = 10000; // hardcoded `serverSelectionTimeoutMS` for legacy topology\n\nconst SERVER_SELECTION_INTERVAL_MS = 1000; // time to wait between selection attempts\n\n/**\n * Selects a server\n *\n * @method\n * @param {function} selector Unused\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {ClientSession} [options.session] Unused\n * @param {function} callback\n */\n\nReplSet.prototype.selectServer = function (selector, options, callback) {\n  if (typeof selector === 'function' && typeof callback === 'undefined') callback = selector, selector = undefined, options = {};\n  if (typeof options === 'function') callback = options, options = selector;\n  options = options || {};\n  let readPreference;\n\n  if (selector instanceof ReadPreference) {\n    readPreference = selector;\n  } else {\n    readPreference = options.readPreference || ReadPreference.primary;\n  }\n\n  let lastError;\n  const start = now();\n\n  const _selectServer = () => {\n    if (calculateDurationInMs(start) >= SERVER_SELECTION_TIMEOUT_MS) {\n      if (lastError != null) {\n        callback(lastError, null);\n      } else {\n        callback(new MongoError('Server selection timed out'));\n      }\n\n      return;\n    }\n\n    const server = this.s.replicaSetState.pickServer(readPreference);\n\n    if (server == null) {\n      setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);\n      return;\n    }\n\n    if (!(server instanceof Server)) {\n      lastError = server;\n      setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);\n      return;\n    }\n\n    if (this.s.debug) this.emit('pickedServer', options.readPreference, server);\n    callback(null, server);\n  };\n\n  _selectServer();\n};\n/**\n * Get all connected servers\n * @method\n * @return {Server[]}\n */\n\n\nReplSet.prototype.getServers = function () {\n  return this.s.replicaSetState.allServers();\n}; //\n// Execute write operation\n\n\nfunction executeWriteOperation(args, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // TODO: once we drop Node 4, use destructuring either here or in arguments.\n\n  const self = args.self;\n  const op = args.op;\n  const ns = args.ns;\n  const ops = args.ops;\n\n  if (self.state === DESTROYED) {\n    return callback(new MongoError(f('topology was destroyed')));\n  }\n\n  const willRetryWrite = !args.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(self) && !options.session.inTransaction() && options.explain === undefined;\n\n  if (!self.s.replicaSetState.hasPrimary()) {\n    if (self.s.disconnectHandler) {\n      // Not connected but we have a disconnecthandler\n      return self.s.disconnectHandler.add(op, ns, ops, options, callback);\n    } else if (!willRetryWrite) {\n      // No server returned we had an error\n      return callback(new MongoError('no primary server found'));\n    }\n  }\n\n  const handler = (err, result) => {\n    if (!err) return callback(null, result);\n\n    if (!legacyIsRetryableWriteError(err, self)) {\n      err = getMMAPError(err);\n      return callback(err);\n    }\n\n    if (willRetryWrite) {\n      const newArgs = Object.assign({}, args, {\n        retrying: true\n      });\n      return executeWriteOperation(newArgs, options, callback);\n    } // Per SDAM, remove primary from replicaset\n\n\n    if (self.s.replicaSetState.primary) {\n      self.s.replicaSetState.primary.destroy();\n      self.s.replicaSetState.remove(self.s.replicaSetState.primary, {\n        force: true\n      });\n    }\n\n    return callback(err);\n  };\n\n  if (callback.operationId) {\n    handler.operationId = callback.operationId;\n  } // increment and assign txnNumber\n\n\n  if (willRetryWrite) {\n    options.session.incrementTransactionNumber();\n    options.willRetryWrite = willRetryWrite;\n  }\n\n  self.s.replicaSetState.primary[op](ns, ops, options, handler);\n}\n/**\n * Insert one or more documents\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of documents to insert\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\n * @param {opResultCallback} callback A callback function\n */\n\n\nReplSet.prototype.insert = function (ns, ops, options, callback) {\n  // Execute write operation\n  executeWriteOperation({\n    self: this,\n    op: 'insert',\n    ns,\n    ops\n  }, options, callback);\n};\n/**\n * Perform one or more update operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of updates\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\n * @param {opResultCallback} callback A callback function\n */\n\n\nReplSet.prototype.update = function (ns, ops, options, callback) {\n  // Execute write operation\n  executeWriteOperation({\n    self: this,\n    op: 'update',\n    ns,\n    ops\n  }, options, callback);\n};\n/**\n * Perform one or more remove operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of removes\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\n * @param {opResultCallback} callback A callback function\n */\n\n\nReplSet.prototype.remove = function (ns, ops, options, callback) {\n  // Execute write operation\n  executeWriteOperation({\n    self: this,\n    op: 'remove',\n    ns,\n    ops\n  }, options, callback);\n};\n\nconst RETRYABLE_WRITE_OPERATIONS = ['findAndModify', 'insert', 'update', 'delete'];\n\nfunction isWriteCommand(command) {\n  return RETRYABLE_WRITE_OPERATIONS.some(op => command[op]);\n}\n/**\n * Execute a command\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cmd The command hash\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Connection} [options.connection] Specify connection object to execute command against\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\n\n\nReplSet.prototype.command = function (ns, cmd, options, callback) {\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n\n  if (this.state === DESTROYED) return callback(new MongoError(f('topology was destroyed')));\n  var self = this; // Establish readPreference\n\n  var readPreference = options.readPreference ? options.readPreference : ReadPreference.primary; // If the readPreference is primary and we have no primary, store it\n\n  if (readPreference.preference === 'primary' && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  } else if (readPreference.preference === 'secondary' && !this.s.replicaSetState.hasSecondary() && this.s.disconnectHandler != null) {\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  } else if (readPreference.preference !== 'primary' && !this.s.replicaSetState.hasSecondary() && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  } // Pick a server\n\n\n  var server = this.s.replicaSetState.pickServer(readPreference); // We received an error, return it\n\n  if (!(server instanceof Server)) return callback(server); // Emit debug event\n\n  if (self.s.debug) self.emit('pickedServer', ReadPreference.primary, server); // No server returned we had an error\n\n  if (server == null) {\n    return callback(new MongoError(f('no server found that matches the provided readPreference %s', readPreference)));\n  }\n\n  const willRetryWrite = !options.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(self) && !options.session.inTransaction() && isWriteCommand(cmd);\n\n  const cb = (err, result) => {\n    if (!err) return callback(null, result);\n\n    if (!legacyIsRetryableWriteError(err, self)) {\n      return callback(err);\n    }\n\n    if (willRetryWrite) {\n      const newOptions = Object.assign({}, options, {\n        retrying: true\n      });\n      return this.command(ns, cmd, newOptions, callback);\n    } // Per SDAM, remove primary from replicaset\n\n\n    if (this.s.replicaSetState.primary) {\n      this.s.replicaSetState.primary.destroy();\n      this.s.replicaSetState.remove(this.s.replicaSetState.primary, {\n        force: true\n      });\n    }\n\n    return callback(err);\n  }; // increment and assign txnNumber\n\n\n  if (willRetryWrite) {\n    options.session.incrementTransactionNumber();\n    options.willRetryWrite = willRetryWrite;\n  } // Execute the command\n\n\n  server.command(ns, cmd, options, cb);\n};\n/**\n * Get a new cursor\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId\n * @param {object} [options] Options for the cursor\n * @param {object} [options.batchSize=0] Batchsize for the operation\n * @param {array} [options.documents=[]] Initial documents list for cursor\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {object} [options.topology] The internal topology of the created cursor\n * @returns {Cursor}\n */\n\n\nReplSet.prototype.cursor = function (ns, cmd, options) {\n  options = options || {};\n  const topology = options.topology || this; // Set up final cursor type\n\n  var FinalCursor = options.cursorFactory || this.s.Cursor; // Return the cursor\n\n  return new FinalCursor(topology, ns, cmd, options);\n};\n/**\n * A replset connect event, used to verify that the connection is up and running\n *\n * @event ReplSet#connect\n * @type {ReplSet}\n */\n\n/**\n * A replset reconnect event, used to verify that the topology reconnected\n *\n * @event ReplSet#reconnect\n * @type {ReplSet}\n */\n\n/**\n * A replset fullsetup event, used to signal that all topology members have been contacted.\n *\n * @event ReplSet#fullsetup\n * @type {ReplSet}\n */\n\n/**\n * A replset all event, used to signal that all topology members have been contacted.\n *\n * @event ReplSet#all\n * @type {ReplSet}\n */\n\n/**\n * A replset failed event, used to signal that initial replset connection failed.\n *\n * @event ReplSet#failed\n * @type {ReplSet}\n */\n\n/**\n * A server member left the replicaset\n *\n * @event ReplSet#left\n * @type {function}\n * @param {string} type The type of member that left (primary|secondary|arbiter)\n * @param {Server} server The server object that left\n */\n\n/**\n * A server member joined the replicaset\n *\n * @event ReplSet#joined\n * @type {function}\n * @param {string} type The type of member that joined (primary|secondary|arbiter)\n * @param {Server} server The server object that joined\n */\n\n/**\n * A server opening SDAM monitoring event\n *\n * @event ReplSet#serverOpening\n * @type {object}\n */\n\n/**\n * A server closed SDAM monitoring event\n *\n * @event ReplSet#serverClosed\n * @type {object}\n */\n\n/**\n * A server description SDAM change monitoring event\n *\n * @event ReplSet#serverDescriptionChanged\n * @type {object}\n */\n\n/**\n * A topology open SDAM event\n *\n * @event ReplSet#topologyOpening\n * @type {object}\n */\n\n/**\n * A topology closed SDAM event\n *\n * @event ReplSet#topologyClosed\n * @type {object}\n */\n\n/**\n * A topology structure SDAM change event\n *\n * @event ReplSet#topologyDescriptionChanged\n * @type {object}\n */\n\n/**\n * A topology serverHeartbeatStarted SDAM event\n *\n * @event ReplSet#serverHeartbeatStarted\n * @type {object}\n */\n\n/**\n * A topology serverHeartbeatFailed SDAM event\n *\n * @event ReplSet#serverHeartbeatFailed\n * @type {object}\n */\n\n/**\n * A topology serverHeartbeatSucceeded SDAM change event\n *\n * @event ReplSet#serverHeartbeatSucceeded\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command was started, if command monitoring is enabled\n *\n * @event ReplSet#commandStarted\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command succeeded, if command monitoring is enabled\n *\n * @event ReplSet#commandSucceeded\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command failed, if command monitoring is enabled\n *\n * @event ReplSet#commandFailed\n * @type {object}\n */\n\n\nmodule.exports = ReplSet;","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/core/topologies/replset.js"],"names":["inherits","require","f","format","EventEmitter","ReadPreference","CoreCursor","retrieveBSON","Logger","MongoError","Server","ReplSetState","Timeout","Interval","SessionMixins","isRetryableWritesSupported","relayEvents","BSON","getMMAPError","makeClientMetadata","legacyIsRetryableWriteError","now","calculateDurationInMs","DISCONNECTED","CONNECTING","CONNECTED","UNREFERENCED","DESTROYED","stateTransition","self","newState","legalTransitions","disconnected","connecting","connected","unreferenced","destroyed","legalStates","state","indexOf","s","logger","error","id","handlers","ReplSet","seedlist","options","Array","isArray","length","forEach","e","host","port","call","localThresholdMS","acceptableLatency","Object","assign","metadata","bson","Binary","Code","DBRef","Decimal128","Double","Int32","Long","Map","MaxKey","MinKey","ObjectId","BSONRegExp","Symbol","Timestamp","Cursor","cursorFactory","replicaSetState","setName","heartbeatFrequencyMS","haInterval","connectingServers","minHeartbeatFrequencyMS","disconnectHandler","index","connectOptions","debug","on","r","emit","isWarn","socketTimeout","warn","types","x","t","initialConnectState","connect","fullsetup","all","haTimeoutId","ismaster","intervalIds","clusterTime","prototype","defineProperty","enumerable","get","native","logicalSessionTimeoutMinutes","rexecuteOperations","hasPrimaryAndSecondary","execute","hasPrimary","executePrimary","hasSecondary","executeSecondary","connectNewServers","servers","callback","count","done","_handleEvent","event","err","_self","destroy","force","result","update","lastIsMaster","i","removeAllListeners","handleEvent","monitorServer","me","_server","setTimeout","existingServerIdx","findIndex","name","connectingServer","splice","server","split","parseInt","reconnect","monitoring","parent","once","push","pingServer","cb","start","Date","getTime","emitSDAMEvent","connectionId","command","connectionTimeout","latencyMS","lastUpdateTime","durationMS","failure","remove","lastWrite","lastWriteDate","lastIsMasterMS","reply","updateServerMaxStaleness","__host","_process","_haInterval","intervalId","stop","filter","isRunning","secondaryOnlyConnectionAllowed","process","nextTick","topologyMonitor","keys","set","unknownServers","executeReconnect","monitoringFrequencey","intervalTime","addServerToList","list","toLowerCase","isDebug","shouldTriggerConnect","isConnecting","readPreferenceSecondary","readPreference","equals","secondary","handleInitialConnectEvent","_this","JSON","stringify","connectServers","concat","timeoutInterval","shift","description","listeners","map","topologyId","auth","credentials","destroyCount","serverDestroyed","clearTimeout","unref","allServers","secondaries","primary","connections","isConnected","primaryPreferred","secondaryPreferred","isDestroyed","SERVER_SELECTION_TIMEOUT_MS","SERVER_SELECTION_INTERVAL_MS","selectServer","selector","undefined","lastError","_selectServer","pickServer","getServers","executeWriteOperation","args","op","ns","ops","willRetryWrite","retrying","retryWrites","session","inTransaction","explain","add","handler","newArgs","operationId","incrementTransactionNumber","insert","RETRYABLE_WRITE_OPERATIONS","isWriteCommand","some","cmd","preference","newOptions","cursor","topology","FinalCursor","module","exports"],"mappings":"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L,WAAJ,CAAgBD,QAAhB,EAA0BrB,EAA1B,EAA8BiB,GAA9B,EAAmC9M,OAAnC,CAAP;AACD,CATD;AAWA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEAoN,MAAM,CAACC,OAAP,GAAiBvN,OAAjB","sourcesContent":["'use strict';\n\nconst inherits = require('util').inherits;\nconst f = require('util').format;\nconst EventEmitter = require('events').EventEmitter;\nconst ReadPreference = require('./read_preference');\nconst CoreCursor = require('../cursor').CoreCursor;\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\nconst Logger = require('../connection/logger');\nconst MongoError = require('../error').MongoError;\nconst Server = require('./server');\nconst ReplSetState = require('./replset_state');\nconst Timeout = require('./shared').Timeout;\nconst Interval = require('./shared').Interval;\nconst SessionMixins = require('./shared').SessionMixins;\nconst isRetryableWritesSupported = require('./shared').isRetryableWritesSupported;\nconst relayEvents = require('../utils').relayEvents;\nconst BSON = retrieveBSON();\nconst getMMAPError = require('./shared').getMMAPError;\nconst makeClientMetadata = require('../utils').makeClientMetadata;\nconst legacyIsRetryableWriteError = require('./shared').legacyIsRetryableWriteError;\nconst now = require('../../utils').now;\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs;\n\n//\n// States\nvar DISCONNECTED = 'disconnected';\nvar CONNECTING = 'connecting';\nvar CONNECTED = 'connected';\nvar UNREFERENCED = 'unreferenced';\nvar DESTROYED = 'destroyed';\n\nfunction stateTransition(self, newState) {\n  var legalTransitions = {\n    disconnected: [CONNECTING, DESTROYED, DISCONNECTED],\n    connecting: [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],\n    connected: [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],\n    unreferenced: [UNREFERENCED, DESTROYED],\n    destroyed: [DESTROYED]\n  };\n\n  // Get current state\n  var legalStates = legalTransitions[self.state];\n  if (legalStates && legalStates.indexOf(newState) !== -1) {\n    self.state = newState;\n  } else {\n    self.s.logger.error(\n      f(\n        'Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]',\n        self.id,\n        self.state,\n        newState,\n        legalStates\n      )\n    );\n  }\n}\n\n//\n// ReplSet instance id\nvar id = 1;\nvar handlers = ['connect', 'close', 'error', 'timeout', 'parseError'];\n\n/**\n * Creates a new Replset instance\n * @class\n * @param {array} seedlist A list of seeds for the replicaset\n * @param {boolean} options.setName The Replicaset set name\n * @param {boolean} [options.secondaryOnlyConnectionAllowed=false] Allow connection to a secondary only replicaset\n * @param {number} [options.haInterval=10000] The High availability period for replicaset inquiry\n * @param {boolean} [options.emitError=false] Server will emit errors events\n * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors\n * @param {number} [options.size=5] Server connection pool size\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=10000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {number} [options.pingInterval=5000] Ping interval to check the response time to the different servers\n * @param {number} [options.localThresholdMS=15] Cutoff latency point in MS for Replicaset member selection\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\n * @return {ReplSet} A cursor instance\n * @fires ReplSet#connect\n * @fires ReplSet#ha\n * @fires ReplSet#joined\n * @fires ReplSet#left\n * @fires ReplSet#failed\n * @fires ReplSet#fullsetup\n * @fires ReplSet#all\n * @fires ReplSet#error\n * @fires ReplSet#serverHeartbeatStarted\n * @fires ReplSet#serverHeartbeatSucceeded\n * @fires ReplSet#serverHeartbeatFailed\n * @fires ReplSet#topologyOpening\n * @fires ReplSet#topologyClosed\n * @fires ReplSet#topologyDescriptionChanged\n * @property {string} type the topology type.\n * @property {string} parserType the parser type used (c++ or js).\n */\nvar ReplSet = function(seedlist, options) {\n  var self = this;\n  options = options || {};\n\n  // Validate seedlist\n  if (!Array.isArray(seedlist)) throw new MongoError('seedlist must be an array');\n  // Validate list\n  if (seedlist.length === 0) throw new MongoError('seedlist must contain at least one entry');\n  // Validate entries\n  seedlist.forEach(function(e) {\n    if (typeof e.host !== 'string' || typeof e.port !== 'number')\n      throw new MongoError('seedlist entry must contain a host and port');\n  });\n\n  // Add event listener\n  EventEmitter.call(this);\n\n  // Get replSet Id\n  this.id = id++;\n\n  // Get the localThresholdMS\n  var localThresholdMS = options.localThresholdMS || 15;\n  // Backward compatibility\n  if (options.acceptableLatency) localThresholdMS = options.acceptableLatency;\n\n  // Create a logger\n  var logger = Logger('ReplSet', options);\n\n  // Internal state\n  this.s = {\n    options: Object.assign({ metadata: makeClientMetadata(options) }, options),\n    // BSON instance\n    bson:\n      options.bson ||\n      new BSON([\n        BSON.Binary,\n        BSON.Code,\n        BSON.DBRef,\n        BSON.Decimal128,\n        BSON.Double,\n        BSON.Int32,\n        BSON.Long,\n        BSON.Map,\n        BSON.MaxKey,\n        BSON.MinKey,\n        BSON.ObjectId,\n        BSON.BSONRegExp,\n        BSON.Symbol,\n        BSON.Timestamp\n      ]),\n    // Factory overrides\n    Cursor: options.cursorFactory || CoreCursor,\n    // Logger instance\n    logger: logger,\n    // Seedlist\n    seedlist: seedlist,\n    // Replicaset state\n    replicaSetState: new ReplSetState({\n      id: this.id,\n      setName: options.setName,\n      acceptableLatency: localThresholdMS,\n      heartbeatFrequencyMS: options.haInterval ? options.haInterval : 10000,\n      logger: logger\n    }),\n    // Current servers we are connecting to\n    connectingServers: [],\n    // Ha interval\n    haInterval: options.haInterval ? options.haInterval : 10000,\n    // Minimum heartbeat frequency used if we detect a server close\n    minHeartbeatFrequencyMS: 500,\n    // Disconnect handler\n    disconnectHandler: options.disconnectHandler,\n    // Server selection index\n    index: 0,\n    // Connect function options passed in\n    connectOptions: {},\n    // Are we running in debug mode\n    debug: typeof options.debug === 'boolean' ? options.debug : false\n  };\n\n  // Add handler for topology change\n  this.s.replicaSetState.on('topologyDescriptionChanged', function(r) {\n    self.emit('topologyDescriptionChanged', r);\n  });\n\n  // Log info warning if the socketTimeout < haInterval as it will cause\n  // a lot of recycled connections to happen.\n  if (\n    this.s.logger.isWarn() &&\n    this.s.options.socketTimeout !== 0 &&\n    this.s.options.socketTimeout < this.s.haInterval\n  ) {\n    this.s.logger.warn(\n      f(\n        'warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts',\n        this.s.options.socketTimeout,\n        this.s.haInterval\n      )\n    );\n  }\n\n  // Add forwarding of events from state handler\n  var types = ['joined', 'left'];\n  types.forEach(function(x) {\n    self.s.replicaSetState.on(x, function(t, s) {\n      self.emit(x, t, s);\n    });\n  });\n\n  // Connect stat\n  this.initialConnectState = {\n    connect: false,\n    fullsetup: false,\n    all: false\n  };\n\n  // Disconnected state\n  this.state = DISCONNECTED;\n  this.haTimeoutId = null;\n  // Last ismaster\n  this.ismaster = null;\n  // Contains the intervalId\n  this.intervalIds = [];\n\n  // Highest clusterTime seen in responses from the current deployment\n  this.clusterTime = null;\n};\n\ninherits(ReplSet, EventEmitter);\nObject.assign(ReplSet.prototype, SessionMixins);\n\nObject.defineProperty(ReplSet.prototype, 'type', {\n  enumerable: true,\n  get: function() {\n    return 'replset';\n  }\n});\n\nObject.defineProperty(ReplSet.prototype, 'parserType', {\n  enumerable: true,\n  get: function() {\n    return BSON.native ? 'c++' : 'js';\n  }\n});\n\nObject.defineProperty(ReplSet.prototype, 'logicalSessionTimeoutMinutes', {\n  enumerable: true,\n  get: function() {\n    return this.s.replicaSetState.logicalSessionTimeoutMinutes || null;\n  }\n});\n\nfunction rexecuteOperations(self) {\n  // If we have a primary and a disconnect handler, execute\n  // buffered operations\n  if (self.s.replicaSetState.hasPrimaryAndSecondary() && self.s.disconnectHandler) {\n    self.s.disconnectHandler.execute();\n  } else if (self.s.replicaSetState.hasPrimary() && self.s.disconnectHandler) {\n    self.s.disconnectHandler.execute({ executePrimary: true });\n  } else if (self.s.replicaSetState.hasSecondary() && self.s.disconnectHandler) {\n    self.s.disconnectHandler.execute({ executeSecondary: true });\n  }\n}\n\nfunction connectNewServers(self, servers, callback) {\n  // No new servers\n  if (servers.length === 0) {\n    return callback();\n  }\n\n  // Count lefts\n  var count = servers.length;\n  var error = null;\n\n  function done() {\n    count = count - 1;\n    if (count === 0) {\n      callback(error);\n    }\n  }\n\n  // Handle events\n  var _handleEvent = function(self, event) {\n    return function(err) {\n      var _self = this;\n\n      // Destroyed\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        this.destroy({ force: true });\n        return done();\n      }\n\n      if (event === 'connect') {\n        // Update the state\n        var result = self.s.replicaSetState.update(_self);\n        // Update the state with the new server\n        if (result) {\n          // Primary lastIsMaster store it\n          if (_self.lastIsMaster() && _self.lastIsMaster().ismaster) {\n            self.ismaster = _self.lastIsMaster();\n          }\n\n          // Remove the handlers\n          for (let i = 0; i < handlers.length; i++) {\n            _self.removeAllListeners(handlers[i]);\n          }\n\n          // Add stable state handlers\n          _self.on('error', handleEvent(self, 'error'));\n          _self.on('close', handleEvent(self, 'close'));\n          _self.on('timeout', handleEvent(self, 'timeout'));\n          _self.on('parseError', handleEvent(self, 'parseError'));\n\n          // Enalbe the monitoring of the new server\n          monitorServer(_self.lastIsMaster().me, self, {});\n\n          // Rexecute any stalled operation\n          rexecuteOperations(self);\n        } else {\n          _self.destroy({ force: true });\n        }\n      } else if (event === 'error') {\n        error = err;\n      }\n\n      // Rexecute any stalled operation\n      rexecuteOperations(self);\n      done();\n    };\n  };\n\n  // Execute method\n  function execute(_server, i) {\n    setTimeout(function() {\n      // Destroyed\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        return;\n      }\n\n      // remove existing connecting server if it's failed to connect, otherwise\n      // wait for that server to connect\n      const existingServerIdx = self.s.connectingServers.findIndex(s => s.name === _server);\n      if (existingServerIdx >= 0) {\n        const connectingServer = self.s.connectingServers[existingServerIdx];\n        connectingServer.destroy({ force: true });\n\n        self.s.connectingServers.splice(existingServerIdx, 1);\n        return done();\n      }\n\n      // Create a new server instance\n      var server = new Server(\n        Object.assign({}, self.s.options, {\n          host: _server.split(':')[0],\n          port: parseInt(_server.split(':')[1], 10),\n          reconnect: false,\n          monitoring: false,\n          parent: self\n        })\n      );\n\n      // Add temp handlers\n      server.once('connect', _handleEvent(self, 'connect'));\n      server.once('close', _handleEvent(self, 'close'));\n      server.once('timeout', _handleEvent(self, 'timeout'));\n      server.once('error', _handleEvent(self, 'error'));\n      server.once('parseError', _handleEvent(self, 'parseError'));\n\n      // SDAM Monitoring events\n      server.on('serverOpening', e => self.emit('serverOpening', e));\n      server.on('serverDescriptionChanged', e => self.emit('serverDescriptionChanged', e));\n      server.on('serverClosed', e => self.emit('serverClosed', e));\n\n      // Command Monitoring events\n      relayEvents(server, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);\n\n      self.s.connectingServers.push(server);\n      server.connect(self.s.connectOptions);\n    }, i);\n  }\n\n  // Create new instances\n  for (var i = 0; i < servers.length; i++) {\n    execute(servers[i], i);\n  }\n}\n\n// Ping the server\nvar pingServer = function(self, server, cb) {\n  // Measure running time\n  var start = new Date().getTime();\n\n  // Emit the server heartbeat start\n  emitSDAMEvent(self, 'serverHeartbeatStarted', { connectionId: server.name });\n\n  // Execute ismaster\n  // Set the socketTimeout for a monitoring message to a low number\n  // Ensuring ismaster calls are timed out quickly\n  server.command(\n    'admin.$cmd',\n    {\n      ismaster: true\n    },\n    {\n      monitoring: true,\n      socketTimeout: self.s.options.connectionTimeout || 2000\n    },\n    function(err, r) {\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        server.destroy({ force: true });\n        return cb(err, r);\n      }\n\n      // Calculate latency\n      var latencyMS = new Date().getTime() - start;\n\n      // Set the last updatedTime\n      server.lastUpdateTime = now();\n\n      // We had an error, remove it from the state\n      if (err) {\n        // Emit the server heartbeat failure\n        emitSDAMEvent(self, 'serverHeartbeatFailed', {\n          durationMS: latencyMS,\n          failure: err,\n          connectionId: server.name\n        });\n\n        // Remove server from the state\n        self.s.replicaSetState.remove(server);\n      } else {\n        // Update the server ismaster\n        server.ismaster = r.result;\n\n        // Check if we have a lastWriteDate convert it to MS\n        // and store on the server instance for later use\n        if (server.ismaster.lastWrite && server.ismaster.lastWrite.lastWriteDate) {\n          server.lastWriteDate = server.ismaster.lastWrite.lastWriteDate.getTime();\n        }\n\n        // Do we have a brand new server\n        if (server.lastIsMasterMS === -1) {\n          server.lastIsMasterMS = latencyMS;\n        } else if (server.lastIsMasterMS) {\n          // After the first measurement, average RTT MUST be computed using an\n          // exponentially-weighted moving average formula, with a weighting factor (alpha) of 0.2.\n          // If the prior average is denoted old_rtt, then the new average (new_rtt) is\n          // computed from a new RTT measurement (x) using the following formula:\n          // alpha = 0.2\n          // new_rtt = alpha * x + (1 - alpha) * old_rtt\n          server.lastIsMasterMS = 0.2 * latencyMS + (1 - 0.2) * server.lastIsMasterMS;\n        }\n\n        if (self.s.replicaSetState.update(server)) {\n          // Primary lastIsMaster store it\n          if (server.lastIsMaster() && server.lastIsMaster().ismaster) {\n            self.ismaster = server.lastIsMaster();\n          }\n        }\n\n        // Server heart beat event\n        emitSDAMEvent(self, 'serverHeartbeatSucceeded', {\n          durationMS: latencyMS,\n          reply: r.result,\n          connectionId: server.name\n        });\n      }\n\n      // Calculate the staleness for this server\n      self.s.replicaSetState.updateServerMaxStaleness(server, self.s.haInterval);\n\n      // Callback\n      cb(err, r);\n    }\n  );\n};\n\n// Each server is monitored in parallel in their own timeout loop\nvar monitorServer = function(host, self, options) {\n  // If this is not the initial scan\n  // Is this server already being monitoried, then skip monitoring\n  if (!options.haInterval) {\n    for (var i = 0; i < self.intervalIds.length; i++) {\n      if (self.intervalIds[i].__host === host) {\n        return;\n      }\n    }\n  }\n\n  // Get the haInterval\n  var _process = options.haInterval ? Timeout : Interval;\n  var _haInterval = options.haInterval ? options.haInterval : self.s.haInterval;\n\n  // Create the interval\n  var intervalId = new _process(function() {\n    if (self.state === DESTROYED || self.state === UNREFERENCED) {\n      // clearInterval(intervalId);\n      intervalId.stop();\n      return;\n    }\n\n    // Do we already have server connection available for this host\n    var _server = self.s.replicaSetState.get(host);\n\n    // Check if we have a known server connection and reuse\n    if (_server) {\n      // Ping the server\n      return pingServer(self, _server, function(err) {\n        if (err) {\n          // NOTE: should something happen here?\n          return;\n        }\n\n        if (self.state === DESTROYED || self.state === UNREFERENCED) {\n          intervalId.stop();\n          return;\n        }\n\n        // Filter out all called intervaliIds\n        self.intervalIds = self.intervalIds.filter(function(intervalId) {\n          return intervalId.isRunning();\n        });\n\n        // Initial sweep\n        if (_process === Timeout) {\n          if (\n            self.state === CONNECTING &&\n            ((self.s.replicaSetState.hasSecondary() &&\n              self.s.options.secondaryOnlyConnectionAllowed) ||\n              self.s.replicaSetState.hasPrimary())\n          ) {\n            stateTransition(self, CONNECTED);\n\n            // Emit connected sign\n            process.nextTick(function() {\n              self.emit('connect', self);\n            });\n\n            // Start topology interval check\n            topologyMonitor(self, {});\n          }\n        } else {\n          if (\n            self.state === DISCONNECTED &&\n            ((self.s.replicaSetState.hasSecondary() &&\n              self.s.options.secondaryOnlyConnectionAllowed) ||\n              self.s.replicaSetState.hasPrimary())\n          ) {\n            stateTransition(self, CONNECTED);\n\n            // Rexecute any stalled operation\n            rexecuteOperations(self);\n\n            // Emit connected sign\n            process.nextTick(function() {\n              self.emit('reconnect', self);\n            });\n          }\n        }\n\n        if (\n          self.initialConnectState.connect &&\n          !self.initialConnectState.fullsetup &&\n          self.s.replicaSetState.hasPrimaryAndSecondary()\n        ) {\n          // Set initial connect state\n          self.initialConnectState.fullsetup = true;\n          self.initialConnectState.all = true;\n\n          process.nextTick(function() {\n            self.emit('fullsetup', self);\n            self.emit('all', self);\n          });\n        }\n      });\n    }\n  }, _haInterval);\n\n  // Start the interval\n  intervalId.start();\n  // Add the intervalId host name\n  intervalId.__host = host;\n  // Add the intervalId to our list of intervalIds\n  self.intervalIds.push(intervalId);\n};\n\nfunction topologyMonitor(self, options) {\n  if (self.state === DESTROYED || self.state === UNREFERENCED) return;\n  options = options || {};\n\n  // Get the servers\n  var servers = Object.keys(self.s.replicaSetState.set);\n\n  // Get the haInterval\n  var _process = options.haInterval ? Timeout : Interval;\n  var _haInterval = options.haInterval ? options.haInterval : self.s.haInterval;\n\n  if (_process === Timeout) {\n    return connectNewServers(self, self.s.replicaSetState.unknownServers, function(err) {\n      // Don't emit errors if the connection was already\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        return;\n      }\n\n      if (!self.s.replicaSetState.hasPrimary() && !self.s.options.secondaryOnlyConnectionAllowed) {\n        if (err) {\n          return self.emit('error', err);\n        }\n\n        self.emit(\n          'error',\n          new MongoError('no primary found in replicaset or invalid replica set name')\n        );\n        return self.destroy({ force: true });\n      } else if (\n        !self.s.replicaSetState.hasSecondary() &&\n        self.s.options.secondaryOnlyConnectionAllowed\n      ) {\n        if (err) {\n          return self.emit('error', err);\n        }\n\n        self.emit(\n          'error',\n          new MongoError('no secondary found in replicaset or invalid replica set name')\n        );\n        return self.destroy({ force: true });\n      }\n\n      for (var i = 0; i < servers.length; i++) {\n        monitorServer(servers[i], self, options);\n      }\n    });\n  } else {\n    for (var i = 0; i < servers.length; i++) {\n      monitorServer(servers[i], self, options);\n    }\n  }\n\n  // Run the reconnect process\n  function executeReconnect(self) {\n    return function() {\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        return;\n      }\n\n      connectNewServers(self, self.s.replicaSetState.unknownServers, function() {\n        var monitoringFrequencey = self.s.replicaSetState.hasPrimary()\n          ? _haInterval\n          : self.s.minHeartbeatFrequencyMS;\n\n        // Create a timeout\n        self.intervalIds.push(new Timeout(executeReconnect(self), monitoringFrequencey).start());\n      });\n    };\n  }\n\n  // Decide what kind of interval to use\n  var intervalTime = !self.s.replicaSetState.hasPrimary()\n    ? self.s.minHeartbeatFrequencyMS\n    : _haInterval;\n\n  self.intervalIds.push(new Timeout(executeReconnect(self), intervalTime).start());\n}\n\nfunction addServerToList(list, server) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i].name.toLowerCase() === server.name.toLowerCase()) return true;\n  }\n\n  list.push(server);\n}\n\nfunction handleEvent(self, event) {\n  return function() {\n    if (self.state === DESTROYED || self.state === UNREFERENCED) return;\n    // Debug log\n    if (self.s.logger.isDebug()) {\n      self.s.logger.debug(\n        f('handleEvent %s from server %s in replset with id %s', event, this.name, self.id)\n      );\n    }\n\n    // Remove from the replicaset state\n    self.s.replicaSetState.remove(this);\n\n    // Are we in a destroyed state return\n    if (self.state === DESTROYED || self.state === UNREFERENCED) return;\n\n    // If no primary and secondary available\n    if (\n      !self.s.replicaSetState.hasPrimary() &&\n      !self.s.replicaSetState.hasSecondary() &&\n      self.s.options.secondaryOnlyConnectionAllowed\n    ) {\n      stateTransition(self, DISCONNECTED);\n    } else if (!self.s.replicaSetState.hasPrimary()) {\n      stateTransition(self, DISCONNECTED);\n    }\n\n    addServerToList(self.s.connectingServers, this);\n  };\n}\n\nfunction shouldTriggerConnect(self) {\n  const isConnecting = self.state === CONNECTING;\n  const hasPrimary = self.s.replicaSetState.hasPrimary();\n  const hasSecondary = self.s.replicaSetState.hasSecondary();\n  const secondaryOnlyConnectionAllowed = self.s.options.secondaryOnlyConnectionAllowed;\n  const readPreferenceSecondary =\n    self.s.connectOptions.readPreference &&\n    self.s.connectOptions.readPreference.equals(ReadPreference.secondary);\n\n  return (\n    (isConnecting &&\n      ((readPreferenceSecondary && hasSecondary) || (!readPreferenceSecondary && hasPrimary))) ||\n    (hasSecondary && secondaryOnlyConnectionAllowed)\n  );\n}\n\nfunction handleInitialConnectEvent(self, event) {\n  return function() {\n    var _this = this;\n    // Debug log\n    if (self.s.logger.isDebug()) {\n      self.s.logger.debug(\n        f(\n          'handleInitialConnectEvent %s from server %s in replset with id %s',\n          event,\n          this.name,\n          self.id\n        )\n      );\n    }\n\n    // Destroy the instance\n    if (self.state === DESTROYED || self.state === UNREFERENCED) {\n      return this.destroy({ force: true });\n    }\n\n    // Check the type of server\n    if (event === 'connect') {\n      // Update the state\n      var result = self.s.replicaSetState.update(_this);\n      if (result === true) {\n        // Primary lastIsMaster store it\n        if (_this.lastIsMaster() && _this.lastIsMaster().ismaster) {\n          self.ismaster = _this.lastIsMaster();\n        }\n\n        // Debug log\n        if (self.s.logger.isDebug()) {\n          self.s.logger.debug(\n            f(\n              'handleInitialConnectEvent %s from server %s in replset with id %s has state [%s]',\n              event,\n              _this.name,\n              self.id,\n              JSON.stringify(self.s.replicaSetState.set)\n            )\n          );\n        }\n\n        // Remove the handlers\n        for (let i = 0; i < handlers.length; i++) {\n          _this.removeAllListeners(handlers[i]);\n        }\n\n        // Add stable state handlers\n        _this.on('error', handleEvent(self, 'error'));\n        _this.on('close', handleEvent(self, 'close'));\n        _this.on('timeout', handleEvent(self, 'timeout'));\n        _this.on('parseError', handleEvent(self, 'parseError'));\n\n        // Do we have a primary or primaryAndSecondary\n        if (shouldTriggerConnect(self)) {\n          // We are connected\n          stateTransition(self, CONNECTED);\n\n          // Set initial connect state\n          self.initialConnectState.connect = true;\n          // Emit connect event\n          process.nextTick(function() {\n            self.emit('connect', self);\n          });\n\n          topologyMonitor(self, {});\n        }\n      } else if (result instanceof MongoError) {\n        _this.destroy({ force: true });\n        self.destroy({ force: true });\n        return self.emit('error', result);\n      } else {\n        _this.destroy({ force: true });\n      }\n    } else {\n      // Emit failure to connect\n      self.emit('failed', this);\n\n      addServerToList(self.s.connectingServers, this);\n      // Remove from the state\n      self.s.replicaSetState.remove(this);\n    }\n\n    if (\n      self.initialConnectState.connect &&\n      !self.initialConnectState.fullsetup &&\n      self.s.replicaSetState.hasPrimaryAndSecondary()\n    ) {\n      // Set initial connect state\n      self.initialConnectState.fullsetup = true;\n      self.initialConnectState.all = true;\n\n      process.nextTick(function() {\n        self.emit('fullsetup', self);\n        self.emit('all', self);\n      });\n    }\n\n    // Remove from the list from connectingServers\n    for (var i = 0; i < self.s.connectingServers.length; i++) {\n      if (self.s.connectingServers[i].equals(this)) {\n        self.s.connectingServers.splice(i, 1);\n      }\n    }\n\n    // Trigger topologyMonitor\n    if (self.s.connectingServers.length === 0 && self.state === CONNECTING) {\n      topologyMonitor(self, { haInterval: 1 });\n    }\n  };\n}\n\nfunction connectServers(self, servers) {\n  // Update connectingServers\n  self.s.connectingServers = self.s.connectingServers.concat(servers);\n\n  // Index used to interleaf the server connects, avoiding\n  // runtime issues on io constrained vm's\n  var timeoutInterval = 0;\n\n  function connect(server, timeoutInterval) {\n    setTimeout(function() {\n      // Add the server to the state\n      if (self.s.replicaSetState.update(server)) {\n        // Primary lastIsMaster store it\n        if (server.lastIsMaster() && server.lastIsMaster().ismaster) {\n          self.ismaster = server.lastIsMaster();\n        }\n      }\n\n      // Add event handlers\n      server.once('close', handleInitialConnectEvent(self, 'close'));\n      server.once('timeout', handleInitialConnectEvent(self, 'timeout'));\n      server.once('parseError', handleInitialConnectEvent(self, 'parseError'));\n      server.once('error', handleInitialConnectEvent(self, 'error'));\n      server.once('connect', handleInitialConnectEvent(self, 'connect'));\n\n      // SDAM Monitoring events\n      server.on('serverOpening', e => self.emit('serverOpening', e));\n      server.on('serverDescriptionChanged', e => self.emit('serverDescriptionChanged', e));\n      server.on('serverClosed', e => self.emit('serverClosed', e));\n\n      // Command Monitoring events\n      relayEvents(server, self, ['commandStarted', 'commandSucceeded', 'commandFailed']);\n\n      // Start connection\n      server.connect(self.s.connectOptions);\n    }, timeoutInterval);\n  }\n\n  // Start all the servers\n  while (servers.length > 0) {\n    connect(servers.shift(), timeoutInterval++);\n  }\n}\n\n/**\n * Emit event if it exists\n * @method\n */\nfunction emitSDAMEvent(self, event, description) {\n  if (self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n}\n\n/**\n * Initiate server connect\n */\nReplSet.prototype.connect = function(options) {\n  var self = this;\n  // Add any connect level options to the internal state\n  this.s.connectOptions = options || {};\n\n  // Set connecting state\n  stateTransition(this, CONNECTING);\n\n  // Create server instances\n  var servers = this.s.seedlist.map(function(x) {\n    return new Server(\n      Object.assign({}, self.s.options, x, options, {\n        reconnect: false,\n        monitoring: false,\n        parent: self\n      })\n    );\n  });\n\n  // Error out as high availability interval must be < than socketTimeout\n  if (\n    this.s.options.socketTimeout > 0 &&\n    this.s.options.socketTimeout <= this.s.options.haInterval\n  ) {\n    return self.emit(\n      'error',\n      new MongoError(\n        f(\n          'haInterval [%s] MS must be set to less than socketTimeout [%s] MS',\n          this.s.options.haInterval,\n          this.s.options.socketTimeout\n        )\n      )\n    );\n  }\n\n  // Emit the topology opening event\n  emitSDAMEvent(this, 'topologyOpening', { topologyId: this.id });\n  // Start all server connections\n  connectServers(self, servers);\n};\n\n/**\n * Authenticate the topology.\n * @method\n * @param {MongoCredentials} credentials The credentials for authentication we are using\n * @param {authResultCallback} callback A callback function\n */\nReplSet.prototype.auth = function(credentials, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n\n/**\n * Destroy the server connection\n * @param {boolean} [options.force=false] Force destroy the pool\n * @method\n */\nReplSet.prototype.destroy = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  let destroyCount = this.s.connectingServers.length + 1; // +1 for the callback from `replicaSetState.destroy`\n  const serverDestroyed = () => {\n    destroyCount--;\n    if (destroyCount > 0) {\n      return;\n    }\n\n    // Emit toplogy closing event\n    emitSDAMEvent(this, 'topologyClosed', { topologyId: this.id });\n\n    if (typeof callback === 'function') {\n      callback(null, null);\n    }\n  };\n\n  if (this.state === DESTROYED) {\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  }\n\n  // Transition state\n  stateTransition(this, DESTROYED);\n\n  // Clear out any monitoring process\n  if (this.haTimeoutId) clearTimeout(this.haTimeoutId);\n\n  // Clear out all monitoring\n  for (var i = 0; i < this.intervalIds.length; i++) {\n    this.intervalIds[i].stop();\n  }\n\n  // Reset list of intervalIds\n  this.intervalIds = [];\n\n  if (destroyCount === 0) {\n    serverDestroyed();\n    return;\n  }\n\n  // Destroy the replicaset\n  this.s.replicaSetState.destroy(options, serverDestroyed);\n\n  // Destroy all connecting servers\n  this.s.connectingServers.forEach(function(x) {\n    x.destroy(options, serverDestroyed);\n  });\n};\n\n/**\n * Unref all connections belong to this server\n * @method\n */\nReplSet.prototype.unref = function() {\n  // Transition state\n  stateTransition(this, UNREFERENCED);\n\n  this.s.replicaSetState.allServers().forEach(function(x) {\n    x.unref();\n  });\n\n  clearTimeout(this.haTimeoutId);\n};\n\n/**\n * Returns the last known ismaster document for this server\n * @method\n * @return {object}\n */\nReplSet.prototype.lastIsMaster = function() {\n  // If secondaryOnlyConnectionAllowed and no primary but secondary\n  // return the secondaries ismaster result.\n  if (\n    this.s.options.secondaryOnlyConnectionAllowed &&\n    !this.s.replicaSetState.hasPrimary() &&\n    this.s.replicaSetState.hasSecondary()\n  ) {\n    return this.s.replicaSetState.secondaries[0].lastIsMaster();\n  }\n\n  return this.s.replicaSetState.primary\n    ? this.s.replicaSetState.primary.lastIsMaster()\n    : this.ismaster;\n};\n\n/**\n * All raw connections\n * @method\n * @return {Connection[]}\n */\nReplSet.prototype.connections = function() {\n  var servers = this.s.replicaSetState.allServers();\n  var connections = [];\n  for (var i = 0; i < servers.length; i++) {\n    connections = connections.concat(servers[i].connections());\n  }\n\n  return connections;\n};\n\n/**\n * Figure out if the server is connected\n * @method\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @return {boolean}\n */\nReplSet.prototype.isConnected = function(options) {\n  options = options || {};\n\n  // If we specified a read preference check if we are connected to something\n  // than can satisfy this\n  if (options.readPreference && options.readPreference.equals(ReadPreference.secondary)) {\n    return this.s.replicaSetState.hasSecondary();\n  }\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.primary)) {\n    return this.s.replicaSetState.hasPrimary();\n  }\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.primaryPreferred)) {\n    return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();\n  }\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.secondaryPreferred)) {\n    return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();\n  }\n\n  if (this.s.options.secondaryOnlyConnectionAllowed && this.s.replicaSetState.hasSecondary()) {\n    return true;\n  }\n\n  return this.s.replicaSetState.hasPrimary();\n};\n\n/**\n * Figure out if the replicaset instance was destroyed by calling destroy\n * @method\n * @return {boolean}\n */\nReplSet.prototype.isDestroyed = function() {\n  return this.state === DESTROYED;\n};\n\nconst SERVER_SELECTION_TIMEOUT_MS = 10000; // hardcoded `serverSelectionTimeoutMS` for legacy topology\nconst SERVER_SELECTION_INTERVAL_MS = 1000; // time to wait between selection attempts\n/**\n * Selects a server\n *\n * @method\n * @param {function} selector Unused\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {ClientSession} [options.session] Unused\n * @param {function} callback\n */\nReplSet.prototype.selectServer = function(selector, options, callback) {\n  if (typeof selector === 'function' && typeof callback === 'undefined')\n    (callback = selector), (selector = undefined), (options = {});\n  if (typeof options === 'function') (callback = options), (options = selector);\n  options = options || {};\n\n  let readPreference;\n  if (selector instanceof ReadPreference) {\n    readPreference = selector;\n  } else {\n    readPreference = options.readPreference || ReadPreference.primary;\n  }\n\n  let lastError;\n  const start = now();\n  const _selectServer = () => {\n    if (calculateDurationInMs(start) >= SERVER_SELECTION_TIMEOUT_MS) {\n      if (lastError != null) {\n        callback(lastError, null);\n      } else {\n        callback(new MongoError('Server selection timed out'));\n      }\n\n      return;\n    }\n\n    const server = this.s.replicaSetState.pickServer(readPreference);\n    if (server == null) {\n      setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);\n      return;\n    }\n\n    if (!(server instanceof Server)) {\n      lastError = server;\n      setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);\n      return;\n    }\n\n    if (this.s.debug) this.emit('pickedServer', options.readPreference, server);\n    callback(null, server);\n  };\n\n  _selectServer();\n};\n\n/**\n * Get all connected servers\n * @method\n * @return {Server[]}\n */\nReplSet.prototype.getServers = function() {\n  return this.s.replicaSetState.allServers();\n};\n\n//\n// Execute write operation\nfunction executeWriteOperation(args, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  // TODO: once we drop Node 4, use destructuring either here or in arguments.\n  const self = args.self;\n  const op = args.op;\n  const ns = args.ns;\n  const ops = args.ops;\n\n  if (self.state === DESTROYED) {\n    return callback(new MongoError(f('topology was destroyed')));\n  }\n\n  const willRetryWrite =\n    !args.retrying &&\n    !!options.retryWrites &&\n    options.session &&\n    isRetryableWritesSupported(self) &&\n    !options.session.inTransaction() &&\n    options.explain === undefined;\n\n  if (!self.s.replicaSetState.hasPrimary()) {\n    if (self.s.disconnectHandler) {\n      // Not connected but we have a disconnecthandler\n      return self.s.disconnectHandler.add(op, ns, ops, options, callback);\n    } else if (!willRetryWrite) {\n      // No server returned we had an error\n      return callback(new MongoError('no primary server found'));\n    }\n  }\n\n  const handler = (err, result) => {\n    if (!err) return callback(null, result);\n    if (!legacyIsRetryableWriteError(err, self)) {\n      err = getMMAPError(err);\n      return callback(err);\n    }\n\n    if (willRetryWrite) {\n      const newArgs = Object.assign({}, args, { retrying: true });\n      return executeWriteOperation(newArgs, options, callback);\n    }\n\n    // Per SDAM, remove primary from replicaset\n    if (self.s.replicaSetState.primary) {\n      self.s.replicaSetState.primary.destroy();\n      self.s.replicaSetState.remove(self.s.replicaSetState.primary, { force: true });\n    }\n\n    return callback(err);\n  };\n\n  if (callback.operationId) {\n    handler.operationId = callback.operationId;\n  }\n\n  // increment and assign txnNumber\n  if (willRetryWrite) {\n    options.session.incrementTransactionNumber();\n    options.willRetryWrite = willRetryWrite;\n  }\n\n  self.s.replicaSetState.primary[op](ns, ops, options, handler);\n}\n\n/**\n * Insert one or more documents\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of documents to insert\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\n * @param {opResultCallback} callback A callback function\n */\nReplSet.prototype.insert = function(ns, ops, options, callback) {\n  // Execute write operation\n  executeWriteOperation({ self: this, op: 'insert', ns, ops }, options, callback);\n};\n\n/**\n * Perform one or more update operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of updates\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\n * @param {opResultCallback} callback A callback function\n */\nReplSet.prototype.update = function(ns, ops, options, callback) {\n  // Execute write operation\n  executeWriteOperation({ self: this, op: 'update', ns, ops }, options, callback);\n};\n\n/**\n * Perform one or more remove operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of removes\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {boolean} [options.retryWrites] Enable retryable writes for this operation\n * @param {opResultCallback} callback A callback function\n */\nReplSet.prototype.remove = function(ns, ops, options, callback) {\n  // Execute write operation\n  executeWriteOperation({ self: this, op: 'remove', ns, ops }, options, callback);\n};\n\nconst RETRYABLE_WRITE_OPERATIONS = ['findAndModify', 'insert', 'update', 'delete'];\n\nfunction isWriteCommand(command) {\n  return RETRYABLE_WRITE_OPERATIONS.some(op => command[op]);\n}\n\n/**\n * Execute a command\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cmd The command hash\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Connection} [options.connection] Specify connection object to execute command against\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\nReplSet.prototype.command = function(ns, cmd, options, callback) {\n  if (typeof options === 'function') {\n    (callback = options), (options = {}), (options = options || {});\n  }\n\n  if (this.state === DESTROYED) return callback(new MongoError(f('topology was destroyed')));\n  var self = this;\n\n  // Establish readPreference\n  var readPreference = options.readPreference ? options.readPreference : ReadPreference.primary;\n\n  // If the readPreference is primary and we have no primary, store it\n  if (\n    readPreference.preference === 'primary' &&\n    !this.s.replicaSetState.hasPrimary() &&\n    this.s.disconnectHandler != null\n  ) {\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  } else if (\n    readPreference.preference === 'secondary' &&\n    !this.s.replicaSetState.hasSecondary() &&\n    this.s.disconnectHandler != null\n  ) {\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  } else if (\n    readPreference.preference !== 'primary' &&\n    !this.s.replicaSetState.hasSecondary() &&\n    !this.s.replicaSetState.hasPrimary() &&\n    this.s.disconnectHandler != null\n  ) {\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  }\n\n  // Pick a server\n  var server = this.s.replicaSetState.pickServer(readPreference);\n  // We received an error, return it\n  if (!(server instanceof Server)) return callback(server);\n  // Emit debug event\n  if (self.s.debug) self.emit('pickedServer', ReadPreference.primary, server);\n\n  // No server returned we had an error\n  if (server == null) {\n    return callback(\n      new MongoError(\n        f('no server found that matches the provided readPreference %s', readPreference)\n      )\n    );\n  }\n\n  const willRetryWrite =\n    !options.retrying &&\n    !!options.retryWrites &&\n    options.session &&\n    isRetryableWritesSupported(self) &&\n    !options.session.inTransaction() &&\n    isWriteCommand(cmd);\n\n  const cb = (err, result) => {\n    if (!err) return callback(null, result);\n    if (!legacyIsRetryableWriteError(err, self)) {\n      return callback(err);\n    }\n\n    if (willRetryWrite) {\n      const newOptions = Object.assign({}, options, { retrying: true });\n      return this.command(ns, cmd, newOptions, callback);\n    }\n\n    // Per SDAM, remove primary from replicaset\n    if (this.s.replicaSetState.primary) {\n      this.s.replicaSetState.primary.destroy();\n      this.s.replicaSetState.remove(this.s.replicaSetState.primary, { force: true });\n    }\n\n    return callback(err);\n  };\n\n  // increment and assign txnNumber\n  if (willRetryWrite) {\n    options.session.incrementTransactionNumber();\n    options.willRetryWrite = willRetryWrite;\n  }\n\n  // Execute the command\n  server.command(ns, cmd, options, cb);\n};\n\n/**\n * Get a new cursor\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId\n * @param {object} [options] Options for the cursor\n * @param {object} [options.batchSize=0] Batchsize for the operation\n * @param {array} [options.documents=[]] Initial documents list for cursor\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {object} [options.topology] The internal topology of the created cursor\n * @returns {Cursor}\n */\nReplSet.prototype.cursor = function(ns, cmd, options) {\n  options = options || {};\n  const topology = options.topology || this;\n\n  // Set up final cursor type\n  var FinalCursor = options.cursorFactory || this.s.Cursor;\n\n  // Return the cursor\n  return new FinalCursor(topology, ns, cmd, options);\n};\n\n/**\n * A replset connect event, used to verify that the connection is up and running\n *\n * @event ReplSet#connect\n * @type {ReplSet}\n */\n\n/**\n * A replset reconnect event, used to verify that the topology reconnected\n *\n * @event ReplSet#reconnect\n * @type {ReplSet}\n */\n\n/**\n * A replset fullsetup event, used to signal that all topology members have been contacted.\n *\n * @event ReplSet#fullsetup\n * @type {ReplSet}\n */\n\n/**\n * A replset all event, used to signal that all topology members have been contacted.\n *\n * @event ReplSet#all\n * @type {ReplSet}\n */\n\n/**\n * A replset failed event, used to signal that initial replset connection failed.\n *\n * @event ReplSet#failed\n * @type {ReplSet}\n */\n\n/**\n * A server member left the replicaset\n *\n * @event ReplSet#left\n * @type {function}\n * @param {string} type The type of member that left (primary|secondary|arbiter)\n * @param {Server} server The server object that left\n */\n\n/**\n * A server member joined the replicaset\n *\n * @event ReplSet#joined\n * @type {function}\n * @param {string} type The type of member that joined (primary|secondary|arbiter)\n * @param {Server} server The server object that joined\n */\n\n/**\n * A server opening SDAM monitoring event\n *\n * @event ReplSet#serverOpening\n * @type {object}\n */\n\n/**\n * A server closed SDAM monitoring event\n *\n * @event ReplSet#serverClosed\n * @type {object}\n */\n\n/**\n * A server description SDAM change monitoring event\n *\n * @event ReplSet#serverDescriptionChanged\n * @type {object}\n */\n\n/**\n * A topology open SDAM event\n *\n * @event ReplSet#topologyOpening\n * @type {object}\n */\n\n/**\n * A topology closed SDAM event\n *\n * @event ReplSet#topologyClosed\n * @type {object}\n */\n\n/**\n * A topology structure SDAM change event\n *\n * @event ReplSet#topologyDescriptionChanged\n * @type {object}\n */\n\n/**\n * A topology serverHeartbeatStarted SDAM event\n *\n * @event ReplSet#serverHeartbeatStarted\n * @type {object}\n */\n\n/**\n * A topology serverHeartbeatFailed SDAM event\n *\n * @event ReplSet#serverHeartbeatFailed\n * @type {object}\n */\n\n/**\n * A topology serverHeartbeatSucceeded SDAM change event\n *\n * @event ReplSet#serverHeartbeatSucceeded\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command was started, if command monitoring is enabled\n *\n * @event ReplSet#commandStarted\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command succeeded, if command monitoring is enabled\n *\n * @event ReplSet#commandSucceeded\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command failed, if command monitoring is enabled\n *\n * @event ReplSet#commandFailed\n * @type {object}\n */\n\nmodule.exports = ReplSet;\n"]},"metadata":{},"sourceType":"script"}