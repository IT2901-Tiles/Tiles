{"ast":null,"code":"'use strict';\n\nconst applyRetryableWrites = require('../utils').applyRetryableWrites;\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst MongoError = require('../core').MongoError;\n\nconst OperationBase = require('./operation').OperationBase;\n\nclass BulkWriteOperation extends OperationBase {\n  constructor(collection, operations, options) {\n    super(options);\n    this.collection = collection;\n    this.operations = operations;\n  }\n\n  execute(callback) {\n    const coll = this.collection;\n    const operations = this.operations;\n    let options = this.options; // Add ignoreUndfined\n\n    if (coll.s.options.ignoreUndefined) {\n      options = Object.assign({}, options);\n      options.ignoreUndefined = coll.s.options.ignoreUndefined;\n    } // Create the bulk operation\n\n\n    const bulk = options.ordered === true || options.ordered == null ? coll.initializeOrderedBulkOp(options) : coll.initializeUnorderedBulkOp(options); // Do we have a collation\n\n    let collation = false; // for each op go through and add to the bulk\n\n    try {\n      for (let i = 0; i < operations.length; i++) {\n        // Get the operation type\n        const key = Object.keys(operations[i])[0]; // Check if we have a collation\n\n        if (operations[i][key].collation) {\n          collation = true;\n        } // Pass to the raw bulk\n\n\n        bulk.raw(operations[i]);\n      }\n    } catch (err) {\n      return callback(err, null);\n    } // Final options for retryable writes and write concern\n\n\n    let finalOptions = Object.assign({}, options);\n    finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n    finalOptions = applyWriteConcern(finalOptions, {\n      db: coll.s.db,\n      collection: coll\n    }, options);\n    const writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};\n    const capabilities = coll.s.topology.capabilities(); // Did the user pass in a collation, check if our write server supports it\n\n    if (collation && capabilities && !capabilities.commandsTakeCollation) {\n      return callback(new MongoError('server/primary/mongos does not support collation'));\n    } // Execute the bulk\n\n\n    bulk.execute(writeCon, finalOptions, (err, r) => {\n      // We have connection level error\n      if (!r && err) {\n        return callback(err, null);\n      }\n\n      r.insertedCount = r.nInserted;\n      r.matchedCount = r.nMatched;\n      r.modifiedCount = r.nModified || 0;\n      r.deletedCount = r.nRemoved;\n      r.upsertedCount = r.getUpsertedIds().length;\n      r.upsertedIds = {};\n      r.insertedIds = {}; // Update the n\n\n      r.n = r.insertedCount; // Inserted documents\n\n      const inserted = r.getInsertedIds(); // Map inserted ids\n\n      for (let i = 0; i < inserted.length; i++) {\n        r.insertedIds[inserted[i].index] = inserted[i]._id;\n      } // Upserted documents\n\n\n      const upserted = r.getUpsertedIds(); // Map upserted ids\n\n      for (let i = 0; i < upserted.length; i++) {\n        r.upsertedIds[upserted[i].index] = upserted[i]._id;\n      } // Return the results\n\n\n      callback(null, r);\n    });\n  }\n\n}\n\nmodule.exports = BulkWriteOperation;","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/operations/bulk_write.js"],"names":["applyRetryableWrites","require","applyWriteConcern","MongoError","OperationBase","BulkWriteOperation","constructor","collection","operations","options","execute","callback","coll","s","ignoreUndefined","Object","assign","bulk","ordered","initializeOrderedBulkOp","initializeUnorderedBulkOp","collation","i","length","key","keys","raw","err","finalOptions","db","writeCon","writeConcern","capabilities","topology","commandsTakeCollation","r","insertedCount","nInserted","matchedCount","nMatched","modifiedCount","nModified","deletedCount","nRemoved","upsertedCount","getUpsertedIds","upsertedIds","insertedIds","n","inserted","getInsertedIds","index","_id","upserted","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst applyRetryableWrites = require('../utils').applyRetryableWrites;\nconst applyWriteConcern = require('../utils').applyWriteConcern;\nconst MongoError = require('../core').MongoError;\nconst OperationBase = require('./operation').OperationBase;\n\nclass BulkWriteOperation extends OperationBase {\n  constructor(collection, operations, options) {\n    super(options);\n\n    this.collection = collection;\n    this.operations = operations;\n  }\n\n  execute(callback) {\n    const coll = this.collection;\n    const operations = this.operations;\n    let options = this.options;\n\n    // Add ignoreUndfined\n    if (coll.s.options.ignoreUndefined) {\n      options = Object.assign({}, options);\n      options.ignoreUndefined = coll.s.options.ignoreUndefined;\n    }\n\n    // Create the bulk operation\n    const bulk =\n      options.ordered === true || options.ordered == null\n        ? coll.initializeOrderedBulkOp(options)\n        : coll.initializeUnorderedBulkOp(options);\n\n    // Do we have a collation\n    let collation = false;\n\n    // for each op go through and add to the bulk\n    try {\n      for (let i = 0; i < operations.length; i++) {\n        // Get the operation type\n        const key = Object.keys(operations[i])[0];\n        // Check if we have a collation\n        if (operations[i][key].collation) {\n          collation = true;\n        }\n\n        // Pass to the raw bulk\n        bulk.raw(operations[i]);\n      }\n    } catch (err) {\n      return callback(err, null);\n    }\n\n    // Final options for retryable writes and write concern\n    let finalOptions = Object.assign({}, options);\n    finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n    finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);\n\n    const writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};\n    const capabilities = coll.s.topology.capabilities();\n\n    // Did the user pass in a collation, check if our write server supports it\n    if (collation && capabilities && !capabilities.commandsTakeCollation) {\n      return callback(new MongoError('server/primary/mongos does not support collation'));\n    }\n\n    // Execute the bulk\n    bulk.execute(writeCon, finalOptions, (err, r) => {\n      // We have connection level error\n      if (!r && err) {\n        return callback(err, null);\n      }\n\n      r.insertedCount = r.nInserted;\n      r.matchedCount = r.nMatched;\n      r.modifiedCount = r.nModified || 0;\n      r.deletedCount = r.nRemoved;\n      r.upsertedCount = r.getUpsertedIds().length;\n      r.upsertedIds = {};\n      r.insertedIds = {};\n\n      // Update the n\n      r.n = r.insertedCount;\n\n      // Inserted documents\n      const inserted = r.getInsertedIds();\n      // Map inserted ids\n      for (let i = 0; i < inserted.length; i++) {\n        r.insertedIds[inserted[i].index] = inserted[i]._id;\n      }\n\n      // Upserted documents\n      const upserted = r.getUpsertedIds();\n      // Map upserted ids\n      for (let i = 0; i < upserted.length; i++) {\n        r.upsertedIds[upserted[i].index] = upserted[i]._id;\n      }\n\n      // Return the results\n      callback(null, r);\n    });\n  }\n}\n\nmodule.exports = BulkWriteOperation;\n"]},"metadata":{},"sourceType":"script"}