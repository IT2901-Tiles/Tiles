{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\n\nconst MongoError = require('../error').MongoError;\n\nconst AuthProvider = require('./auth_provider').AuthProvider;\n\nconst BSON = retrieveBSON();\nconst Binary = BSON.Binary;\nlet saslprep;\n\ntry {\n  saslprep = require('saslprep');\n} catch (e) {// don't do anything;\n}\n\nclass ScramSHA extends AuthProvider {\n  constructor(bson, cryptoMethod) {\n    super(bson);\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n\n  prepare(handshakeDoc, authContext, callback) {\n    const cryptoMethod = this.cryptoMethod;\n\n    if (cryptoMethod === 'sha256' && saslprep == null) {\n      console.warn('Warning: no saslprep library specified. Passwords will not be sanitized');\n    }\n\n    crypto.randomBytes(24, (err, nonce) => {\n      if (err) {\n        return callback(err);\n      } // store the nonce for later use\n\n\n      Object.assign(authContext, {\n        nonce\n      });\n      const credentials = authContext.credentials;\n      const request = Object.assign({}, handshakeDoc, {\n        speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n          db: credentials.source\n        })\n      });\n      callback(undefined, request);\n    });\n  }\n\n  auth(authContext, callback) {\n    const response = authContext.response;\n\n    if (response && response.speculativeAuthenticate) {\n      continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);\n      return;\n    }\n\n    executeScram(this.cryptoMethod, authContext, callback);\n  }\n\n}\n\nfunction cleanUsername(username) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\n\nfunction clientFirstMessageBare(username, nonce) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce.toString('base64'), 'utf8')]);\n}\n\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n  const username = cleanUsername(credentials.username);\n  const mechanism = cryptoMethod === 'sha1' ? 'SCRAM-SHA-1' : 'SCRAM-SHA-256'; // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n\n  return {\n    saslStart: 1,\n    mechanism,\n    payload: new Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),\n    autoAuthorize: 1,\n    options: {\n      skipEmptyExchange: true\n    }\n  };\n}\n\nfunction executeScram(cryptoMethod, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  connection.command(`${db}.$cmd`, saslStartCmd, (_err, result) => {\n    const err = resolveError(_err, result);\n\n    if (err) {\n      return callback(err);\n    }\n\n    continueScramConversation(cryptoMethod, result.result, authContext, callback);\n  });\n}\n\nfunction continueScramConversation(cryptoMethod, response, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const username = cleanUsername(credentials.username);\n  const password = credentials.password;\n  let processedPassword;\n\n  if (cryptoMethod === 'sha256') {\n    processedPassword = saslprep ? saslprep(password) : password;\n  } else {\n    try {\n      processedPassword = passwordDigest(username, password);\n    } catch (e) {\n      return callback(e);\n    }\n  }\n\n  const payload = Buffer.isBuffer(response.payload) ? new Binary(response.payload) : response.payload;\n  const dict = parsePayload(payload.value());\n  const iterations = parseInt(dict.i, 10);\n\n  if (iterations && iterations < 4096) {\n    callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);\n    return;\n  }\n\n  const salt = dict.s;\n  const rnonce = dict.r;\n\n  if (rnonce.startsWith('nonce')) {\n    callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);\n    return;\n  } // Set up start of proof\n\n\n  const withoutProof = `c=biws,r=${rnonce}`;\n  const saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  const storedKey = H(cryptoMethod, clientKey);\n  const authMessage = [clientFirstMessageBare(username, nonce), payload.value().toString('base64'), withoutProof].join(',');\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\n  const clientFinal = [withoutProof, clientProof].join(',');\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  const saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new Binary(Buffer.from(clientFinal))\n  };\n  connection.command(`${db}.$cmd`, saslContinueCmd, (_err, result) => {\n    const err = resolveError(_err, result);\n\n    if (err) {\n      return callback(err);\n    }\n\n    const r = result.result;\n    const parsedResponse = parsePayload(r.payload.value());\n\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n      callback(new MongoError('Server returned an invalid signature'));\n      return;\n    }\n\n    if (!r || r.done !== false) {\n      return callback(err, r);\n    }\n\n    const retrySaslContinueCmd = {\n      saslContinue: 1,\n      conversationId: r.conversationId,\n      payload: Buffer.alloc(0)\n    };\n    connection.command(`${db}.$cmd`, retrySaslContinueCmd, callback);\n  });\n}\n\nfunction parsePayload(payload) {\n  const dict = {};\n  const parts = payload.split(',');\n\n  for (let i = 0; i < parts.length; i++) {\n    const valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n}\n\nfunction passwordDigest(username, password) {\n  if (typeof username !== 'string') {\n    throw new MongoError('username must be a string');\n  }\n\n  if (typeof password !== 'string') {\n    throw new MongoError('password must be a string');\n  }\n\n  if (password.length === 0) {\n    throw new MongoError('password cannot be empty');\n  }\n\n  const md5 = crypto.createHash('md5');\n  md5.update(`${username}:mongo:${password}`, 'utf8');\n  return md5.digest('hex');\n} // XOR two buffers\n\n\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\n\nlet _hiCache = {};\nlet _hiCacheCount = 0;\n\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n\n  if (_hiCache[key] !== undefined) {\n    return _hiCache[key];\n  } // generate the salt\n\n\n  const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod); // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  let result = 0;\n\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n\nfunction resolveError(err, result) {\n  if (err) return err;\n  const r = result.result;\n  if (r.$err || r.errmsg) return new MongoError(r);\n}\n\nclass ScramSHA1 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha1');\n  }\n\n}\n\nclass ScramSHA256 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha256');\n  }\n\n}\n\nmodule.exports = {\n  ScramSHA1,\n  ScramSHA256\n};","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/mongodb/lib/core/auth/scram.js"],"names":["crypto","require","Buffer","retrieveBSON","MongoError","AuthProvider","BSON","Binary","saslprep","e","ScramSHA","constructor","bson","cryptoMethod","prepare","handshakeDoc","authContext","callback","console","warn","randomBytes","err","nonce","Object","assign","credentials","request","speculativeAuthenticate","makeFirstMessage","db","source","undefined","auth","response","continueScramConversation","executeScram","cleanUsername","username","replace","clientFirstMessageBare","concat","from","toString","mechanism","saslStart","payload","autoAuthorize","options","skipEmptyExchange","connection","saslStartCmd","command","_err","result","resolveError","password","processedPassword","passwordDigest","isBuffer","dict","parsePayload","value","iterations","parseInt","i","salt","s","rnonce","r","startsWith","withoutProof","saltedPassword","HI","clientKey","HMAC","serverKey","storedKey","H","authMessage","join","clientSignature","clientProof","xor","clientFinal","serverSignature","saslContinueCmd","saslContinue","conversationId","parsedResponse","compareDigest","v","done","retrySaslContinueCmd","alloc","parts","split","length","valueParts","md5","createHash","update","digest","a","b","Math","max","res","push","method","text","key","createHmac","_hiCache","_hiCacheCount","_hiCachePurge","hiLengthMap","sha256","sha1","data","saltedData","pbkdf2Sync","lhs","rhs","timingSafeEqual","$err","errmsg","ScramSHA1","ScramSHA256","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst crypto = require('crypto');\nconst Buffer = require('safe-buffer').Buffer;\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\nconst MongoError = require('../error').MongoError;\nconst AuthProvider = require('./auth_provider').AuthProvider;\n\nconst BSON = retrieveBSON();\nconst Binary = BSON.Binary;\n\nlet saslprep;\ntry {\n  saslprep = require('saslprep');\n} catch (e) {\n  // don't do anything;\n}\n\nclass ScramSHA extends AuthProvider {\n  constructor(bson, cryptoMethod) {\n    super(bson);\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n\n  prepare(handshakeDoc, authContext, callback) {\n    const cryptoMethod = this.cryptoMethod;\n    if (cryptoMethod === 'sha256' && saslprep == null) {\n      console.warn('Warning: no saslprep library specified. Passwords will not be sanitized');\n    }\n\n    crypto.randomBytes(24, (err, nonce) => {\n      if (err) {\n        return callback(err);\n      }\n\n      // store the nonce for later use\n      Object.assign(authContext, { nonce });\n\n      const credentials = authContext.credentials;\n      const request = Object.assign({}, handshakeDoc, {\n        speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n          db: credentials.source\n        })\n      });\n\n      callback(undefined, request);\n    });\n  }\n\n  auth(authContext, callback) {\n    const response = authContext.response;\n    if (response && response.speculativeAuthenticate) {\n      continueScramConversation(\n        this.cryptoMethod,\n        response.speculativeAuthenticate,\n        authContext,\n        callback\n      );\n\n      return;\n    }\n\n    executeScram(this.cryptoMethod, authContext, callback);\n  }\n}\n\nfunction cleanUsername(username) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\n\nfunction clientFirstMessageBare(username, nonce) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([\n    Buffer.from('n=', 'utf8'),\n    Buffer.from(username, 'utf8'),\n    Buffer.from(',r=', 'utf8'),\n    Buffer.from(nonce.toString('base64'), 'utf8')\n  ]);\n}\n\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n  const username = cleanUsername(credentials.username);\n  const mechanism = cryptoMethod === 'sha1' ? 'SCRAM-SHA-1' : 'SCRAM-SHA-256';\n\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return {\n    saslStart: 1,\n    mechanism,\n    payload: new Binary(\n      Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])\n    ),\n    autoAuthorize: 1,\n    options: { skipEmptyExchange: true }\n  };\n}\n\nfunction executeScram(cryptoMethod, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  connection.command(`${db}.$cmd`, saslStartCmd, (_err, result) => {\n    const err = resolveError(_err, result);\n    if (err) {\n      return callback(err);\n    }\n\n    continueScramConversation(cryptoMethod, result.result, authContext, callback);\n  });\n}\n\nfunction continueScramConversation(cryptoMethod, response, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  const nonce = authContext.nonce;\n\n  const db = credentials.source;\n  const username = cleanUsername(credentials.username);\n  const password = credentials.password;\n\n  let processedPassword;\n  if (cryptoMethod === 'sha256') {\n    processedPassword = saslprep ? saslprep(password) : password;\n  } else {\n    try {\n      processedPassword = passwordDigest(username, password);\n    } catch (e) {\n      return callback(e);\n    }\n  }\n\n  const payload = Buffer.isBuffer(response.payload)\n    ? new Binary(response.payload)\n    : response.payload;\n  const dict = parsePayload(payload.value());\n\n  const iterations = parseInt(dict.i, 10);\n  if (iterations && iterations < 4096) {\n    callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);\n    return;\n  }\n\n  const salt = dict.s;\n  const rnonce = dict.r;\n  if (rnonce.startsWith('nonce')) {\n    callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);\n    return;\n  }\n\n  // Set up start of proof\n  const withoutProof = `c=biws,r=${rnonce}`;\n  const saltedPassword = HI(\n    processedPassword,\n    Buffer.from(salt, 'base64'),\n    iterations,\n    cryptoMethod\n  );\n\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  const storedKey = H(cryptoMethod, clientKey);\n  const authMessage = [\n    clientFirstMessageBare(username, nonce),\n    payload.value().toString('base64'),\n    withoutProof\n  ].join(',');\n\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\n  const clientFinal = [withoutProof, clientProof].join(',');\n\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  const saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new Binary(Buffer.from(clientFinal))\n  };\n\n  connection.command(`${db}.$cmd`, saslContinueCmd, (_err, result) => {\n    const err = resolveError(_err, result);\n    if (err) {\n      return callback(err);\n    }\n\n    const r = result.result;\n    const parsedResponse = parsePayload(r.payload.value());\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n      callback(new MongoError('Server returned an invalid signature'));\n      return;\n    }\n\n    if (!r || r.done !== false) {\n      return callback(err, r);\n    }\n\n    const retrySaslContinueCmd = {\n      saslContinue: 1,\n      conversationId: r.conversationId,\n      payload: Buffer.alloc(0)\n    };\n\n    connection.command(`${db}.$cmd`, retrySaslContinueCmd, callback);\n  });\n}\n\nfunction parsePayload(payload) {\n  const dict = {};\n  const parts = payload.split(',');\n  for (let i = 0; i < parts.length; i++) {\n    const valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n}\n\nfunction passwordDigest(username, password) {\n  if (typeof username !== 'string') {\n    throw new MongoError('username must be a string');\n  }\n\n  if (typeof password !== 'string') {\n    throw new MongoError('password must be a string');\n  }\n\n  if (password.length === 0) {\n    throw new MongoError('password cannot be empty');\n  }\n\n  const md5 = crypto.createHash('md5');\n  md5.update(`${username}:mongo:${password}`, 'utf8');\n  return md5.digest('hex');\n}\n\n// XOR two buffers\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto\n    .createHash(method)\n    .update(text)\n    .digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto\n    .createHmac(method, key)\n    .update(text)\n    .digest();\n}\n\nlet _hiCache = {};\nlet _hiCacheCount = 0;\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n  if (_hiCache[key] !== undefined) {\n    return _hiCache[key];\n  }\n\n  // generate the salt\n  const saltedData = crypto.pbkdf2Sync(\n    data,\n    salt,\n    iterations,\n    hiLengthMap[cryptoMethod],\n    cryptoMethod\n  );\n\n  // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  let result = 0;\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n\nfunction resolveError(err, result) {\n  if (err) return err;\n\n  const r = result.result;\n  if (r.$err || r.errmsg) return new MongoError(r);\n}\n\nclass ScramSHA1 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha1');\n  }\n}\n\nclass ScramSHA256 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha256');\n  }\n}\n\nmodule.exports = { ScramSHA1, ScramSHA256 };\n"]},"metadata":{},"sourceType":"script"}