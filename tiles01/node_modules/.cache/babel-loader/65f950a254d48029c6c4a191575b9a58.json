{"ast":null,"code":"import waveEncoder from './wave-encoder/index.js';\nlet AudioContext = window.AudioContext || window.webkitAudioContext;\n\nlet createWorker = fn => {\n  let js = fn.toString().replace(/^(\\(\\)\\s*=>|function\\s*\\(\\))\\s*{/, '').replace(/}$/, '');\n  let blob = new Blob([js]);\n  return new Worker(URL.createObjectURL(blob));\n};\n\nlet error = method => {\n  let event = new Event('error');\n  event.data = new Error('Wrong state for ' + method);\n  return event;\n};\n\nlet context;\n/**\n * Audio Recorder with MediaRecorder API.\n *\n * @example\n * navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {\n *   let recorder = new MediaRecorder(stream)\n * })\n */\n\nclass MediaRecorder {\n  /**\n   * @param {MediaStream} stream The audio stream to record.\n   */\n  constructor(stream, config = null) {\n    /**\n     * The `MediaStream` passed into the constructor.\n     * @type {MediaStream}\n     */\n    this.stream = stream;\n    this.config = config;\n    /**\n     * The current state of recording process.\n     * @type {\"inactive\"|\"recording\"|\"paused\"}\n     */\n\n    this.state = 'inactive';\n    this.em = document.createDocumentFragment();\n    this.encoder = createWorker(MediaRecorder.encoder);\n    let recorder = this;\n    this.encoder.addEventListener('message', e => {\n      let event = new Event('dataavailable');\n      event.data = new Blob([e.data], {\n        type: recorder.mimeType\n      });\n      recorder.em.dispatchEvent(event);\n\n      if (recorder.state === 'inactive') {\n        recorder.em.dispatchEvent(new Event('stop'));\n      }\n    });\n  }\n  /**\n   * Begins recording media.\n   *\n   * @param {number} [timeslice] The milliseconds to record into each `Blob`.\n   *                             If this parameter isn’t included, single `Blob`\n   *                             will be recorded.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * recordButton.addEventListener('click', () => {\n   *   recorder.start()\n   * })\n   */\n\n\n  start(timeslice) {\n    if (this.state !== 'inactive') {\n      return this.em.dispatchEvent(error('start'));\n    }\n\n    this.state = 'recording';\n\n    if (!context) {\n      context = new AudioContext(this.config);\n    }\n\n    this.clone = this.stream.clone();\n    this.input = context.createMediaStreamSource(this.clone);\n    this.processor = context.createScriptProcessor(2048, 1, 1);\n    this.encoder.postMessage(['init', context.sampleRate]);\n\n    this.processor.onaudioprocess = e => {\n      if (this.state === 'recording') {\n        this.encoder.postMessage(['encode', e.inputBuffer.getChannelData(0)]);\n      }\n    };\n\n    this.input.connect(this.processor);\n    this.processor.connect(context.destination);\n    this.em.dispatchEvent(new Event('start'));\n\n    if (timeslice) {\n      this.slicing = setInterval(() => {\n        if (this.state === 'recording') this.requestData();\n      }, timeslice);\n    }\n\n    return undefined;\n  }\n  /**\n   * Stop media capture and raise `dataavailable` event with recorded data.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * finishButton.addEventListener('click', () => {\n   *   recorder.stop()\n   * })\n   */\n\n\n  stop() {\n    if (this.state === 'inactive') {\n      return this.em.dispatchEvent(error('stop'));\n    }\n\n    this.requestData();\n    this.state = 'inactive';\n    this.clone.getTracks().forEach(track => {\n      track.stop();\n    });\n    this.processor.disconnect();\n    this.input.disconnect();\n    return clearInterval(this.slicing);\n  }\n  /**\n   * Pauses recording of media streams.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * pauseButton.addEventListener('click', () => {\n   *   recorder.pause()\n   * })\n   */\n\n\n  pause() {\n    if (this.state !== 'recording') {\n      return this.em.dispatchEvent(error('pause'));\n    }\n\n    this.state = 'paused';\n    return this.em.dispatchEvent(new Event('pause'));\n  }\n  /**\n   * Resumes media recording when it has been previously paused.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * resumeButton.addEventListener('click', () => {\n   *   recorder.resume()\n   * })\n   */\n\n\n  resume() {\n    if (this.state !== 'paused') {\n      return this.em.dispatchEvent(error('resume'));\n    }\n\n    this.state = 'recording';\n    return this.em.dispatchEvent(new Event('resume'));\n  }\n  /**\n   * Raise a `dataavailable` event containing the captured media.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * this.on('nextData', () => {\n   *   recorder.requestData()\n   * })\n   */\n\n\n  requestData() {\n    if (this.state === 'inactive') {\n      return this.em.dispatchEvent(error('requestData'));\n    }\n\n    return this.encoder.postMessage(['dump', context.sampleRate]);\n  }\n  /**\n   * Add listener for specified event type.\n   *\n   * @param {\"start\"|\"stop\"|\"pause\"|\"resume\"|\"dataavailable\"|\"error\"}\n   * type Event type.\n   * @param {function} listener The listener function.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * recorder.addEventListener('dataavailable', e => {\n   *   audio.src = URL.createObjectURL(e.data)\n   * })\n   */\n\n\n  addEventListener(...args) {\n    this.em.addEventListener(...args);\n  }\n  /**\n   * Remove event listener.\n   *\n   * @param {\"start\"|\"stop\"|\"pause\"|\"resume\"|\"dataavailable\"|\"error\"}\n   * type Event type.\n   * @param {function} listener The same function used in `addEventListener`.\n   *\n   * @return {undefined}\n   */\n\n\n  removeEventListener(...args) {\n    this.em.removeEventListener(...args);\n  }\n  /**\n   * Calls each of the listeners registered for a given event.\n   *\n   * @param {Event} event The event object.\n   *\n   * @return {boolean} Is event was no canceled by any listener.\n   */\n\n\n  dispatchEvent(...args) {\n    this.em.dispatchEvent(...args);\n  }\n\n}\n/**\n * The MIME type that is being used for recording.\n * @type {string}\n */\n\n\nMediaRecorder.prototype.mimeType = 'audio/wav';\n/**\n * Returns `true` if the MIME type specified is one the polyfill can record.\n *\n * This polyfill supports `audio/wav` and `audio/mpeg`.\n *\n * @param {string} mimeType The mimeType to check.\n *\n * @return {boolean} `true` on `audio/wav` and `audio/mpeg` MIME type.\n */\n\nMediaRecorder.isTypeSupported = mimeType => {\n  return MediaRecorder.prototype.mimeType === mimeType;\n};\n/**\n * `true` if MediaRecorder can not be polyfilled in the current browser.\n * @type {boolean}\n *\n * @example\n * if (MediaRecorder.notSupported) {\n *   showWarning('Audio recording is not supported in this browser')\n * }\n */\n\n\nMediaRecorder.notSupported = !navigator.mediaDevices || !AudioContext;\n/**\n * Converts RAW audio buffer to compressed audio files.\n * It will be loaded to Web Worker.\n * By default, WAVE encoder will be used.\n * @type {function}\n *\n * @example\n * MediaRecorder.prototype.mimeType = 'audio/ogg'\n * MediaRecorder.encoder = oggEncoder\n */\n\nMediaRecorder.encoder = waveEncoder;\nexport default MediaRecorder;","map":{"version":3,"sources":["C:/Users/StuartGO/projects/bachelorOppgave/Tiles/tiles01/node_modules/audio-recorder-polyfill/index.js"],"names":["waveEncoder","AudioContext","window","webkitAudioContext","createWorker","fn","js","toString","replace","blob","Blob","Worker","URL","createObjectURL","error","method","event","Event","data","Error","context","MediaRecorder","constructor","stream","config","state","em","document","createDocumentFragment","encoder","recorder","addEventListener","e","type","mimeType","dispatchEvent","start","timeslice","clone","input","createMediaStreamSource","processor","createScriptProcessor","postMessage","sampleRate","onaudioprocess","inputBuffer","getChannelData","connect","destination","slicing","setInterval","requestData","undefined","stop","getTracks","forEach","track","disconnect","clearInterval","pause","resume","args","removeEventListener","prototype","isTypeSupported","notSupported","navigator","mediaDevices"],"mappings":"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","sourcesContent":["import waveEncoder from './wave-encoder/index.js'\n\nlet AudioContext = window.AudioContext || window.webkitAudioContext\n\nlet createWorker = fn => {\n  let js = fn\n    .toString()\n    .replace(/^(\\(\\)\\s*=>|function\\s*\\(\\))\\s*{/, '')\n    .replace(/}$/, '')\n  let blob = new Blob([js])\n  return new Worker(URL.createObjectURL(blob))\n}\n\nlet error = method => {\n  let event = new Event('error')\n  event.data = new Error('Wrong state for ' + method)\n  return event\n}\n\nlet context\n\n/**\n * Audio Recorder with MediaRecorder API.\n *\n * @example\n * navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {\n *   let recorder = new MediaRecorder(stream)\n * })\n */\nclass MediaRecorder {\n  /**\n   * @param {MediaStream} stream The audio stream to record.\n   */\n  constructor (stream, config = null) {\n    /**\n     * The `MediaStream` passed into the constructor.\n     * @type {MediaStream}\n     */\n    this.stream = stream\n    this.config = config\n    /**\n     * The current state of recording process.\n     * @type {\"inactive\"|\"recording\"|\"paused\"}\n     */\n    this.state = 'inactive'\n\n    this.em = document.createDocumentFragment()\n    this.encoder = createWorker(MediaRecorder.encoder)\n\n    let recorder = this\n    this.encoder.addEventListener('message', e => {\n      let event = new Event('dataavailable')\n      event.data = new Blob([e.data], { type: recorder.mimeType })\n      recorder.em.dispatchEvent(event)\n      if (recorder.state === 'inactive') {\n        recorder.em.dispatchEvent(new Event('stop'))\n      }\n    })\n  }\n\n  /**\n   * Begins recording media.\n   *\n   * @param {number} [timeslice] The milliseconds to record into each `Blob`.\n   *                             If this parameter isn’t included, single `Blob`\n   *                             will be recorded.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * recordButton.addEventListener('click', () => {\n   *   recorder.start()\n   * })\n   */\n  start (timeslice) {\n    if (this.state !== 'inactive') {\n      return this.em.dispatchEvent(error('start'))\n    }\n\n    this.state = 'recording'\n\n    if (!context) {\n      context = new AudioContext(this.config)\n    }\n    this.clone = this.stream.clone()\n    this.input = context.createMediaStreamSource(this.clone)\n    this.processor = context.createScriptProcessor(2048, 1, 1)\n\n    this.encoder.postMessage(['init', context.sampleRate])\n\n    this.processor.onaudioprocess = e => {\n      if (this.state === 'recording') {\n        this.encoder.postMessage(['encode', e.inputBuffer.getChannelData(0)])\n      }\n    }\n\n    this.input.connect(this.processor)\n    this.processor.connect(context.destination)\n\n    this.em.dispatchEvent(new Event('start'))\n\n    if (timeslice) {\n      this.slicing = setInterval(() => {\n        if (this.state === 'recording') this.requestData()\n      }, timeslice)\n    }\n\n    return undefined\n  }\n\n  /**\n   * Stop media capture and raise `dataavailable` event with recorded data.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * finishButton.addEventListener('click', () => {\n   *   recorder.stop()\n   * })\n   */\n  stop () {\n    if (this.state === 'inactive') {\n      return this.em.dispatchEvent(error('stop'))\n    }\n\n    this.requestData()\n    this.state = 'inactive'\n    this.clone.getTracks().forEach(track => {\n      track.stop()\n    })\n    this.processor.disconnect()\n    this.input.disconnect()\n    return clearInterval(this.slicing)\n  }\n\n  /**\n   * Pauses recording of media streams.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * pauseButton.addEventListener('click', () => {\n   *   recorder.pause()\n   * })\n   */\n  pause () {\n    if (this.state !== 'recording') {\n      return this.em.dispatchEvent(error('pause'))\n    }\n\n    this.state = 'paused'\n    return this.em.dispatchEvent(new Event('pause'))\n  }\n\n  /**\n   * Resumes media recording when it has been previously paused.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * resumeButton.addEventListener('click', () => {\n   *   recorder.resume()\n   * })\n   */\n  resume () {\n    if (this.state !== 'paused') {\n      return this.em.dispatchEvent(error('resume'))\n    }\n\n    this.state = 'recording'\n    return this.em.dispatchEvent(new Event('resume'))\n  }\n\n  /**\n   * Raise a `dataavailable` event containing the captured media.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * this.on('nextData', () => {\n   *   recorder.requestData()\n   * })\n   */\n  requestData () {\n    if (this.state === 'inactive') {\n      return this.em.dispatchEvent(error('requestData'))\n    }\n\n    return this.encoder.postMessage(['dump', context.sampleRate])\n  }\n\n  /**\n   * Add listener for specified event type.\n   *\n   * @param {\"start\"|\"stop\"|\"pause\"|\"resume\"|\"dataavailable\"|\"error\"}\n   * type Event type.\n   * @param {function} listener The listener function.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * recorder.addEventListener('dataavailable', e => {\n   *   audio.src = URL.createObjectURL(e.data)\n   * })\n   */\n  addEventListener (...args) {\n    this.em.addEventListener(...args)\n  }\n\n  /**\n   * Remove event listener.\n   *\n   * @param {\"start\"|\"stop\"|\"pause\"|\"resume\"|\"dataavailable\"|\"error\"}\n   * type Event type.\n   * @param {function} listener The same function used in `addEventListener`.\n   *\n   * @return {undefined}\n   */\n  removeEventListener (...args) {\n    this.em.removeEventListener(...args)\n  }\n\n  /**\n   * Calls each of the listeners registered for a given event.\n   *\n   * @param {Event} event The event object.\n   *\n   * @return {boolean} Is event was no canceled by any listener.\n   */\n  dispatchEvent (...args) {\n    this.em.dispatchEvent(...args)\n  }\n}\n\n/**\n * The MIME type that is being used for recording.\n * @type {string}\n */\nMediaRecorder.prototype.mimeType = 'audio/wav'\n\n/**\n * Returns `true` if the MIME type specified is one the polyfill can record.\n *\n * This polyfill supports `audio/wav` and `audio/mpeg`.\n *\n * @param {string} mimeType The mimeType to check.\n *\n * @return {boolean} `true` on `audio/wav` and `audio/mpeg` MIME type.\n */\nMediaRecorder.isTypeSupported = mimeType => {\n  return MediaRecorder.prototype.mimeType === mimeType\n}\n\n/**\n * `true` if MediaRecorder can not be polyfilled in the current browser.\n * @type {boolean}\n *\n * @example\n * if (MediaRecorder.notSupported) {\n *   showWarning('Audio recording is not supported in this browser')\n * }\n */\nMediaRecorder.notSupported = !navigator.mediaDevices || !AudioContext\n\n/**\n * Converts RAW audio buffer to compressed audio files.\n * It will be loaded to Web Worker.\n * By default, WAVE encoder will be used.\n * @type {function}\n *\n * @example\n * MediaRecorder.prototype.mimeType = 'audio/ogg'\n * MediaRecorder.encoder = oggEncoder\n */\nMediaRecorder.encoder = waveEncoder\n\nexport default MediaRecorder\n"]},"metadata":{},"sourceType":"module"}